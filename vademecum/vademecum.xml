<?xml version="1.0" encoding="UTF-8" ?>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="pl" lang="pl">
<head>
	<title>Vademecum informatyki praktycznej</title>
	
	<link rel="stylesheet" href="lib/base.css" type="text/css" />
	<link rel="stylesheet" href="lib/menu.css" type="text/css" />
	<link rel="stylesheet" href="lib/highlight.css" type="text/css" />
	<script type="text/javascript" src="lib/menu.js" />
	<script type="text/javascript" src="https://rpaciorek.github.io/mathml.css/mspace.js" />
</head><body>

<h1>Vademecum informatyki praktycznej</h1>

<div id="page_menu">
	<ul id="toc"><li>Spis treści</li></ul>
	<p id="menu_extra">
		<a href="http://www.opcode.eu.org/"><img src="lib/opcode.svg" alt="OpCode WWW site" title="Strona należy do serwisu OpCode.eu.org"/></a>
		<a href="vademecum.pdf"><img src="lib/pdfFile.svg" alt="Pobierz jako PDF" title="Pobierz jako PDF"/></a>
	</p>
</div>
<p id="updateInfo">(aktualizacja: 2019-07-05)</p>

<section>
	<p>
		W założeniu ma to być kompleksowy przegląd podstawowych zagadnień z zakresu elektroniki, programowania oraz użytkowania i administracji systemami unixowymi. Nie jest to tutorial, ani samouczek prowadzący krok po kroku w zgłębianie tajników "komputerologii", natomiast tekst ten może być wykorzystywany jako materiał pomocniczy do zająć o takiej tematyce, bądź też materiał służący przypomnieniu / uzupełnieniu posiadanej wiedzy na przedstawiane tematy.
		Korzystanie z tego dokumentu przy samodzielnej nauce jest także możliwe, należy jednak liczyć się z tym że konieczne może być sięganie do innych, bardziej szczegółowych źródeł, a co najważniejsze także duża ilość praktyki i prób samodzielnego rozwiązywania problemów - samo przeczytanie nie wystarczy.
	</p>
	<!--
	ZAŁOŻENIA:
		1) nie jest to tutorial / samouczek, ale raczej materiał służący przypomnieniu / uzupełnieniu posiadanej wiedzy na przedstawiane tematy lub pomocniczy do zająć dydaktycznych
		2) przedewszystkim suche fakty, definicje, opisane przykłady; bez komentarzy typu "obecnie już", "nadal jest używany"; czysty tryb bezosobowy - bez pierwszoosobowych komentarzy i bez bezpośrednich zwrotów do czytelnika
		3) nie linkujemy w tekście (także do wikipedii) - ten tekst ma być kompletny i zamknięty
	-->
	<p>
		Założeniem tego dokumentu było że ma być kompletny i zamknięty, jednym z efektów tego jest unikanie odsyłania do innych materiałów bezpośrednio w tekście, wszystkie odnośniki do zewnętrznych źródeł (za wyjątkiem powoływania się na dokumentację narzędzi/bibliotek) znajdują się wyłącznie w dziale "Literatura".
		Założeniem tego dokumentu było także że ma być w miarę uniwersalny i ponadczasowy (nie zdezaktualizować się po roku) dlatego też skupia się na bardziej uniwersalnych aspektach omawianych zagadnień, faktach, definicjach, itp bez odniesień w stylu "obecnie już", "nadal jest używany", itd, nie pokazuje też różnego rodzaju sztuczek czy obejść doraźnych problemów, ani nie omawia szczegółów technologii szybko zmieniających się.
	</p>
</section>

<section>
	<h2>Elektronika</h2>
	<!-- BEGIN: Elektronika - intro -->
	<p>Elektronika zajmuje się wytwarzaniem i przetwarzaniem sygnałów w postaci prądów i napięć elektrycznych.
		Zjawisko prądu związane jest z przepływem ładunku (z uporządkowanym ruchem nośników ładunku), aby wystąpiło konieczna jest różnica potencjałów (napięcie) pomiędzy końcami przewodnika, prowadzi ono do neutralizacji tej różnicy.
		Dlatego dla podtrzymania stałej różnicy potencjałów konieczne jest istnienie źródeł prądu, prowadzących do rozdzielania ładunków dodatnich od ujemnych.</p>
	<section>
		<h3>Podstawy</h3>
		<section>
			<h4>Napięcie i prąd</h4>
			<p>Dla elementów liniowych (np. zwykły kawałek przewodu) zachodzi proporcjonalność natężenia prądu płynącego przez taki element do napięcia pomiędzy jego końcami: <m>R = \sfrac{U}{I}</m>.</p>
			<dl>
				<dt><dfn>Natężenie prądu elektrycznego</dfn> <dfn><m>I</m></dfn> (określane skrótowo jako <dfn>prąd</dfn>)</dt>
				<dd>jest to stosunek przemieszczonego ładunku do czasu jego przepływu.</dd>
				
				<dt><dfn>Napięcie elektryczne</dfn> <dfn><m>U</m></dfn> pomiędzy punktem A i B (jakiegoś obwodu)</dt>
				<dd>jest to różnica potencjału elektrycznego w punkcie A i w punkcie B.</dd>
				
				<dt><dfn>Potencjał elektryczny</dfn> <dfn><m>V</m></dfn> w punkcie A</dt>
				<dd>
					jest skalarną wielkością charakteryzującą pole elektryczne w danym punkcie. Odpowiada pracy którą trzeba by wykonać aby przenieść ładunek <m>q</m> z tego punktu do nieskończoności podzielonej przez wielkość tego ładunku (jest niezależny od wartości <m>q</m>).<br />
					W elektronice używa się wartości potencjałów względem umownego potencjału zerowego GND (co umożliwia traktowanie ich jako różnic potencjałów - napięć elektrycznych), w efekcie tego określenia "(stałe) napięcie" i "potencjał" bardzo często stosowane są zamiennie.
				</dd>
				
				<dt><dfn>Masa</dfn>, <dfn>GND</dfn></dt>
				<dd>umowny potencjał zerowy, względem którego wyraża się inne potencjały w układzie (co umożliwia traktowanie ich jako różnic potencjałów - napięć elektrycznych). Potencjał ten może być równy potencjałowi ziemi (masie ochronnej PE), bądź może być z nim nie związany (układy izolowane).</dd>
			</dl>
			
			<p>Podstawowym przykładem teoretycznych (w rzeczywistości mogą występować tylko elementy realizujące ich funkcję w pewnym zakresie i w pewnym przybliżeniu) elementów nieliniowych są:
				<dl>
					<dt><dfn>Idealne źródło prądowe</dfn></dt>
					<dd>wymusza przepływ określonego prądu przez przyłączony układ, niezależnie od spadków napięć w układzie (czyli może odłożyć się na nim dowolne napięcie).</dd>
					
					<dt><dfn>Idealne źródło napięciowe</dfn></dt>
					<dd>wymusza określoną różnicę potencjałów pomiędzy swoimi zaciskami (czyli może przez nie przepływać dowolne natężenie prądu).</dd>
				</dl>
			</p>
			
			<p>Węzeł układu (sam w sobie, pomijając zjawiska pasożytnicze) nie jest w stanie gromadzić ładunku elektrycznego zatem: <em>Suma prądów wpływających do węzła jest równa sumie prądów wypływających z tego węzła.</em></p>
			
			<p>Jeżeli rozważamy obwód zamknięty od punktu A z potencjałem <m>V_A</m> to sumując napięcia na kolejnych elementach obwodu (oporach, źródłach napięciowych, etc) z uwzględnieniem ich znaku gdy wrócimy do punktu A to potencjał nadal musi wynosić <m>V_A</m>, zatem: <em>Suma spadków napięć w zamkniętym obwodzie jest równa zeru.</em></p>
		</section>
		<section>
			<h4>Opór, pojemność i indukcyjność</h4>
			
			<section>
				<h5>Pojęcia</h5>
				<dl>
					<dt><dfn>Rezystancja</dfn> (<dfn>opór</dfn> elektryczny)</dt>
					<dd>wyraża trudność przepływu prądu przez dany przewodnik - im większy opór elementu to (przy takim samym przyłożonym napięciu) będzie płynął mniejszy prąd. <m>R = \sfrac{U}{I}</m></dd>
					
					<dt><dfn>Pojemność</dfn> (wzajemna)</dt>
					<dd>wyraża zdolność do gromadzenia ładunku przez dany element - im większa pojemność tym więcej ładunku (przy takim samym przyłożonym napięciu) zgromadzi element. <m>C = \sfrac{q}{U}</m></dd>
					
					<dt><dfn>Indukcyjność</dfn></dt>
					<dd>wyraża zdolność do wytwarzania strumienia pola magnetycznego związanego z przepływem prądu przez dany element. <m>L = \sfrac{I}{\Phi}</m></dd>
				</dl>
			</section>
			
			<section>
				<h5>Obwody prądu stałego a zmiennego</h5>
				<p>Pojemność oraz indukcyjność wprowadzona do obwodu ma znaczenie tylko gdy zachodzi zmiana natężania prądu płynącego przez obwód / zmiana wartości napięć odłożonych na jego elementach. W stanie ustalonym obwodu prądu stałego wprowadzona do obwodu pojemność oraz indukcyjność nie odgrywają roli, gdyż:
					<ul>
						<li>pojemności zgromadziły już (stosowny do przyłożonego do nich napięcia) ładunek i nie pobierają prądu z obwodu,</li>
						<li>indukcyjności wytworzyły pole magnetyczne (stosowne do przepływającego przez nie prądu) i nie stanowią oporu dla płynącego prądu w obwodzie.</li>
					</ul>
				W takim przypadku można traktować pojemności jako rozwarcia, a indukcyjności jako zwarcia.</p>
				
				<dl>
					<dt><dfn>Impedancja</dfn></dt>
					<dd>jest wielkością charakteryzującą zależność pomiędzy natężeniem prądu i napięciem uwzględniającą reaktancję obwodu. <m>Z = R + j X</m></dd>
					
					<dt><dfn>Reaktancja</dfn></dt>
					<dd>jest wielkością charakteryzującą opór bierny elementów pojemnościowych (<dfn>kapacytancja</dfn> <m>X_C = - \sfrac{1}{\omega C}</m>) i indukcyjnych (<dfn>induktancja</dfn> <m>X_L = \omega L</m>).</dd>
					
					<dt><dfn>Pulsacja</dfn> <dfn><m>\omega</m></dfn></dt>
					<dd>charakteryzuje szybkość zmian (jest proporcjonalna do odwrotności czasu trwania okresu zmiany). <m>\omega = \sfrac{2\pi}{T}</m></dd>
				</dl>
			</section>
			
			<section>
				<h5>Elementy rzeczywiste</h5>
				<dl>
					<dt><dfn>Rezystor</dfn> (<dfn>opornik</dfn>)</dt>
					<dd>wprowadza do układu rezystancję związaną z swoją wartością nominalną. Typowo służy do ograniczania wartości prądu przez niego przepływającego. Symbole:
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 -2 100 27" style="height:16px; stroke:black; fill:none">
							<rect x="25" y="0" width="50" height="20" stroke-width="3" />
							<line x1="0" y1="10" x2="25" y2="10" stroke-width="3" />
							<line x1="75" y1="10" x2="100" y2="10" stroke-width="3" />
						</svg>,
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-2 -2 100 27" style="height:16px; stroke:black; fill:none">
							<polyline points="0,10 20,10 26,2 38,18 50,2 62,18 74,2 80,10 100,10" stroke-width="3" />
						</svg>.
					<br />
					Powoduje wydzielanie się energii (cieplnej) związanej z stratami na rezystancji - moc wydzielana dana jest zależnościami: <m>P = UI = \sfrac{U^2}{R} = I^2R</m>, czyli przy stałym napięciu przyłożonym do rezystora im większy jego opór tym mniejsza moc się wydzieli (gdyż popłynie mniejszy prąd), ale przy stałym prądzie płynącym przez rezystor moc rośnie wraz ze wzrostem oporu.</dd>
					
					<dt><dfn>Kondensator</dfn></dt>
					<dd>wprowadza do układu pojemność związaną z swoją wartością nominalną. Typowo służy do ograniczania zmian napięcia (poprzez gromadzenie energii w polu elektrycznym). Symbole:
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 -2 50 32" style="height:20px; stroke:black; fill:none">
							<line x1="0" y1="15" x2="20" y2="15" stroke-width="3" />
							<line x1="30" y1="15" x2="50" y2="15" stroke-width="3" />
							<line x1="20" y1="0" x2="20" y2="30" stroke-width="3" />
							<line x1="30" y1="0" x2="30" y2="30" stroke-width="3" />
						</svg>,
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 -2 55 32" style="height:20px; stroke:black; fill:none">
							<line x1="0" y1="15" x2="20" y2="15" stroke-width="3" />
							<line x1="35" y1="15" x2="55" y2="15" stroke-width="3" />
							<line x1="20" y1="0" x2="20" y2="30" stroke-width="3" />
							<line x1="31" y1="0" x2="31" y2="30" stroke-width="7" />
						</svg>.
					Czas potrzebny do zmiany napięcia na kondensatorze dany jest zależnością:<m>\Delta T = \frac{C \cdot \Delta U}{I}</m></dd>
					
					<dt><dfn>Cewka</dfn> (<dfn>dławik</dfn>)</dt>
					<dd>wprowadza do układu indukcyjność związaną z swoją wartością nominalną. Typowo służy do ograniczania zmian prądu (poprzez gromadzenie energii w polu magnetycznym). Symbol:
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 27" style="height:16px; stroke:black; fill:none">
							<path d="M 0,21 L 20,21 A 10,12 0 0 1 40,21 A 10,12 0 0 1 60,21 A 10,12 0 0 1 80,21 L 100,21" stroke-width="3" />
						</svg>.
					Czas potrzebny zmiany prądu płynącego przez cewkę (dławik stawia opór takiej zmianie tak jak kondensator zmianie napięcia) dany jest zależnością: <m>\Delta T = \frac{L \cdot \Delta I}{U}</m>.<br />
					Często cewka nawinięta jest na rdzeń ferrytowy, bardzo silnie zwiększa on indukcyjność cewki, ale ogranicza od góry częstotliwość pracy cewki. Ponadto przy odpowiednio dużym prądzie może dochodzić do nasycenia rdzenia, które objawia się tym, że zaczyna in hamować wzrost pola zamiast go poprawiać. Cewka nawinięta na odpowiednim rdzeniu może stanowić elektromagnes.</dd>
					
					<dt><dfn>Transformator</dfn></dt>
					<dd>Układ cewek sprzężonych magnetycznie, z których część służy do wytwarzania energii pola magnetycznego, a część do jej odbierania. Typowo służy do przekazywania energii poprzez pole magnetycznym celem zmiany napięcia lub separacji galwanicznej obwodów.<br />
					W przypadku dwu uzwojeniowego transformatora zachodzi: <m>\frac{U_{we}}{U_{wy}} = \frac{I_{wy}}{I_{we}} = \frac{n_{we}}{n_{wy}} = z</m>, gdzie <m>z</m> to przekładnia transformatora, <m>n_{we}</m> to liczba uzwojeń strony pierwotnej (wejściowej), a <m>n_{wy}</m> to liczba uzwojeń strony wtórnej (wyjściowej).</dd>
					
					<dt><dfn>Styk</dfn></dt>
					<dd>jest to element służący do mechanicznego załączania lub odłączania prądu, nazywany bywa także przełącznikiem.
						Wyróżnia się styki monostabilne (chwilowe), które samoistnie (po ustaniu czynnika przełączającego) wracają do jednej ze swoich pozycji oraz styki bistabilne, które po przełączeniu pozostają w wybranej pozycji.
						Wyróżnia się także styki zwierne (normalnie rozwarte), rozwierne (normalnie zwarte) lub przełączne (następuje przełączanie pomiędzy dwoma lub więcej możliwymi wyjściami).
						Czynnikiem odpowiedzialnym za przełączanie styków może być manualne działanie (przełącznik naciskany, przekręcany, pociąganym, itd przez człowieka) lub działanie elektromagnesu (cewki) - jest to wtedy przekaźnik elektromagnetyczny lub stycznik.<br />
						Stan zwarcia określa się często mianem "zamknięty" (ang. "close"), a rozwarcia mianem "otwarty" ("open"). Należy (zwłaszcza w systemach cyfrowych) pamiętać, że styki potrafią drgać - na ogół przy zmianie pozycji zamiast pojedynczego impulsu generują całą serię.</dd>
				</dl>
				<p>Elementy rzeczywiste oprócz wartości nominalnej (wprowadzanej przez nie rezystancji, pojemności lub indukcyjności) charakteryzują także:
					<ul>
						<li>wartości graniczne (takie jak maksymalna moc która może wydzielić się na rezystorze, napięcie przebicia kondensatora, maksymalny prąd przewodzenia cewki, temperaturowy zakres pracy, ...),</li>
						<li>impedancje pasożytnicze (każdy element rzeczywisty wprowadza zarówno niepożądaną rezystancję, jak i niepożądaną reaktancję nie związaną z jego wartością nominalną).</li>
					</ul>
					W większości przypadków impedancję pasożytniczą można pominąć. Jednak np. w przypadku rzeczywistych źródeł napięciowych i prądowych rezystancja wewnętrzna takiego źródła często odgrywa istotną rolę dla działania układu i nie może zostać pominięta.
				</p>
			</section>
		</section>
		
		<section>
			<h4>Układy połączeń</h4>
			<dl>
				<dt><dfn>Połączenie szeregowe</dfn></dt>
				<dd>jest to takie połączenie elementów że przepływa przez nie jednakowy prąd. Impedancje (zarówno rezystancyjne jak i reaktancyjne) tak połączonych elementów sumują się.
					<br /><div class="vcenter" style="height:52px;">
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 70 20" style="height:50px; stroke:black; fill:none">
							<g transform="translate(10,3)"><circle cx="5" cy="5" r="5" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">~</text></g>
							<line x1="20" y1="8" x2="30" y2="8" stroke-width="1" />
							<g transform="translate(30,3)"><rect width="10" height="10" stroke-width="1" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">Z<tspan dy="1" style="font-size: 66%;">1</tspan></text></g>
							<line x1="40" y1="8" x2="50" y2="8" stroke-width="1" />
							<g transform="translate(50,3)"><rect width="10" height="10" stroke-width="1" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">Z<tspan dy="1" style="font-size: 66%;">2</tspan></text></g>
							<polyline points="60,8 69,8 69,18 2,18, 2,8 10,8" stroke-width="1" />
						</svg>
						<span style="position: relative; top: -15px; left: 5px"><m>Z = Z_1 + Z_2</m></span>
					</div>
				</dd>
				
				<dt><dfn>Połączenie równoległe</dfn></dt>
				<dd>jest to takie połączenie elementów że przyłożone do nich napięcia są jednakowe (a prąd płynący w obwodzie ulega rozdzieleniu). Odwrotność impedancji takiego układu jest sumą odwrotności impedancji tak połączonych elementów.
					<br /><div class="vcenter" style="height:65px;">
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 55 25" style="height:63px; stroke:black; fill:none">
							<polyline points="8,8 8,3 48,3 48,8" stroke-width="1" />
							<line x1="28" y1="3" x2="28" y2="8" stroke-width="1" />
							<g transform="translate(3,8)"><circle cx="5" cy="5" r="5" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">~</text></g>
							<g transform="translate(23,8)"><rect width="10" height="10" stroke-width="1" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">Z<tspan dy="1" style="font-size: 66%;">1</tspan></text></g>
							<g transform="translate(43,8)"><rect width="10" height="10" stroke-width="1" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">Z<tspan dy="1" style="font-size: 66%;">2</tspan></text></g>
							<polyline points="8,18 8,23 48,23 48,18" stroke-width="1" />
							<line x1="28" y1="23" x2="28" y2="18" stroke-width="1" />
						</svg>
						<span style="position: relative; top: -25px; left: 5px"><m>Z = Z_1 || Z_2 \iff \frac{1}{Z} = \sfrac{1}{Z_1} + \sfrac{1}{Z_2} \iff Z = \frac{1}{\sfrac{1}{Z_1} + \sfrac{1}{Z_2}}</m></span>
					</div>
				</dd>
				
				<dt><dfn>Dzielnik napięcia</dfn> (rezystancyjny)</dt>
				<dd>jest to szeregowe połączenie dwóch rezystorów. Poprzez dobór wartości rezystorów uzyskuje się pożądane napięcie na wyjściu takiego dzielnika, które dane jest zależnością <m>U_{wy}=U_{we}\frac{R_2}{R_1 + R_2}</m>. Ze względu na to iż jest ono proporcjonalne do napięcia przyłożonego do całego dzielnika może on służyć także do skalowania napięciowego sygnału wejściowego. Aby minimalizować wpływ wartości impedancji podłączonej do wyjścia dzielnika na napięcie wyjściowe należy zapewnić odpowiednio małe wartości rezystorów w dzielniku - tak aby prąd płynący przez <m>R_2</m> był zdecydowanie większy (typowo 5 do 10 razy) od prądu płynącego przez obciążenie (<m>R_L</m>).
					<br />
						<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 70 65" style="height:160px; stroke:black; fill:none">
							<g transform="translate(3,28)"><circle cx="5" cy="5" r="7" /><text x="5" y="7" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">U<tspan dy="1" style="font-size: 66%;">we</tspan></text></g>
							<polyline points="8,26 8,3 28,3 28,8" stroke-width="1" />
							<polyline points="8,40 8,63 28,63 28,58" stroke-width="1" />
							<g transform="translate(23,8)"><rect width="10" height="20" stroke-width="1" /><text x="5" y="11" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">R<tspan dy="1" style="font-size: 66%;">1</tspan></text></g>
							<g transform="translate(23,38)"><rect width="10" height="20" stroke-width="1" /><text x="5" y="11" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">R<tspan dy="1" style="font-size: 66%;">2</tspan></text></g>
							<line x1="28" y1="28" x2="28" y2="38" stroke-width="1" />
							<g transform="translate(40,49)"><text transform="rotate(-90)" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">U<tspan dy="1" style="font-size: 66%;">wy</tspan></text></g>
							<polyline points="28,63 58,63 58,58" stroke-width="1" />
							<polyline points="28,33 58,33 58,38" stroke-width="1" />
							<g transform="translate(53,38)"><rect width="10" height="20" stroke-width="1" /><text x="5" y="11" text-anchor="middle" style="font-size: 37%; fill:black; stroke:none">R<tspan dy="1" style="font-size: 66%;">L</tspan></text></g>
						</svg>
				</dd>
				
				<dt><dfn>Dzielnik prądu</dfn> (rezystancyjny)</dt>
				<dd>jest to równoległe połączenie dwóch rezystorów. Poprzez dobór wartości rezystorów uzyskuje się pożądane natężenie prądu w wyjściowej gałęzi.</dd>
				
				<dt><dfn>Obwód RC</dfn></dt>
				<dd>jest to szeregowe połączenie rezystora i kondensatora. Obwód taki charakteryzuje się stałą czasową <m>\tau = RC</m>. Napięcie na kondensatorze w trakcie jego ładowania dane jest zależnością <m>U_C(t) = U_{we} \cdot (1 - e^{-\sfrac{t}{\tau}})</m>, a w trakcie rozładowywania <m>U_C(t) = U_C(0) \cdot (e^{-\sfrac{t}{\tau}})</m>. W przypadku wyjścia na zaciskach rezystora stanowi filtr górnoprzepustowy, a w przypadku wyjścia na zaciskach kondensatora stanowi filtr dolnoprzepustowy, częstotliwość graniczna (zapewniająca tłumienie większe niż 3dB) takich filtrów wynosi <m>f_{gr} = \sfrac{1}{2\pi\tau}</m>.</dd>
			</dl>
		</section>
		
		<section>
			<h4>Dioda</h4>
			<img src="img/diody.svg" class="right_img" style="height:120px; margin-bottom:10px" alt="symbole diód" />
			<p>Dioda idealna to element przewodzący prąd tylko w jednym kierunku. Rzeczywiste diody przewodzą prąd zdecydowanie chętniej w jednym kierunku niż w drugim (na ogół przewodzenie w kierunku zaporowym się pomija) ponadto charakteryzują je cechy zależne od technologi wykonania takie jak:
				<ul>
					<li>spadek napięcia w kierunku przewodzenia (typowo dla diod krzemowych 0.6V - 0.7V, a dla diod Schottky’ego 0.3V)</li>
					<li>napięcie przebicia - napięcie, które przyłożone w kierunku zaporowym powoduje znaczące przewodzenie diody w tym kierunku - w większości przypadków parametr którego nie należy przekraczać, jednak wykorzystywane (i stanowiące ich parametr) w niektórych typach diod</li>
					<li>maksymalny prąd przewodzenia</li>
					<li>czas przełączania (związany głównie z pasożytniczą pojemnością złącza) - zdecydowanie krótszy (około 100 ps) w diodach Schottky’ego niż w diodach krzemowych,.</li>
				</ul>
				Ponadto stosowane są m.in.:
				<ul>
					<li>diody Zenera - wykorzystuje się (charakterystyczną dla danego typu) wartość napięcia przebicia do uzyskania w układzie spadku napięcia o tej wartości,</li>
					<li>diody świecące (LED) - emitujące światło w trakcie przewodzenia (na elemencie występuje stały spadek napięcia, jasność zależy od natężenia prądu),</li>
					<li>fotodiody - będące detektorami oświetlenia (przewodzenie spolaryzowanej w kierunku zaporowym zależy od ilości padającego na element światła, niespolaryzowana pod wpływem oświetlenia staje się źródłem prądu).</li>
				</ul>
			</p>
		</section>
	</section>
	<!-- END: Elektronika - intro -->
	
	<section><!-- BEGIN: Elektronika - Tranzystory -->
		<h3>Tranzystor</h3>
		<p>Tranzystor jest to element o regulowanym elektrycznie przewodzeniu prądu (oporze), często wykorzystywany do wzmacniania sygnałów lub jako przełącznik elektroniczny.</p>
		
		<section>
			<h4>NPN, PNP, JFET, MOSFET, ...</h4>
			<img src="img/npn_pnp.svg" class="right_img" style="height:200px; margin-bottom:10px" alt="podłączenie NPN i PNP" />
			<dl>
				<dt><dfn>NPN</dfn></dt>
				<dd>
					Prąd przepływający pomiędzy kolektorem a emiterem jest funkcją prądu przepływającego pomiędzy bazą a emiterem: <m>I_C = \beta I_B</m>.
					Napięcie pomiędzy kolektorem a emiterem wynosi: <m>U_{CE} = U_{zasilania} - I_C \cdot R_{load}</m>.
					Napięcie to nie może jednak spaść poniżej wartości minimalnej wynoszącej około 0.2V, gdy z powyższych zależności wynikałby taki spadek to tranzystor pracuje w stanem nasycenia i <m>U_{CE} \approx 0.2V</m>.
				</dd>
				
				<dt><dfn>PNP</dfn></dt>
				<dd>Podobnie jak w NPE tyle że prąd przepływający pomiędzy emiterem a kolektorem jest funkcją prądu przepływającego pomiędzy emiterem a bazą.</dd>
			</dl>
			<p>
				Spadek napięcia pomiędzy bazą a emiterem <m>U_{BE}</m> w tranzystorze NPN (między emiterem a bazą w PNP) wynosi nie więcej niż około 0.7V.
				Utrzymanie takiej wartości spadku napięcia podowduje powstanie określonego prądu bazy.
				Jeżeli spadek ten wynosi dużo mniej (np. zero), to prąd bazy nie płynie, a więc tranzystor nie przewodzi.
			</p><p>
				Zatem w układzie przedstawionym obok zmiana <m>V_{ster}</m> spowoduje taką zmianę prądu bazy <m>I_B</m> aby na <m>R_b</m> odłożyło się napięcie <m>V_{ster} - 0.7V</m>.
				Z tego też względu konieczne jest stosowanie rezystancji pomiędzy bazą a napięciami sterującymi innymi od napięcia emitera.
			</p>
			
			<div style="clear:both;"></div>
			<img src="img/jfet.svg" class="right_img" style="height:220px; margin-bottom:10px" alt="podłączenie JFET" />
			<dl>
				<dt><dfn>N-JFET</dfn></dt>
				<dd>
					<p>
						Prąd przepływający pomiędzy drenem (<dfn>drain</dfn>) a źródłem (<dfn>source</dfn>) jest funkcją napięcia pomiędzy bramką (<dfn>gate</dfn>) a źródłem (potencjału bramki względem źródła - <m>U_{GS}</m>), prąd bramki można uznać za pomijanie mały.
						Tranzystor ten przewodzi tylko gdy napięcie pomiędzy bramką a źródłem jest większe od napięcia odcięcia (<m>U_{GS_{off}} &lt; 0</m>), przewodzony prąd wzrasta wraz ze wzrostem <m>U_{GS}</m>, a maksimum jest osiągane dla <m>U_{GS} = 0</m>.
					</p><p>
						Gdy tranzystor jest spolaryzowany tak aby <m>U_{DS} &gt; 0</m> oraz <m>U_{GS} &gt; U_{GS_{off}}</m> to w zależności od wartości spadku napięcia na tranzystorze <m>U_{DS}</m> oraz wartości napięcia nasycenia <m>U_{sat} = U_{GS} - U_{GS_{off}}</m> wyróżnia się dwa tryby pracy:
						<ol>
							<li>liniowy   (gdy <m>U_{DS}   &gt;  U_{sat}</m>), w którym <m>I_D = \beta \cdot {U_{sat}}^2</m></li>
							<li>nasycenia (gdy <m>U_{DS} \leq U_{sat}</m>), w którym <m>I_D = \beta \cdot U_{GS} \cdot [2 U_{sat} - U_{DS}]</m></li>
						</ol>gdzie <m>\beta = \frac{I_{DSS}}{{U_{GS_{off}}}^2}</m>
					</p>
				</dd>
				
				<dt><dfn>P-JFET</dfn></dt>
				<dd>Podobnie jak N-JFET tyle że: prąd przepływa pomiędzy źródłem a drenem, przewodzony prąd wzrasta wraz ze zmniejszaniem <m>U_{GS}</m> (od <m>U_{GS_{off}} &gt; 0</m> do zera).</dd>
			</dl>
			
			<div style="clear:both;"></div>
			<img src="img/mosfet.svg" class="right_img" style="height:220px; margin-bottom:10px" alt="podłączenie MOSFET" />
			<dl>
				<dt><dfn>N-MOSFET</dfn></dt>
				<dd>
					<p>
						Prąd przepływający pomiędzy drenem (<dfn>drain</dfn>) a źródłem (<dfn>source</dfn>) jest funkcją napięcia pomiędzy bramką (<dfn>gate</dfn>) a źródłem (potencjału bramki względem źródła - <m>U_{GS}</m>), bramka jest izolowana (nie płynie przez nią prąd).
					</p><p>
						W kierunku dren → źródło tranzystor ten przewodzi gdy <m>U_{GS} &gt; U_{GS (th)}</m>, natomiast w przeciwnym kierunku przewodzi zawsze. Dla tranzystorów N-MOSFET z kanałem wzbogacanym (<dfn>enhancement</dfn>) <m>U_{GS (th)} &gt; 0</m>, a z kanałem zubożonym (<dfn>depletion</dfn>) <m>U_{GS (th)} &lt; 0</m>.
					</p><p>
						Konkretna wartość <m>U_{GS (th)}</m> zależna jest od konkretnego modelu tranzystora, innym istotnym parametrem związanym z sterowaniem tranzystorem jest maksymalna i minimalna dopuszczalna wartość napięcia <m>U_{GS}</m>.
					</p>
				</dd>
				
				<dt><dfn>P-MOSFET</dfn></dt>
				<dd>
					<p>Podobnie jak N-MOSFET tyle że:<ol>
						<li>regulowane jest przewodzenie w kierunku źródło → dren (a w kierunku dren → źródło przewodzi zawsze),</li>
						<li>przewodzenie w kierunku źródło → dren ma miejsce gdy <m>U_{GS} &lt; U_{GS (th)}</m>,</li>
						<li>dla tranzystorów z kanałem wzbogacanym (<dfn>enhancement</dfn>) <m>U_{GS (th)} &lt; 0</m>, a z kanałem zubożonym (<dfn>depletion</dfn>) <m>U_{GS (th)} &gt; 0</m>.</li>
					</ol></p>
				</dd>
			</dl>
			
			<p class="examples">
				BC846 (NPN, 65V, 0.1A), BC337 (NPN, 50V, 0.8A), BD139 (NPN, 80V, 1.5A);
				BC327 (PNP, 50V, 0.8A), BD140 (PNP, 80V, 1.5A);
				BS170 (N-MOSFET, 60V, 5Ohm, 0.5A), IRF540N (N-MOSFET, 100V, 44mOhm, 33A), IRFZ44N (N-MOSFET, 55V, 17.5mOhm, 49A);
				IRF9Z34N (P-MOSFET, 55V, 100mOhm, 19A), IRF5210 (P-MOSFET, 100V, 60mOhm, 40A), IRF5305 (P-MOSFET, 55V, 60mOhm, 31A);
				BF245 (N-JFET)
				i wiele innych
			</p>
			
			<section>
				<h5>(inne) elementy mocy</h5>
				<img src="img/tyrystor_triak_igbt.svg" class="right_img" style="height:300px; margin-bottom:10px" alt="tyrystor triak i tranzystor IGBT" />
				<section class="noclear">
					<h6>Tyrystor</h6>
					<p>Jest elementem przewodzącym wyłącznie w jednym kierunku (od anody do katody). Przewodzenie musi zostać zainicjowane podaniem (dodatniego względem katody) napięcia na bramkę. Wyzwolony (raz przyłożonym napięciem bramki) tyrystor przewodzi do momentu spadku prądu poniżej minimalnej wartości przewodzenia lub wystąpienia odwrotnej polaryzacji. Zasadę działania tyrystora obrazuje przedstawiony obok dwu-tranzystorowy model.</p>
				</section>
				<section class="noclear">
					<h6>Triak</h6>
					<p>Jest elementem o dwukierunkowym przewodzeniu inicjowanym impulsem napięciowym podanym na bramkę. Zasadę jego działania obrazuje schemat zastępczy złożony z dwóch połączonych anty-równolegle tyrystorów. Używany jest jako elektroniczny przełącznik prądu przemiennego.</p>
					<p class="examples">BTA16</p>
				</section>
				<section class="noclear">
					<h6>Tranzystor IGBT</h6>
					<p>Jest to tranzystor bipolarny z izolowaną bramką. Z punktu sterowania należy patrzeć na niego jak na tranzystor typu N-MOSFET. Stosowany do przełączania w układach dużej mocy.</p>
				</section>
			</section>
			<section>
				<h5>transoptory</h5>
				<p>
					Poprzez połączenie w jednej obudowie diody świecącej z fototranzystorem, fotodiodą (niekiedy wraz z tranzystorem do bramki którego jest podłączona), fototriakiem lub podobnym elementem (to znaczy takim którego przewodność zależy od padającego na niego oświetlenia) uzyskuje się element nazywany transoptorem. W układzie może być zawarty także dodatkowy stopień wyjściowy dostosowujący napięcia do poziomów wymaganych przez jakiś standard.
				</p><p>
					Transoptor zapewnia on izolację (typowo rzędu tysięcy woltów) galwaniczną dwóch części obwodu. Pozwala to m.in. na odbiór sygnałów wysokonapięciowych przez niskonapięciową część układu (dioda LED może być sterowana np. z napięcia 230V, a tranzystor może sterować układem 3.3V).<br />
					Ponadto transoptor zabezpiecza część odbiorczą (podłączoną do swojego wyjścia) przed przepięciami w części sterującej diodą LED.
					Jednak ze względu na fizyczną bliskość diody i elementu foto-elektrycznego przy napięciu przekraczającym wartość izolacji może zdarzyć się przebicie (pełną izolację optyczną zapewnia użycie połączeń światłowodowych).
				</p>
				<p class="examples">4N25 (analogowy), 4N35 (analogowy), 6N136 (cyfrowy), 6N137 (cyfrowy), MOC3023 (optotriak), MOC3063 (optotriak)</p>
			</section>
		</section><!-- END: Elektronika - Tranzystory -->
		
		<section>
			<h4>Klucz tranzystorowy</h4>
			<p>Klucz jest układem przełączającym wykorzystującym dwa skrajne stany pracy tranzystora - zatkania (tranzystor nie przewodzi), nasycenia (tranzystor przewodzi z minimalnymi ograniczeniami).</p>
			<section>
				<h5>klucz NPN</h5>
				<p>
					Aby wprowadzić tranzystor NPN w stan zatkania należy podać na jego bazę potencjał mniejszy lub równy potencjałowi emitera (zakładamy że potencjał kolektora jest nie mniejszy niż emitera - co ma miejsce w typowych warunkach polaryzacji tranzystora NPN), czyli <m>U_{BE} \leq 0</m>.<br />
					Aby wprowadzić tranzystor NPN w stan nasycenia należy na jego bazę wprowadzić potencjał większy od potencjałów emitera i kolektora, uzyskuje się to poprzez wprowadzenie do tranzystora prądu bazy <m>I_B \gg \frac{U_{zasilania}}{\beta R_{load}}</m>.
				</p>
			</section>
			<section>
				<h5>klucz PNP</h5>
				<p>
					Aby wprowadzić tranzystor PNP w stan zatkania należy podać na jego bazę potencjał większy lub równy potencjałowi emitera (zakładamy że potencjał emitera jest nie mniejszy niż kolektora - co ma miejsce w typowych warunkach polaryzacji tranzystora PNP), czyli <m>U_{BE} \geq 0</m>.<br />
					Aby wprowadzić tranzystor PNP w stan nasycenia należy na jego bazę wprowadzić potencjał mniejszy od potencjałów emitera i kolektora, uzyskuje się to poprzez wyprowadzenie z tranzystora prądu bazy <m>I_B \gg \frac{U_{zasilania}}{\beta R_{load}}</m>.
				</p>
			</section>
			<section>
				<h5>klucz JFET</h5>
				<p>
					Aby wprowadzić w stan zatkania tranzystor N-JFET należy podać <m>U_{GS} \leq U_{GS_{off}}</m>, a dla tranzystora P-JFET należy podać <m>U_{GS} \geq U_{GS_{off}}</m>.<br />
					Aby wprowadzić w stan przewodzenia tranzystor N-JFET należy podać <m>U_{GS} \geq 0}</m>, a dla tranzystora P-JFET należy podać <m>U_{GS} \leq 0</m>.
				</p>
			</section>
			<section>
				<h5>klucz MOSFET</h5>
				<p>
					Aby wprowadzić tranzystor MOSFET w stan zatkania należy podać <m>U_{GS} &lt; U_{GS (th)}</m>. Dla tranzystorów:<ul>
						<li>N-MOSFET z kanałem wzbogaconym i P-MOSFET z kanałem zubożonym wystarczy obniżyć potencjał bramki do wartości niewiele wyższej niż potencjał źródła</li>
						<li>P-MOSFET z kanałem wzbogaconym i N-MOSFET z kanałem zubożonym musi to być wartość poniżej potencjału źródła.</li>
					</ul>
					Aby wprowadzić tranzystor MOSFET w stan przewodzenia należy podać <m>U_{GS} \gg U_{GS (th)}</m>.
				</p>
			</section>
			<section>
				<h5>(pół)mostek H</h5>
				<img src="img/mostek_H.svg" class="right_img" style="height:330px" alt="schemat mostka H oraz przykładowa konstrukcja półmostka" />
				<p>Mostek H jest to układ (oparty o 4 przełączniki, których rolę mogą pełnić klucze tranzystorowe) pozwalający na zmianę polaryzacji zasilania podłączonego do niego odbiornika. Układ taki złożony jest z dwóch identycznych gałęzi (S1 + S2 oraz S3 + S4). Pojedyncza taka gałąź nazywana jest pół-mostkiem i składa się z dwóch kluczy które powinny być sterowane przeciwstawnie (aby wyeliminować możliwość zwarcia zasilania z masą). Układ pół-mostka może być wykorzystywany także samodzielnie jako uniwersalny układ klucza pozwalającego na załączanie odbiornika zarówno od strony napięcia dodatniego jak i od strony masy (w zależności od sposobu jego podłączenia) lub przełączania dwóch odbiorników (jednego umieszczonego pomiędzy zasilaniem a wyjściem mostka, a drugiego pomiędzy wyjściem a masą).</p>
				<p>
					Na schemacie umieszczonym obok przedstawiona jest także przykładowa realizacja pół-mostka w oparciu o dwa klucze na tranzystorach MOSFET i sterujące nimi klucze NPN.
					<br />
					Zastosowanie kluczy NPN (tranzystory Q3 i Q4) pozwala na sterowanie z użyciem napięcia niższego od napięcia przełączanego.
				</p>
				<p>
					W stanie zatkania Q3 i Q4:<ul>
						<li>potencjał bramki Q1 równy jest potencjałowi zasilania (czyli także potencjałowi źródła), zatem Q1 (P-MOSFET wzbogacony) nie przewodzi;</li>
						<li>potencjał bramki Q2 ustala dzielnik złożony z R21 i Z21 (jest on wyższy od potencjału źródła, minimalnie o wartość napięcia zasilania, a maksymalnie o wartość spadku na Z21)
							i jest on wyższy o conajmniej <m>U_{GS (th)}</m> od potencjału źródła, zatem Q2 (N-MOSFET wzbogacony) przewodzi.</li>
					</ul>
					W stanie nasycenia (pzewodzenia) Q3 i Q4:<ul>
						<li>potencjał bramki Q1 ustalany jest przez dzielnik R11 i R12 albo (jeżeli napięcie zasilania jest odpowiednio wysokie) przez dzielnik Z11 i R12
							i jest on niższy o conajmniej <m>U_{GS (th)}</m> od potencjału źródła, zatem Q1 przewodzi;</li>
						<li>potencjał bramki Q2 jest równy potencjałowi masy (czyli także potencjałowi źródła), zatem Q2 nie przewodzi.</li>
					</ul>
				</p>
				<p>
					Zastosowanie diod Zenera Z1 i Z2 zabezpiecza tranzystory MOSFET przed podaniem na bramkę zbyt dużego (co do wartości bezwzględnej) napięcia w stosunku co do źródła. 
					Niestety wiąże się to także z zastosowaniem  to zastosowaniem rezystora R12, który (tworząc dzielnik) powoduje iż układ nie będzie działał poprawnie dla niskich napięć zasilania toru prądowego - napięcie musi być większe od <m>2 U_{GS (th)}</m> zamiast od <m>U_{GS (th)}</m>. <!-- FIXME: układ z kluczem PNP,  a może dwa warianty szybki (PNP+NPN do sterowania MOSFETami) i zabezpieczony ? -->
					Ponadto wymaga to zastosowania osobnych gałęzi sterujących dla poszczególnych tranzystorów MOSFET (dwóch kluczy NPN), ponieważ obecność Z21 w gałęzi sterującej P-MOSFETem (Q1) przy wyższym napięciu zasilania powodowała by przepływ prądu przez tą gałąź niezależnie od Q3 co mogłoby prowadzić do przewodzenia Q1.
				</p>
			</section>
		</section>
		
		<section>
			<h4>Wzmacniacz sygnału</h4>
			<section>
				<h5>punkt pracy</h5>
				<img src="img/common_emitter_amplifier_npn.svg" class="right_img" style="height:260px; margin-bottom:10px" alt="schemat wzmacniacza typu wspólny emiter w układzie z stałym potencjałem bazy" />
				<p>Aby móc wykorzystać tranzystor do wzmacniania sygnału konieczne jest wstępne ustalenie punktu pracy tranzystora w ten sposób aby nie wchodził w stany nasycenia i zatkania oraz aby układ posiadał ustalone wzmocnienie.</p>
				<p>
					W przypadku tranzystorów NPN i PNP można by próbować ustalić go z użyciem określonej wartości prądu bazy (pokazany powyżej układ z rezystorem bazy i rezystancją obciążenia), jednak ze względu na znaczny rozrzut wartości współczynnika <m>\beta</m> pomiędzy egzemplarzami układ taki cechowałby się małą powtarzalnością.
					W związku z tym stosuje się pokazany obok układ ze stałym potencjałem bazy i opornikiem emiterowym, gdzie <m>I_E = \frac{U_B - 0.6V}{R_e}</m>, <m>I_B = \frac{I_E}{\beta + 1}</m>, <m>I_C = I_E - I_B</m>, <m>\beta \gg 1</m>, zatem <m>I_C = I_E \frac{\beta}{\beta +1} \approx I_E</m>.
				</p>
			</section>
			<section class="noclear">
				<h5>wspólny emiter</h5>
				<p>Przedstawiony układ jest także przykładem jednego z 3 podstawowych układów pracy tranzystora bipolarnego (NPN, PNP) w funkcji wzmacniacza określanym "wspólny emiter". Układ tego typu charakteryzuje się wejściem sygnału na bazę tranzystora (napięcie bazy w stosunku co do napięcia emitera / masy dla układów NPN) i wyjściem wzmocnionego sygnału z kolektora (napięcie kolektorem w stosunku co do napięcia emitera / masy dla układów NPN).</p>
				<p>W przypadku polaryzacji stałym prądem bazy emiter w układzie tym ma potencjał masy. W przypadku przedstawionej polaryzacji stałym potencjałem bazy aby w układzie tym móc uzyskać wzmocnienie konieczne jest zwarcie emitera do masy dla sygnałów zmiennych, realizowane przy pomocy kondensatora C<sub>e</sub>.</p>
			</section>
			<section>
				<h5>wspólny kolektor i wspólna baza</h5>
				<img src="img/common_collector_and_base_amplifiers_npn.svg" class="right_img" style="height:260px;" alt="schemat wzmacniacza typu swpólny emiter w układzie z stałym potencjałem bazy" />
				<p>Kolejnymi dwoma z 3 podstawowych układów pracy są układy wspólnego kolektora i wspólnej bazy.</p>
				<p>W układzie wspólnego kolektora sygnał wejściowy podawany jest między bazę a kolektor, natomiast wzmocniony sygnał odbierany jest z pomiędzy emitera i kolektora. Wzmacniacz w układzie wspólnego kolektora nie posiada wzmocnienia napięciowego (napięcie wyjściowe jest wręcz pomniejszone o spadek na złączu PN), natomiast posiada znaczne wzmocnienie prądu. Układ często określany jest jako <dfn>wtórnik emiterowy</dfn>.</p>
				<p>W układzie wspólnej bazy sygnał wejściowy podawany jest między emiter a bazę, natomiast wzmocniony sygnał odbierany jest z pomiędzy kolektora i bazy.</p>
			</section>
		</section>
		<section>
			<h4>Układy tranzystorowe</h4>
			<section>
				<h5>Lustro prądowe</h5>
				<img src="img/lustro.svg" class="right_img" style="height:150px;" alt="schemat układu typu lustro" />
				<p>T1 i T2 muszą mieć zapewnioną tą samą temperaturę (najlepiej być wykonane w ramach jednego układu scalonego. T1 pracuje jako dioda (stosujemy tranzystor aby zapewnić taką samą charakterystykę jak T2), która wraz z R1 tworzy sprzężony termicznie z T2 dzielnik sterujący tranzystorem T2. Układ ten sterowany prądem płynącym przez R1 powoduje przepływ (niemalże) takiego samego prądu poprzez RL.</p>
			</section>
			<section>
				<h5>Wzmacniacz różnicowy</h5>
				<img src="img/roznicowy.svg" class="right_img" style="height:240px;" alt="schemat układu wzmacniacza różnicowego" />
				<p>W przypadku układu z tranzystorami NPN "bardziej" przewodzić będzie tranzystor na wejściu którego jest większe napięcie (niż na tym drugim). Fakt tego że on przewodzi powoduje ustalenie się potencjału w węźle łączącym emitery obu tranzystorów na wartość napięcia jego bazy pomniejszonego o spadek na przewodzącym złączu PN. W sytuacji gdy napięcia baz obu tranzystorów są odpowiednio bliskie przewodzić będą oba, zakres ten określa się strefą przejściową.</p>
				<p>Układ ten może pełnić rolę klucza prądowego (gdy podany sygnał na tyle duży aby zatkać jeden z tranzystorów) lub wzmacniacza (gdy pracować będą oba tranzystory. Układ jest czuły na różnicę napięć przyłożonych do in1 i in2. Ree pełni rolę źródła prądowego (i powinien być tak dobrany aby wraz z wartością -Vee zapewnić jego stabilność). Zastosowanie regulowanego źródła prądowego (tranzystor) zamiast Ree (realnie - w szeregu z Ree) pozwala na regulację wzmocnienia tego układu.</p>
			</section>
			<section>
				<h5>Przerzutniki</h5>
				<img src="img/przerzutniki.svg" class="right_img" style="height:430px;" alt="schematy układów przerzutników" />
				<dl>
					<dt><dfn>Przerzutnik bistabilny</dfn></dt>
					<dd>Układ ten służy do zapamiętania stanu binarnego. Może być przełączony poprzez podanie krótkiego sygnału na którejś z wejść lub zwarcie któregoś wyjścia do masy. powoduje to rozpoczęcie przewodzenia przez wybrany z tranzystorów, co prowadzi do spadku napięcia na bazie drugiego tranzystora, prowadząc do jego zatkania i trwałego ustalenia stanu wysokiego na bazie wybranego tranzystora.</dd>
					
					<dt><dfn>Przerzutnik monostabilny</dfn></dt>
					<dd>Układ służy do generacji impulsu trwającego ustaloną długość. Działa on podobnie jak przedstawiony przerzutnik bistabilny, z taką różnicą iż krótkotrwałe zwarcie wejścia do masy powoduje obniżenie potencjału bazy T2 o napięcie do jakiego został naładowany C1 (w normalnym stanie <m>U_{CC}-U_{BE}</m>). Powoduje to zatkanie T2 i przewodzenie T1, następuje także ładowanie C1 z stopniowym zwiększaniem napięcia na bazie T2 aż do osiągnięcia sytuacji pierwotnej. Należy zwrócić uwagę że po zatkaniu T1 (zaprzestaniu generowania sygnału wyjściowego) układ nie osiągnął jeszcze gotowości do generacji następnego impulsu gdyż musi nastąpił ładowanie C1 przez RC1 (należy odczekać <m>t ≳ 5 \tau = 5 R_{C1} C_1</m>). Wadą takiego rozwiązania są duże ujemne napięcia na bazach tranzystorów w chwili przerzutu, co (przy większych napięciach zasilania) może doprowadzić do ich przebicia.</dd>
					
					<dt><dfn>Przerzutnik astabilny</dfn></dt>
					<dd>Przerzutnik ten służy do generacji sygnału prostokątnego o zadanym wypełnieniu. Działanie układu jest podobne do opisanego przerzutnika montostabilnego z tym że po (ponownym) nasyceniu drugiego tranzystora powstały spadek napięcia rozpoczyna taki sam proces dla pierwszego tranzystora i kondensatora podłączonego do jego bazy. Dodatkową wadą tego rozwiązania jest problem startu przy wypełnieniu 1/2 (jednakowych elementach) i łagodnym włączaniu.</dd>
					
					<dt><dfn>Przerzutnik Shmitta</dfn></dt>
					<dd>Służy od do uzyskania histerezy - większe napięcie powoduje przejście w stan wysoki, a mniejsze od niego w stan niski. Pozwala to m.in. na odszumianie sygnałów. Idea działania polega na zmianie potencjału drugiego wejścia wzmacniacza różnicowego zależnie od jego stanu. Przesuwnik poziomów zrealizowany na D1 oraz R1 służy do dostosowania napięcia wyjściowego do zakresu histerezy (wynosi on <m>U_{CC}-U_{p}</m> = wartość górna, <m>U_{CC} - I_{EE} R_{C1} - U_{p}</m> = wartość dolna).</dd>
				</dl>
			</section>
		</section>
		<section>
			<h4>Wzmacniacz operacyjny</h4>
			<img src="img/wzmacniacz_operacyjny.svg" class="right_img" style="height:340px;" alt="schematy układów wzmacniacza operacyjnego" />
			<p>Jest to układ służący do wzmacniania bardzo wiele razy różnicy napięć wejściowych, oparty na układzie wzmacniacza różnicowego z lustrem prądowym. Na stopniu wejściowym posiada on wzmacniacz różnicowy z lustrem, dalej jest układ wzmacniający o dużym wzmocnieniu, a na stopniu wyjściowym wtórnik emiterowy. Charakteryzuje się dużą rezystancją wejściową i bardzo dużą wartością wzmocnienia.</p>
			<p>
				Jako iż wzmocnienie wzmacniaczy operacyjnych jest bardzo duże nie da się w praktyce wykorzystać ich bezpośrednio do wzmacniania sygnału. Robi się to z wykorzystaniem sprzężenia zwrotnego, czyli podaniem przeskalowanego sygnału wyjściowego na wejście.
				Dzięki wykorzystaniu ujemnego sprzężenia układ zachowuje się stabilnie dążąc do utrzymania różnicy napięć wejściowych bliskiej zeru oraz posiada bardzo małą (prawie zerową) rezystancję wyjściową.
				Wzmocnienie zależy od parametrów dzielnika występującego w pętli sprzężenia zwrotnego i dla wzmacniacza odwracającego fazę wynosi <m>k_u = - \frac{R_2}{R_1}</m>, a dla wzmacniacza nie odwracającego fazy <m>k_u = 1 + \frac{R_2}{R_1}</m> (aby uzyskać wtórnik R2 należy zastąpić zwarciem, a R1 rozwarciem).
				W wzmacniaczu odwracającym rezystancja wejściowa Rwe = R1, natomiast w odwracającym jest to zasadniczo tylko rezystancję sumacyjną wzmacniacza różnicowego (różnicowej praktycznie nie widać bo dzięki sprzężeniu zwrotnemu napięcie na niej bliskie zeru). Częstotliwość graniczną oblicza się z zależności <m>f_g = \frac{f_T}{1 + \frac{R_2}{R_1}}</m>.
			</p>
			<p>
				Niekiedy stosuje się także tzw "R3" podłączony do nieodwracającego wejścia wzmacniacza, ma to na celu minimalizację wpływu prądów wejściowych (nie wpływa na napięcie niesymetryczności, które jest cechą samego wzmacniacza), wtedy R3 = R1 || R2 gdy sprzężenie DC, lub R3 = R2 gdy sprzężenie AC (źródło sygnału oddzielone kondensatorem). Ze względu na stosowanie sprzężenia zwrotnego nie można na układ taki podawać sygnału którego przesunięcie fazowe na wzmacniaczu byłoby większe niż 135°, aby nie doprowadzić do wzbudzania się układu. Uzyskuje się to poprzez zapewnienie wzmocnienia mniejszego od jedności dla częstotliwości przy których byłoby takie lub większe przesunięcie fazowe.
			</p>
			<p>W oparciu o wzmacniacz operacyjny w układzie odwracającym można zrealizować sumator napięć wejściowych. Suma prądów wpływających przez rezystory R1, R2, R3, itd, ze względu na dużą rezystancję wejściową wzmacniacza musi być równa prądowi wypływającemu przez Rs. Napięcie na Rf musi być równe napięciu wyjściowemu (wejście nie odwracające podłączone do masy, a układ dąży do zerowego napięcia różnicowego na wejściach wzmacniacza). Zatem <m>\frac{U_1}{R_1} + \frac{U_2}{R_2} + \ldots = -\frac{U_{wy}}{R_s} \iff U_{wy} = -R_s (\frac{U_1}{R_1} + \frac{U_2}{R_2} + \ldots)</m> co przy równych wartościach rezystancji daje: <m>U_{wy} = U_1 + U_2 + \ldots</m>.</p>
			<p class="examples">LM358; TL081</p>
		</section>
		<section>
			<h4>Komparator analogowy</h4>
			<img src="img/komparator.svg" class="right_img" style="height:330px;" alt="schematy układów komparatora" />
			<p>
				Jest to układ służący do porównywania dwóch napięć wejściowych, oparty (podobnie jak wzmacniacz operacyjny) na układzie wzmacniacza różnicowego z lustrem prądowym. Charakteryzuje się dużą rezystancją wejściową (małym poborem prądu z wejść), szybką i stromą zmianą wyjścia w odpowiedzi na zmianę sygnału wejściowego. Oprócz podstawowego układu pracy komparator może być stosowany m.in. w układach:
				<dl>
					<dt>z histerezą:</dt>
					<dd><ul>
						<li>dzielnik R1, R3 zapewnia sprzężenie zwrotne, <m>R_3 \gg R_1</m> (rzędu mega omów), wartość histerezy dana jest zależnością: <m>V_H = V_{cc} \frac{R_1}{R_1 + R_3}</m></li>
						<li>rezystor R2 zapewnia jednakowe rezystancję obu wejść komparatora i wynosić powinien: <m>R_2 \approx R_1</m></li>
					</ul></dd>
					<dt>dyskryminator okienkowy:</dt>
					<dd>układ złożony z dwóch komparatorów wykrywający to iż napięcie znajduje się w przedziale pomiędzy V<sub>ref1</sub> a V<sub>ref2</sub>, jeżeli <m>V_{ref1} &gt; V_{ref2}</m> to znajdowanie się napięcia w zakresie będzie sygnalizowane stanem wysokim, w przeciwnym razie stanem niskim.</dd>
					<dt>detektora przejścia przez zero:</dt>
					<dd>zasadniczo dowolny układ (podstawowy, z histerezą, ...) wtedy gdy napięciem z którym porównujemy jest potencjał zera woltów (masa)</dd>
				</dl>
				Przedstawione schematy są dla komparatora z wyjściem NPN (zwierającym do masy). Dla komparatorów z innym typem wyjścia mogą wymagać pewnych modyfikacji.
			</p>
			<p class="examples">LM239; LM393; LM311</p>
		</section>
	</section>
	
	<section>
		<h3>Cyfrowa</h3>  <!-- wspominać numery użytych w przykładach układów scalonych -->
		<section>
			<h4>Algebra Boole'a i system dwójkowy</h4>
			
			<h5>podstawowe operacje i elementy neutralne</h5>
			<section><table>
				<tr><td>suma logiczna (OR, +, |)</td>
					<td>a OR 1 = 1</td>
					<td>a OR 0 = a</td>
					<td>a OR a = a</td></tr>
				<tr><td>iloczyn logiczny (AND, *, &amp;)</td>
					<td>a AND 1 = a</td>
					<td>a AND 0 = 0</td>
					<td>a AND a = a</td></tr>
				<tr><td>negacja (NOT, ~, ^, !)</td>
					<td>NOT 1 = 0</td>
					<td>NOT 0 = 1</td>
					<td>NOT (NOT a) = a</td></tr>
			</table></section>
			
			<h5>własności działań</h5>
			<section><table>
				<tr><td>łączność</td>
					<td>(a OR b) OR c = a OR (b OR c)</td>
					<td>(a AND b) AND c = a AND (b AND c)</td></tr>
				<tr><td>przemienność</td>
					<td>a OR b = b OR a</td>
					<td>a AND b = b AND a</td></tr>
				<tr><td>rozdzielność</td>
					<td>a AND (b OR c) = (a AND b) OR (a AND c)</td>
					<td>a OR (b AND c) = (a OR b) AND (a OR c)</td></tr>
				<tr><td>absorpcja</td>
					<td>a AND (b OR a) = a</td>
					<td>a OR (b AND a) = a</td></tr>
				<tr><td>negacja sumy i iloczynu</td>
					<td>NOT (a OR b) = (NOT a) AND (NOT b)</td>
					<td>NOT (a AND b) = (NOT a) OR (NOT b)</td></tr>
				<tr><td>pochłanianie</td>
					<td>a OR (NOT a) = 1</td>
					<td>a AND (NOT a) = 0</td></tr>
			</table></section>
			
			<h5>dodatkowe operacje</h5>
			<section><table>
				<tr><td>alternatywa wykluczająca (XOR)</td>
				<td>a XOR b = (a AND (NOT b)) OR (b AND (NOT a))</td>
				<td>a XOR 0 = a</td>
				<td>a XOR a = 0</td>
				</tr>
				
				<tr><td>a NAND b = NOT (a AND b)</td>
				<td colspan="3">(a NAND b) NAND (c NAND d) <!--= NOT( (NOT(a AND b)) AND (NOT(c AND d)) ) = NOT(NOT( (a AND b) OR (c AND d) ))--> = (a AND b) OR (c AND d)</td></tr>
				<tr><td>a NOR b = NOT (a OR b)</td>
				<td colspan="3">(a NOR b) NOR (c NOR d) <!--= NOT( (NOT(a OR b)) OR (NOT(c OR d)) ) = NOT(NOT( (a OR b) AND (c OR d) ))--> = (a OR b) AND (c OR d)</td></tr>
				<tr><td colspan="4">a XNOR b = NOT (a XOR b) = a XAND b</td></tr>
			</table></section>
			
			<h5>tablice prawdy</h5>
			<section><table style="text-align:center">
				<tr><td> a </td><td> b </td><td> a OR b </td><td> a AND b </td><td> a NOR b </td><td> a NAND b </td><td> a XOR b </td><td> a XNOR b </td><td>     NOT a     </td></tr>
				<tr><td> 0 </td><td> 0 </td><td>   0    </td><td>    0    </td><td>    1    </td><td>    1     </td><td>    0    </td><td>    1     </td><td rowspan="2"> 1 </td></tr>
				<tr><td> 0 </td><td> 1 </td><td>   1    </td><td>    0    </td><td>    0    </td><td>    1     </td><td>    1    </td><td>    0     </td>                        </tr>
				<tr><td> 1 </td><td> 0 </td><td>   1    </td><td>    0    </td><td>    0    </td><td>    1     </td><td>    1    </td><td>    0     </td><td rowspan="2"> 0 </td></tr>
				<tr><td> 1 </td><td> 1 </td><td>   1    </td><td>    1    </td><td>    0    </td><td>    0     </td><td>    0    </td><td>    1     </td>                        </tr>
			</table></section>
			
			<h5>reprezentacja liczb</h5>
			<section>
				<p>Pojedynczą cyfrę systemu dwójkowego (przybierającą wartość 0 albo 1) określa się mianem <dfn>bit</dfn>u, liczby reprezentowane są jako ciągi takich cyfr. Terminem <dfn>bajt</dfn> określa się zazwyczaj ciąg o długości 8 bitów (ale w niektórych systemach ciąg o innej długości).</p>
				<p>Podstawowym sposobem zapisy liczb całkowitych nie ujemnych w systemie dwójkowym jest <dfn>naturalny kod binarny</dfn> (<dfn>NKB</dfn>), w którym np. 4 bitowy ciąg <code>a<sub>3</sub> a<sub>2</sub> a<sub>1</sub> a<sub>0</sub></code> reprezentuje liczbę <m>2^0 \cdot a_0 + 2^1 \cdot a_1 + 2^2 \cdot a_2 + 2^3 \cdot a_3</m>.</p>
				<p>Podstawowym sposobem zapisy liczb całkowitych (ze znakiem) jest <dfn>kod uzupełnień do dwóch</dfn> (<dfn>U2</dfn>) w którym n-bitowa liczba reprezentowana przez ciąg <code>a<sub>n-1</sub> ... a<sub>3</sub> a<sub>2</sub> a<sub>1</sub> a<sub>0</sub></code> będzie miała wartość <m>2^0 \cdot a_0 + 2^1 \cdot a_1 + 2^2 \cdot a_2 + ... + 2^{n-2} \cdot a_{n-2} - 2^{n-1} \cdot a_{n-1}</m>. Jako że najstarszy bit wchodzi z ujemną wagą, jego ustawienie na 1 oznacza liczbę ujemną (ale nie jest to kod znaku). Warto zauważyć kompatybilność z NKB.</p>
				<p>Liczby zapisywane w tych kodowaniach systemu dwójkowego oznacza się często przy pomocy prefiksu "0b" albo sufiksu "b", np. <code>0b101 = 101b</code> reprezentuje liczbę 5 w systemie dziesiętnym (<m>2^0 \cdot 1 + 2^1 \cdot 0 + 2^2 \cdot 1 = 5</m>).</p>
				<p>Oprócz podanych istnieje jeszcze kilka stosowanych sposobów zapisu liczb binarnych takich jak (dla liczb bez znaku): kod "1 z n", kod Graya, kod Johnsona, (dla liczb ze znakiem): kod znak-moduł, kod uzupełnień do jedności (U1). Odmiennym zagadnieniem jest kodowanie liczb zmiennoprzecinkowych.</p>
			</section>
			
			<h5>zapis hexalny (szesnastkowy)</h5>
			<section>
				<p>Celem skrócenia zapisu liczb binarnych często zapisuje się je w postaci szesnastkowej, jest on wygodniejszy od dziesiątkowego gdyż każda cyfra systemu szesnastkowego rozkłada się na dokładnie 4 bity, co pozwala na niezależne konwertowanie poszczególnych cyfr szesnastkowych / ciągów 4 bitowych i ich łączenie w dłuższe ciągi.</p>
				<p>Cyfry o wartościach powyżej 9 zapisuje się jako kolejne małe lub wielkie litery a, b, c, d, e, f. Liczby zapisywane w systemie szesnastkowym oznacza się przy pomocy prefiksu "0x" lub "#" albo sufiksu "h" np. <code>0xc7 = #c7 = c7h</code> reprezentuje liczbę 199 w systemie dziesiątkowym (<m>16^0 \cdot 7 + 16^1 \cdot 12 = 199</m>).
					Konwersja na system binarny może odbywać się niezależnie dla każdej cyfry, jako że: <code>0xc = 0b1100</code> oraz <code>0x7 = 0b0111</code> to<code> 0xc7 = 0b 1100 0111</code>.
				</p>
			</section>
			
			<h5>reprezentacja elektryczna</h5>
			<section>
				<p>Typowo logicznej 1 odpowiada stan wysoki (napięcie dodatnie), a logicznemu 0 stan niski (potencjał masy). W przypadku logiki odwróconej (ujemnej) logicznej 1 odpowiada stan niski a logicznemu zeru wysoki.</p>
			</section>
		</section>
		<section><!-- BEGIN: Elektronika - Bramki -->
			<h4>Bramki</h4>
			<img src="img/bramki.svg" class="right_img" style="height:260px;" alt="symbole bramek logicznych" />
			<p>Bramki są układami elektronicznymi realizującymi podstawowe, opisane powyżej funkcje logiczne. Obok zostały przedstawione podstawowe symbole poszczególnych bramek w wariancie dwu wejściowym, spotkać się można także z symbolami z zanegowanymi wejściami - w takiej konwencji np. bramka AND reprezentowana jest przez NOR z zanegowanymi wejściami. Bramki (z wyjątkiem buforów oraz bramki NOT), mogą występować także w wariantach wielo-wejściowych (ze względu na łączność podstawowych operacji nie ma wątpliwości co don wyniku jaki powinna dawać np. 8 wejściowa bramka OR). Na ogół w pojedynczym układzie scalonym znajduje się kilka jednakowych bramek.</p>
			<section class="noclear">
				<h5>trój-stanowe</h5>
				<p>
					Typowa bramka wymusza (w sposób silny) na swoim wyjściu stan wysoki lub niski, co uniemożliwia bezpośrednie łączenie wyjść bramek.
					Bramki trój-stanowe mają możliwość skonfigurowania wyjścia w stan <dfn>wysokiej impedancji</dfn> czyli nie wymuszania żadnej jego wartości.
					Sterowanie załączeniem bądź wyłączeniem wyjścia (przełączeniem w stan wysokiej impedancji) odbywa się przy pomocy zewnętrznego sygnału sterującego "output enabled" ("OE"), sygnał ten może występować w postaci prostej i zanegowanej.
					Pozwala to na podłączanie do jednej linii wielu bramek i decydowaniu która z nich będzie nią sterować.
				</p>
			</section>
			<section>
				<img src="img/open_drain.svg" class="right_img" style="height:130px;" alt="idea open-drain" />
				<h5>open collector / drain</h5>
				<p>Są kolejnym rodzajem bramek których wyjścia można podłączać do wspólnej linii. Układy te posiadają wyjście w postaci tranzystora zwierającego linię wyjściową do masy, z tego względu samodzielnie zapewniają jedynie stan niski wyjścia (są w stanie wymusić stan niski, ale nie mają możliwości wymuszenia stanu wysokiego).</p>
				<p>Stan wysoki musi zostać zapewniony zewnętrznym rezystorem podciągającym. Pozwala to stosować na takiej linii inny poziom stanu wysokiego niż na wejściach takiej bramki oraz pozwala na sterowanie wspólnej linii przez wiele bramek (czyli łączenie wyjść bramek, jednak w odróżnieniu od bramek trój-stanowych nie wymaga dodatkowych sygnałów sterujących).</p>
				<p>Na schemacie obok przedstawiono dwa układy (U1 i U2) typu open-drain sterujące wspólną linią wyjściową w układzie <dfn>suma na drucie</dfn>. Jeżeli jeden z podłączonych do linii układów będzie miał wewnętrzne wyjście ("ctrl<var>X</var>") w stanie wysokim to jego wyjście OC będzie zwarte do masy (negacja na tranzystorze N-MOS lub NPN), wtedy też cała linia będzie w stanie niskim.</p>
			</section>
			<section>
				<h5>budowa wewnętrzna</h5>
				<img src="img/bramki_cmos.svg" class="right_img" style="height:430px;" alt="budowa bramek logicznych" />
				<p>
					Przedstawiony powyżej układ sumy na drucie jest bardzo prostą (jedno tranzystorową) realizacją bramki logicznej realizującą funkcję logiczną NOT OR (z punktu widzenia wejść <i>ctrl1</i> i <i>ctrl2</i> oraz wyjścia <i>Out</i>).
					W podobny sposób można zrealizować bramkę AND (negując wejścia, np. przy pomocy jednego traznzystora).
					Jeszcze bardziej uproszczoną realizację można uzyskać stosując diody pozwalające na wpływanie prądu do węzła (funkcja OR) lub wypływanie z niego (funkcja AND).
				</p>
				<p>Po prawej przedstawione zostały schematy ideowe inwertera, dwóch podstawowych bramek (NOR i NAND) oraz bramki transmisyjnej (bufora 3 stanowego) w technologii CMOS.</p>
				<p>
					Działanie tych bramek (za wyjątkiem transmisyjnej) polega na otwieraniu tranzystorów podłączonych do napięcia które chcemy otrzymać na wyjściu, a zamykaniu prowadzących do napięcia przeciwnego. W szczególności bramka NOT stanowi pół-mostek H pomiędzy stanem wysokim a stanem niskim.
					Dzięki zastosowaniu tranzystorów PMOS polaryzowanych Vdd oraz NMOS polaryzowanych GND obie gałęzie operują na tym samym sygnale wejściowym (nie jest wymagana jego negacja). Szeregowe łączenie tranzystorów zapewnia że należy otworzyć oba aby otworzyć daną drogę, a równoległe że otwarcie danej drogi powodowane jest otwarciem pojedynczego tranzystora. Dzięki zastosowaniu technologi MOS i podłączaniu wejść bramki tylko do bramek tranzystorów wejścia praktycznie nie pobierają prądu (istotnym wyjątkiem jest chwila zmiany sygnału).
				</p>
				<p>Działanie bramki transmisyjnej polega na przepuszczaniu lub nie (w zależności od stanu wejścia sterującego) sygnału z wejścia na wyjście. Bramka taka nie regeneruje sygnału. Ponadto w uproszczonym (jedno tranzystorowym) rozwiązaniu prowadzi ona do degradacji sygnału wartość w przybliżeniu równą napięciu progowemu tranzystora. Dlatego też na ogół występuje wraz z bramką NOT (bufor 3 stanowy z negacją) lub dwiema szeregowo połączonymi bramkami NOT (bufor 3 stanowy bez negacji).</p>
			</section>
			<section class="noclear">
				<h5>wejście Schmitta</h5>
				<p>Układy z wejściem Schmitta zapewniającym histerezę sygnału wejściowego stosowane są w przypadku mało stromych, zaszumionych sygnałów dla których układy z normalnym wejściem mogłyby zmienić kilkukrotnie stan wyjścia na jednym zboczu sygnału wejściowego.</p>
			</section>
			<p class="examples">
				74HC00 (4 x 2-input NAND);  74HC1G00 (1 x 2-input NAND);
				74HC20 (2 x 4-input NAND);
				74HC30 (1 x 8-input NAND);
				74HC03 (4 x 2-input NAND, open-drain);
				74HC132 (4 x 2-input NAND, Schmitt);
				<br />
				74HC04 (6 x NOT);            74HC1G04 (1 x NOT);
				74HC14 (6 x NOT, Schmitt);   74HC1G14 (1 x NOT, Schmitt);
				74HC02 (4 x 2-input NOR);    74HC1G02 (1 x 2-input NOR);
				74HC08 (4 x 2-input AND);    74HC1G08 (1 x 2-input AND);
				74HC32 (4 x 2-input OR);     74HC1G32 (1 x 2-input OR);
				74HC86 (4 x 2-input XOR);    74HC1G86 (1 x 2-input XOR);
				74HC7226 (4 x 2-input XNOR);
				74HC7014 (6 x Schmitt);
			</p>
		</section><!-- END: Elektronika - Bramki -->
		<section><!-- BEGIN: Elektronika - Przerzutniki i rejestry -->
			<h4>Przerzutniki i rejestry</h4>
			<img src="img/flipflops.svg" class="right_img" style="height:560px;" alt="przerzutniki i ich budowa" />
			<section class="noclear">
				<h5>przerzutnik / zatrzask RS</h5>
				<p>RS Flip-flop (RS Latch) jest podstawowym układem służącym do zapamiętania jednego bitu informacji. Posiada on dwa wejścia (set i reset) i dwa wyjścia (Q i NOT Q), wejścia mogą reagować na stan wysoki (oznaczane jako S i R) lub niski (oznaczane jako wejścia zanegowane ~S i ~R), jedno z wyjść może być jedynie wewnętrzne (nie wyprowadzone na zewnątrz układu). Podanie stanu wysokiego na wejście S (niskiego na ~S) powoduje wystawienie stanu wysokiego na wyjściu Q, a podanie stanu wysokiego na wejście R (niskiego na ~R) powoduje wystawienie stanu niskiego na wyjściu Q. Stan na wyjściu Q nie zmienia się po zmianie wejść S i R na stan niski (zostaje zapamiętany).</p>
				<p>Na schemacie przedstawiono dwubramkową budowę przerzutnika RS zarówno w wariancie z wejściami nie zanegowanymi jak i w wariancie z wejściami zanegowanymi.</p>
			</section>
			<section class="noclear">
				<h5>zatrzask a przerzutnik</h5>
				<p><dfn>Zatrzask</dfn> jest elementem reagującym na poziom sygnału na wejściu "enable" (E). W przypadku nie zanegowanego wejścia E, jeżeli jest ono w stanie wysokim sygnał na wyjściach (Q i NOT Q) jest funkcją sygnałów wejściowych, natomiast stan niski wejścia E blokuje zmianę sygnału wyjściowego (zostaje on zapamiętany).</p>
				<p><dfn>Przerzutnik</dfn> jest elementem reagującym na zbocze sygnału na wejściu "clock" (CLK). W zależności od konstrukcji może reagować na zbocze narastające, opadające albo na oba (wtedy na jednym realizuje odczyt wejść a na drugim zmianę stanu wyjść).</p>
			</section>
			<section class="noclear">
				<h5>zatrzask i przerzutnik JK</h5>
				<p>Posiada dwa wejścia sygnałowe (J i K) oraz wejście "enable" (E) w przypadku zatrzasku lub wejście "clock" (CLK) w przypadku przerzutnika. Może także posiadać asynchroniczne (niezależne od stanu wejścia E / CLK) wejścia reset i set (zanegowane lub proste).</p>
				<table style="text-align:center">
					<tr><td>J</td><td>K</td><td>Q<sub>n+1</sub></td>  <td>Opis</td></tr>
					<tr><td>0</td><td>0</td><td>Q<sub>n</sub></td>    <td>brak zmiany</td></tr>
					<tr><td>0</td><td>1</td><td>0</td>                <td>reset</td></tr>
					<tr><td>1</td><td>0</td><td>1</td>                <td>set</td></tr>
					<tr><td>1</td><td>1</td><td>NOT Q<sub>n</sub></td><td>zmiana wyjścia na przeciwny</td></tr>
				</table>
				<p>Stan wejść J = K = 1 dozwolony jest tylko w przypadku przerzutnika, gdyż wtedy sygnał CLK decyduje o momencie zmiany wyjścia Q na przeciwne. W przypadku zatrzasku, przy wysokim E wystąpiłyby oscylacje na wyjściu.</p>
				<p class="examples">
					74HC73 (2 x przerzutnik JK, zbocze opadające, wejścia ~R);
					74HC107 (2 x przerzutnik JK, zbocze opadające, wejścia ~R);
					74HC112 (2 x przerzutnik JK, zbocze narastające, wejścia ~S i ~R);
					74HC112 (2 x przerzutnik JK, zbocze opadające, wejścia ~S i ~R)
				</p>
			</section>
			<section class="noclear">
				<h5>zatrzask i przerzutnik D</h5>
				<p>Posiada jedno wejścia sygnałowe "data" (D) oraz wejście "enable" (E) w przypadku zatrzasku lub wejście "clock" (CLK) w przypadku przerzutnika. Może także posiadać asynchroniczne (niezależne od stanu wejścia E / CLK) wejścia reset i set (zanegowane lub proste). Obniżenie sygnału E lub zbocze sygnału CLK powodują zapamiętanie (i wystawienie na wyjściu Q) stanu wejścia D.</p>
				<p>W przypadku zaprezentowanej realizacji przerzutnika z dwóch zatrzasków sygnał wejściowy zostanie odczytany na zboczu opadającym zegara a wystawiony na wyjście na zboczu narastającym.</p>
				<div style="width:800px; margin-left: auto; margin-right: auto; margin-bottom:13pt;">
				<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="-10 0 440 44" style="height:80px; stroke:black; fill:none;">
					<g transform="translate(0,12)">
						<text x="-7" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">D</text>
						<polyline points="
							0,0  10,0  10,-10  20,-10  20,0  30,0  30,-10  40,-10  40,0  50,0  50,-10  60,-10  60,0  70,0  70,-10  80,-10  80,0  90,0  90,-10 100,-10
							100,0 110,0 110,-10 120,-10 120,0 130,0 130,-10 140,-10 140,0 150,0 150,-10 160,-10 160,0 170,0 170,-10 180,-10 180,0 190,0 190,-10 200,-10
						" stroke-width="1" />
					</g>
					<g transform="translate(0,27)">
						<text x="-7" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">E</text>
						<polyline points="0,-10  45,-10  45,0  75,0  75,-10 115,-10 115,0 175,0 175,-10 200,-10" stroke-width="1" />
					</g>
					
					<g transform="translate(0,42)">
						<text x="-7" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">Q</text>
						<polyline points="
							  0,0  10,0  10,-10  20,-10  20,0  30,0  30,-10  40,-10  40,0  75,0  75,-10  80,-10  80,0  90,0  90,-10 100,-10
							100,0 110,0 110,-10 180,-10 180,0 190,0 190,-10 200,-10
						" stroke-width="1" />
					</g>
					
					<g transform="translate(230,12)">
						<text x="-7" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">D</text>
						<polyline points="
							0,0  10,0  10,-10  20,-10  20,0  30,0  30,-10  40,-10  40,0  50,0  50,-10  60,-10  60,0  70,0  70,-10  80,-10  80,0  90,0  90,-10 100,-10
							100,0 110,0 110,-10 120,-10 120,0 130,0 130,-10 140,-10 140,0 150,0 150,-10 160,-10 160,0 170,0 170,-10 180,-10 180,0 190,0 190,-10 200,-10
						" stroke-width="1" />
					</g>
					<g transform="translate(230,27)">
						<text x="-13" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">CLK</text>
						<polyline points="0,-10  15,-10  15,0  25,0  25,-10  35,-10  35,0  55,0  55,-10  62,-10  62,0  67,0  67,-10  95,-10  95,0 105,0 105,-10 125,-10 125,0 145,0 145,-10 155,-10 155,0 175,0 175,-10 200,-10" stroke-width="1" />
					</g>
					
					<g transform="translate(230,42)">
						<text x="-7" y="-3" text-anchor="middle" style="font-size: 50%; fill:black; stroke:none">Q</text>
						<polyline points="25,-10  67,-10  67,0  105,0 105,-10 145,-10 145,0 175,0 175,-10, 200,-10
						" stroke-width="1" />
					</g>
				</svg></div>
				<p class="examples">
					74HC74 (2 x przerzutnik D, zbocze narastające, wejścia ~S i ~R);
					74HC173 (4 x przerzutnik D, zbocze narastające, sygnał input-enable, wspólny reset i clock, wyjścia Q trój-stanowe);
					74HC174 (6 x przerzutnik D, zbocze opadające, wspólny reset i clock);
					74HC175 (4 x przerzutnik D, zbocze narastające, wspólny reset i clock, wyjścia Q i NOT Q);
				</p>
			</section>
			<section>
				<h5>rejestry</h5>
				<img src="img/registers.svg" class="right_img" style="height:550px;" alt="rejestry i ich budowa" />
				<p>Mianem rejestru n-bitowego określa się zespół n przerzutników (rzadziej zatrzasków), często z uwspólnionym sterowaniem (sygnały clock, set, reset, etc) służący do zapamiętania n-bitowej wartości (liczby). W zależności od sposobu zapisu i odczytu można wyróżnić:
				<dl>
					<dt><dfn>rejestry równoległe</dfn></dt>
					<dd>
						<p>Posiadają taką samą liczbę wejść jak i wyjść, sygnał na i-tym wyjściu jest bezpośrednio powiązany z sygnałem z i-tego wejścia (jest sygnałem zapamiętanym z tego wejścia).</p>
						<p class="examples">
							74HC273 (8bit, zbocze narastające, sygnał reset);
							74HC374 (8bit, zbocze narastające, wyjścia trój-stanowe);
							74HC377 (8bit, zbocze narastające, sygnał reset, sygnał input-enable);
							74HCT534 (8bit, zbocze narastające, wyjścia trój-stanowe zanegowane);
							74HC574 (8bit, zbocze narastające, wyjścia trój-stanowe);
							<br />
							74HC373 (8bit, zatrzask przeźroczysty w stanie wysokim, wyjścia trój-stanowe);
							74HC563 (8bit, zatrzask przeźroczysty w stanie wysokim, wyjścia trój-stanowe zanegowane);
							74HC573 (8bit, zatrzask przeźroczysty w stanie wysokim, wyjścia trój-stanowe);
						</p>
					</dd>
					
					<dt><dfn>rejestry szeregowe serial-input</dfn></dt>
					<dd>
						<p>Z kolejnymi sygnałami zegarowymi odczytywany jest stan wejścia szeregowego, a stan poprzedni przenoszony jest do kolejnego przerzutnika w ramach rejestru. W ten sposób po n cyklach zegara n-bitowy rejestr ma zapisaną nową zawartość. Często posiada zespolony z nim rejestr równoległy zapobiegający zmianie stanu wyjść w trakcie ładowania danych z wejścia szeregowego przepisanie danych z rejestru przesuwnego do rejestru odpowiedzialnego za sterowanie wyjściami sterowane jest osobnym sygnałem zegarowym.</p>
						<p class="examples">
							74HC164 (8 bit, bez rejestru wyjściowego);
							74HC194 (4 bit, wejście równoległe, przesuwanie w prawo i w lewo);
							74HC195 (4 bit, wejście równoległe);
							74HC594 (8 bit, zatrzask wyjściowy z resetem, wyjście szeregowe, sygnał resetu);
							74HC595 (8 bit, zatrzask wyjściowy z wyjściami trój-stanowymi, wyjście szeregowe, sygnał resetu);
							74HC4094 (8 bit, zatrzask wyjściowy z wyjściami trój-stanowymi, wyjście szeregowe, zatrzask wyjścia szeregowego);
						</p>
					</dd>
					
					<dt><dfn>rejestry szeregowe paraller-input serial-output</dfn></dt>
					<dd>
						<p>Z kolejnymi sygnałami zegarowymi na wyjście szeregowe wystawiany jest stan kolejnego z rejestrów wejściowych. Wariant asynchroniczny posiada osobny sygnał powodujący odczyt wejść do rejestru (sygnał działa jak "enable" w zatrzaskach). Wariant synchroniczny posiada sygnał decydujący o tym czy na zboczu zegara dokonywany jest odczyt wejść czy też przesuwanie zawartości rejestru umożliwiający odczyt z wyjścia szeregowego.</p>
						<p class="examples">
							74HC165 (asynchroniczne wczytanie danych wejściowych, wejście szeregowe, sygnał clock-enable);
							74HC166 (synchroniczne wczytanie danych wejściowych, wejście szeregowe, sygnał clock-enable);
							74HC589 (dodatkowy zatrzask wejściowy, asynchroniczne wczytanie danych wejściowych, wejście szeregowe, wyjście trój-stanowe);
							74HC597 (dodatkowy zatrzask wejściowy, asynchroniczne wczytanie danych wejściowych, wejście szeregowe, sygnał clock-enable);
						</p>
					</dd>
					
					<dt><dfn>liczniki</dfn></dt>
					<dd>
						<p>Z kolejnymi sygnałami zegarowymi zwiększana jest o jeden wartość rejestru. Prostszy w budowie licznik asynchroniczny ma większe (i w dodatku rosnące wraz z bitowością licznika) ograniczenia dotyczące szybkości zliczania od licznika synchronicznego, ze względu na opóźnienie z jakim dochodzi zliczany sygnał (CLK) do kolejnych stopni licznika.</p>
						<p class="examples">
							74HC93 (2x 4bit synchroniczny, zbocze opadające);
							74HC161 (4bit synchroniczny, zbocze narastające, preset wartością początkową, wejście zezwolenia na zliczanie, sygnał przepełnienia);
							74HC163 (4bit synchroniczny, zbocze opadające, preset wartością początkową, wejście zezwolenia na zliczanie, sygnał przepełnienia);
							74HC191 (4bit synchroniczny, zbocze narastające, liczący w górę i w dół - sygnał wyboru, wejście zezwolenia na zliczanie, preset wartością początkową);
							74HC192 (4bit synchroniczny, zbocze narastające, liczący w górę i w dół - osobne zegary, wejście zezwolenia na zliczanie, preset wartością początkową, sygnał przepełnienia przy 9 - BCD);
							74HC193 (4bit synchroniczny, zbocze narastające, liczący w górę i w dół - osobne zegary, wejście zezwolenia na zliczanie, preset wartością początkową, sygnał przepełnienia przy 15);
							74HC393 (2x 4bit asynchroniczny, zbocze opadające, sygnał resetu);
							74HC40103 (8 bit synchroniczny);
							74HC4017 (dekadowy - wartości odpowiada numer aktywnego wyjścia, 10 wyjść);
							74HC4020 (14 bitowy asynchroniczny);
							74HC4040 (12 bitowy asynchroniczny);
							74HC390; 74HC4024; 74HC4060; 74HC4518; 74HC4520; 
						</p>
					</dd>
				</dl>
				</p>
			</section>
		</section><!-- END: Elektronika - Przerzutniki i rejestry -->
		<section>
			<h4>Przetworniki ADC i DAC</h4>
			<p>Przetwornik analogowo-cyfrowe (ADC) służy do konwersji sygnału analogowego na postać cyfrową. Realizowane jest to poprzez pomiar napięcia, na ogół w regularnych odstępach czasowych (celem uzyskania przebiegu sygnału a nie tylko wartości chwilowej).
				Przetwornik ADC o porównaniu bezpośrednim realizowany jest w oparciu o zespół komparatorów analogowych (od ich liczby zależy bitowość danego przetwornika, ale ich liczba nie jest równa bitowości) które używają różnych napięć referencyjnych (typowo uzyskiwanych z jednego napięcia referencyjnego poprzez dzielnik). Stan z komparatorów podawany jest na enkoder celem konwersji do kodu binarnego.
				Inne stosowane sposoby realizacji przetworników ADC opierają się o pojedynczy komparator i podawanie na niego narastającego napięcia referencyjnego oraz zliczanie liczby kroków podnoszenia tego napięcia bądź podawaniu kolejnych napięć z przetwornika DAC i wyszukiwaniu tego które jest najbliższe wejściowemu.
			</p>
			<p>Przetwornik cyfrowo-analogowy (DAC) służy do konwersji sygnału cyfrowego na analogowy. Oparty jest na zasadzie sumatora napięć, którego wejścia załączane są w zależności od ustawienia lub nie danego bitu w konwertowanej wartości. Typowo zamiast stosowania różnych wartości napięć i jednakowych rezystorów (jak w sumatorze), stosuje się różne wartości załączanych rezystorów i jednakowe napięcie do którego są podłączone.</p>
			<section>
				<h5>pomiar napięcia i prądu</h5>
				<p>Pomiar napięcia realizuje bezpośrednio przetwornik ADC. W przypadku konieczności pomiaru wysokich napięć stosuje się przekładniki napięciowe, będące w istocie transformatorami o dobrze ustalonych parametrach pomiarowych. W przypadku małych napięć konieczne może okazać się ich wzmocnienie np. z użyciem wzmacniacza operacyjnego.</p>
				
				
				<p>Pomiar prądu może być realizowany na kilka sposobów:<ul>
					<li>jako pomiar napięcia na rezystancji włączonej w mierzony obwód;
						umożliwia pomiar prądów zmiennych i stałych</li>
					<li>poprzez przekładnik prądowy - transformator włączony szeregowo w obwód lub toroidalną cewkę przez którą przeprowadzony jest przewodnik w którym dokonywany jest pomiar prądu (pojedyncze uzwojenie pierwotne);
						stosuje się tylko dla prądów przemiennych (zmienny prąd w przewodzie powoduje powstanie indukcji magnetycznej która wymusza przepływ prądu w obwodzie pomiarowym)</li>
					<li>z wykorzystaniem efektu Halla (prąd może przepływać bezpośrednio przez układ pomiarowy, może płynąć pętlą ścieżki umieszczoną z drugiej strony płytki drukowanej niż czujnik efektu Halla lub może być realizowany analogicznie do toroidalnego przekładnika prądowego);
						umożliwia pomiar prądów zmiennych i stałych</li>
				</ul></p>
				<p class="examples">
					ACS712  (czujnik prądu AC i DC oparty na efekcie Halla z wyjściem napięciowym, oporność toru pomiarowego 1.2 mΩ, wersje: 5A (185 mV/A), 20A (100 mV/A) i 30A (66mV/A);
					ACS770  (czujnik prądu AC i DC oparty na efekcie Halla z wyjściem napięciowym, oporność toru pomiarowego 0.1 mΩ, wersje: 50A, 100A i 200A);
					WCS1800 (przekładnik prądowy z wbudowanym czujnikiem prądu AC i DC opartym na efekcie Halla z wyjściem napięciowym, czułość: 66 mV/A, 25A AC / 35A DC);
					WCS1600 (przekładnik prądowy z wbudowanym czujnikiem prądu AC i DC opartym na efekcie Halla z wyjściem napięciowym, 70A AC / 100A DC);
					SS49E (czujnik efektu Halla); SS411P (czujnik efektu Halla); TLE4905L (czujnik efektu Halla);
				</p>
			</section>
		</section>
	</section>
	<section>
		<h3>Transmisja</h3>
		<section><!-- BEGIN: Elektronika - Transmisja - sterowanie linią -->
			<h4>Sterowanie linią</h4>
			<img src="img/bufory_i_multipleksacja.svg" class="right_img" style="height:850px;" alt="bufor dwukierunkowy, encoder, decoder i multiplexer" />
			<section class="noclear">
				<h5>bufory</h5>
				<p>
					Bufor jest to układ przekazujący sygnał logiczny z wejścia na wyjście. Bufor może służyć do:
					<ul>
						<li>regeneracji sygnału,</li>
						<li>uniemożliwieniu wprowadzenia sygnału z jego strony wyjściowej na wejściową,</li>
						<li>decydowania o jego przepuszczeniu lub nie (trój-stanowy),</li>
						<li>decydowania o kierunku przepuszczenia sygnału (dwa trój-stanowe albo trój-stanowy dwukierunkowy),</li>
						<li>konwersji na linię open-collector / open-drain,</li>
						<li>negacji sygnału (niektóre bufory realizują funkcję NOT).</li>
					</ul>
				</p>
				<p class="examples">
					74HC125 (4bit, trój-stanowy, wyjście aktywowane niskim);  74HC1G125 (1bit, trój-stanowy, wyjście aktywowane niskim);
					74HC126 (4bit, trój-stanowy, wyjście aktywowane wysokim); 74HC1G126 (1bit, trój-stanowy, wyjście aktywowane wysokim);
					74HC240 (2 x 4bit, trój-stanowy, wyjście aktywowane niskim, odwracający);
					74HC241 (2 x 4bit, trój-stanowy, w jednej grupie wyjście aktywowane wysokim w drugiej niskim);
					74HC244 (2 x 4bit, trój-stanowy, wyjście aktywowane niskim);
					74HC245 (8bit, trój-stanowy, dwukierunkowy - wejście wyboru kierunku, wyjście aktywowane niskim);
					74HC367 (4bit + 2bit, trój-stanowy, wyjście aktywowane niskim);
					74HC540 (8bit, trój-stanowy, wyjście aktywowane niskim, dwa sygnały aktywacji - AND, odwracający);
					74HC541 (8bit, trój-stanowy, wyjście aktywowane niskim, dwa sygnały aktywacji - AND);
					74HC7541 (8bit, trój-stanowy, wyjście aktywowane niskim, dwa sygnały aktywacji - AND, wejścia Schmitta);
					74HC05 (6 bit, open-drain, odwracający);
					ULN2802A (8 bit, open-collector, odwracający, 500mA);
				</p>
			</section>
			<section class="noclear">
				<h5>enkodery</h5>
				<p>Enkoder "<var>n</var> to <var>m</var>" jest to układ o <var>n</var> wejściach, który na swoim <var>m</var> bitowym wyjściu wystawia numer (typowo) wejścia o najwyższym numerze, które znajduje się w stanie niskim. Możliwe są też warianty wystawiające numer pierwszego (a nie ostatniego) w kolejności wejścia lub wybierające wejście ze stanem wysokim.</p>
				<p>Jako że wejścia numerowane są zazwyczaj od zera do 2<sup><var>m</var></sup> to układ najczęściej posiada dodatkowe wyjście informujące że którekolwiek z wejść jest w stanie aktywnym. Typowo numer wystawiany jest w postaci NKB, ale możliwe są inne kodowania.</p>
				<p>Układ pozwala na redukcję ilości wejść potrzebnych do obsługi n-bitowego sygnału w którym tylko jeden bit może być ustawiony lub w którym można pozwolić sobie na obsługę kolejnych linii z kasowaniem ich bitu (np. wektor przerwań z priorytetyzacją).</p>
				<p class="examples">
					74HC148 (8 to 3, priority, active low);
					74HC147 (9 + "none" to 4 / 10 to 4, priority, active low);
				</p>
			</section>
			<section class="noclear">
				<h5>dekodery</h5>
				<p>Dekoder "<var>m</var> to <var>n</var>" jest układem o działaniu przeciwnym do enkodera. Aktywuje on wyjście o numerze odpowiadającym wartości na m-bitowym wejściu adresowym. Typowo posiada także wejście zezwolenia na aktywację wyjść, które może zostać użyte do podłączenia informacji że którekolwiek z wejść enkodera było w stanie aktywnym lub do podłączenia sygnału danych z multipleksowanej linii celem jej demultipleksacji.</p>
				<p class="examples">
					74HC138 (3 to 8, trzy wejścia zezwolenia, odwracający);
					74HC238 (3 to 8, trzy wejścia zezwolenia, nieodwracający);
					74HC137 (3 to 8 + zatrzask na adresie, odwracający);
					74HC237 (3 to 8 + zatrzask na adresie, nieodwracający);
					74HC259 (3 to 8 + zatrzask na wyniku,  sygnał reset, nieodwracający);
					74HC139 (2x "2 to 8", osobne wejścia zezwolenia, nieodwracający);
					74HC154 (4 to 16, dwa wejścia zezwolenia, odwracający);
				</p>
			</section>
			<section class="noclear">
				<h5>(de)multipleksery cyfrowy</h5>
				<p>Multiplekser cyfrowy (jednokierunkowy) na wyjście kopiuje stan wskazanego (poprzez adres podany na wejście adresowe) wejścia. W przypadku braku sygnału "enable" w zależności od rozwiązania wyjście pozostanie w stanie niskim lub wysokiej impedancji.</p>
				<p>Demultiplekser cyfrowy (jednokierunkowy) to zazwyczaj układ dekodera w którym na wejście enabled podany jest sygnał z multipleksowanej linii. Nie wybrane wyjścia pozostają w stanie niskim lub wysokim (zależnie od użycia nieodwracającego lub odwracającego dekodera). Cyfrowe demultipleksery z 3 stanowym wyjściem są rzadkością. Demultipleksację można rozwiązać także przy pomocy odpowiednio sterowanych (np. z dekodera adresu) buforów trój-stanowych lub dwu-wejściowych multiplekserów.</p>
				<p class="examples">
					74HC151  (1 x "8 to 1", multiplekser cyfrowy jednokierunkowy, wyjścia proste i zanegowane);
					74HC153  (2 x "4 to 1", multiplekser cyfrowy jednokierunkowy, wspólne wejścia adresowe);
					74HC157  (4 x "2 to 1", multiplekser cyfrowy jednokierunkowy, wspólne wejścia adresowe);
					<br />
					74HC251  (1 x "8 to 1", multiplekser cyfrowy jednokierunkowy, wyjścia trój-stanowe proste i zanegowane);
					74HC253  (2 x "4 to 1", multiplekser cyfrowy jednokierunkowy, wyjścia trój-stanowe, wspólne wejścia adresowe, osobne wejścia output-enable);
					74HC257  (4 x "2 to 1", multiplekser cyfrowy jednokierunkowy, wyjścia trój-stanowe, wspólne wejścia adresowe i output-enable);
					<br />
					74LVC1G18 (1 x "1 to 2", demultiplekser cyfrowy jednokierunkowy, wyjścia trój-stanowe, można zastąpić układem połączonych 74HC1G125 z 74HC1G126);
				</p>
			</section>
			<section class="noclear">
				<h5>(de)multipleksery analogowy</h5>
				<p>Multiplekser analogowy (dwukierunkowy) działa na zasadzie przełącznika łączącego wskazane wejście z wyjściem, dzięki elektrycznemu "zwarciu" (na ogół rezystancja takiego zwarcia to kilkadziesiąt omów) wejścia z wyjściem transmisja może odbywać się w obu kierunkach. Pozwala to także na wykorzystanie tego samego układu w roli multipleksera i demultipleksera.</p>
				<p class="examples">
					74HC4053 (3 x "2 to 1 / 1 to 2", multiplekser analogowy dwukierunkowy, osobne wejścia adresowe, wspólne wejście enable, trój-stanowy);
					74HC4052 (2 x "4 to 1 / 1 to 4", multiplekser analogowy dwukierunkowy, wspólne wejścia adresowe i enable, trój-stanowy);
					74HC4051 (1 x "8 to 1 / 1 to 8", multiplekser analogowy dwukierunkowy, trój-stanowy);
					74HC4067 (1 x "16 to 1" / 1 to 16", multiplekser analogowy dwukierunkowy, trój-stanowy); 
					<br />
					74HC4066 (4 x analog switch on-off, dwukierunkowy, osobne wejścia sterujące); 74HC1G66 (1x analog switch on-off dwukierunkowy);
					DG212B (4 x analog switch on-off, dwukierunkowy, osobne wejścia sterujące);
				</p>
			</section>
		</section><!-- END: Elektronika - Transmisja - sterowanie linią -->
		<section>
			<h4>Medium transmisyjne</h4>
			<p>
				Mianem medium transmisyjnego określa się nośnik informacji służący do łączności pomiędzy systemami. Wyróżnić można następujące media transmisyjne:
				<ul>
					<li>przewód elektryczny, m.in.:<ul>
						<li>zwykły przewód, na ogół wielożyłowy (tzw "taśmy", przewody telefoniczne)</li>
						<li>kabel typu skrętka (także w różnych wariantach ekranowania)</li>
						<li>kabel współosiowy (koncentryczny)</li>
						<li>kabel symetryczny "twin-lead"</li>
					</ul></li>
					<li>światłowód:<ul>
						<li>wielomodowy</li>
						<li>jednomodowy</li>
					</ul></li>
					<li>bezprzewodowe (zarówno radiowe jak i optyczne):<ul>
						<li>dookolne (izotropowe)</li>
						<li>kierunkowe (w szczególności optyczne linie laserowe)</li>
					</ul></li>
				</ul>
			</p>
			
			<p>W przypadku przewodów typu skrętka stosowana jest transmisja różnicowa to znaczy informacja kodowana jest w różnicy napięć pomiędzy dwoma przewodami wchodzącymi w skład pojedynczej skręconej pary. Żaden z przewodów wchodzących w skład pary nie jest powiązany z potencjałem masy, nie ma też znaczenia różnica potencjału pojedynczego przewodu w stosunku co do masy (ważna jest tylko wzajemna różnica potencjałów), sygnał nadawany w jednym z nich jest w przeciw-fazie do sygnału nadawanego w drugim. Służy to eliminacji zakłóceń elektromagnetycznych (zakłócenie indukuje się w obu przewodach jednakowo, więc różnica nie ulega zmianie) oraz zakłóceń wzajemnych, przesłuchów (sumaryczny prąd płynący parą jest bliski zeru). Typowo linie takie korzystają z dedykowanych układów nadawczo-odbiorczych opartych na zasadzie wzmacniacza różnicowego.</p>
			
			<p>Połączenia światłowodowe charakteryzują się m.in.:<ul>
				<li>pełną separacją galwaniczną (opto-izolacją) pomiędzy łączonymi systemami</li>
				<li>bardzo dużą odpornością na zakłócenia</li>
				<li>dużą przepustowością i dużą prędkością transmisji</li>
				<li>możliwością bezpośredniej (bez stosowania wzmacniaczy umieszczonych w środku linii) transmisji na bardzo duże odległości</li>
			</ul></p>
		</section>
		<!-- BEGIN: Elektronika - Typy transmisji -->
		<section>
			<h4>Topologia połączeń i typy transmisji</h4>
			<img src="img/topologie.svg" class="right_img" style="height:277px;" alt="przykład realizacji magistrali szeregowej simplex" />
			
			<p>Obok przedstawione zostały główne topologie połączeń:
				<dl>
					<dt><dfn>linear bus</dfn> (magistrala)</dt>
					<dd>wszystkie urządzenia są podłączone do jednej linii (wspólnego medium transmisyjnego), okablowanie nie wyróżnia punktu centralnego</dd>
					
					<dt><dfn>daisy chain</dfn></dt>
					<dd>struktura okablowania podobna jak w magistrali, ale medium transmisyjne jest podzielone (połączenie n urządzeń składa się z n-1 łączy punkt-punkt pomiędzy urządzeniami)</dd>
					
					<dt><dfn>ring</dfn> (pierścień)</dt>
					<dd>topologia daisy chain w której końce są połączone, uodparnia to na pojedyncze uszkodzenie</dd>
					
					<dt><dfn>star</dfn> (gwiazda)</dt>
					<dd>wszystkie podłączenia biorą początek w węźle centralnym, w zależności od konstrukcji węzła centralnego może być realizowana w oparciu o współdzielone medium lub połączenia punkt-punkt</dd>
					
					<dt><dfn>mesh</dfn> (krata)</dt>
					<dd>każde urządzenie ma bezpośrednie połączenie punkt-punkt do każdego innego urządzenia (połączenie n urządzeń wymaga n(n-1)/2 połączeń punkt punkt)</dd>
				</dl>
				Ponadto występują topologie mieszane złożone z opisanych powyżej: gwiazda wielokrotna (tzn. taka gdzie niektóre z węzłów stanowią punkty centralne kolejnych gwiazd), magistrala lub ring pomiędzy punktami centralnymi gwiazd, gwiazda w której w węzłach występują magistrale lub pierścienie, itd.
			</p>
			<p>
				Wyróżnić można typy transmisji:
				<dl>
					<dt><dfn>simplex</dfn></dt><dd>umożliwia tylko transmisję jednokierunkową</dd>
					<dt><dfn>half-duplex</dfn></dt><dd>umożliwia transmisję dwukierunkową, ale tylko w jedną stronę równocześnie</dd>
					<dt><dfn>full-duplex</dfn></dt><dd>umożliwia pełną transmisję dwukierunkową (równoczesne nadawanie i odbiór)</dd>
				</dl>
			</p>
		</section>
		<section>
			<h4>Magistrala równoległa</h4>
			<img src="img/magistrala_rownolegla.svg" class="right_img" style="height:370px;" alt="przykład realizacji magistrali równoległej half-duplex ze współdzielonymi liniami danych" />
			<p>
				Magistrala równoległa jest zespołem linii, wraz z układami nimi sterującymi, umożliwiającym równoległe przesyłanie danych (w jednym czasie / takcie zegara na magistrali wystawiane / przesyłane jest całe n-bitowe słowo).
				Można wyróżnić szyny sterującą (kierunek przypływu, żądania obsługi, etc), adresową (adres układu który ma prawo nadawać) i danych (przesyłane dane). Często szyna adresowa współdzieli linie transmisyjne z szyną danych.
				Do realizacji magistrali (celem umożliwiania podłączenia wielu układów) stosuje się zazwyczaj bufory trój-stanowe, a do zapewnienia współdzielonej szyny żądania obsługi (interrupt request) często układy typu open-collector.
			</p>
			<p>
				Typowy układ realizacji magistrali half-duplex ze współdzielonymi liniami danych i adresu przestawiony został na schemacie zamieszczonym obok.<br />
				Zadaniem dekodera adresu jest ustalenie czy wystawiony na magistrali adres (w trakcie wysokiego stanu linii "Adres / Not Dane") jest adresem danego urządzenia i zapamiętanie tej informacji do czasu wystawienia nowego adresu. Informacja ta jest wykorzystywana do sterowania dwukierunkowym buforem trój-stanowym (jako sygnał enable).<br />
				O kierunku działania bufora decyduje sygnał "Read / Not Write". Przy magistralach o ustalonym protokole transmisyjnym sterowanie kierunkiem może być zależne od wykonywanej komendy (po ustawieniu adresu urządzenie odczytuje z magistrali polecenie i w zależności od niego steruje kierunkiem bufora - odczytuje lub zapisuje dane na magistralę).<br />
				Zastosowanie kilku linii typu OC do odbierania żądań obsługi pozwala (na podstawie tego które z tych linii znalazły się w stanie niskim na identyfikację urządzenia lub grupy urządzeń, z której niektóre zgłaszają żądanie obsługi.
			</p>
			<p>
				W przypadku prostych urządzeń wejścia / wyjścia zamiast buforu dwukierunkowego może być umieszczony np.
					jednokierunkowy bufor (lub n-bitowy rejestr) z wyjściami trój-stanowymi, który wystawia dane na magistralę w oparciu o sygnał zapisu na magistralę (WR) oraz zegar (clock) albo
					n-bitowy rejestr do którego zapisywane są dane z magistrali w oparciu o sygnał RD i Clock.
			</p>
		</section>
		<section>
			<h4>Magistrala szeregowa</h4>
			<img src="img/magistrala_szeregowa.svg" class="right_img" style="height:330px;" alt="przykład realizacji magistrali szeregowej simplex" />
			<p>
				W magistrali szeregowej dane przesyłane są bit po bicie w pojedynczej linii. Podobnie jak w magistrali równoległej oprócz linii danych mogą występować także linie sterujące. Prostą realizację magistrali szeregowej zapewniają rejestry przesuwne.
			</p>
			<p>
				Przykładowy układ realizacji magistrali simplex (jednokierunkowej) z rozdzielonymi szynami danych i adresową został na schemacie zamieszczonym obok.<br />
				W prezentowanym przykładzie oprócz adresu master wystawia trzy sygnały - dane, zegar i strobe. Z każdym taktem zegara na linii danych wystawiany jest kolejny bit który jest wczytywany do zespołu rejestrów. Sygnał strobe służy do przepisania wartości z rejestrów przesuwnych do rejestrów wyjściowych, takie rozwiązanie zapobiega zmianom wyjść w trakcie przesyłania nowych danych poprzez szynę szeregową, jest ono jednak opcjonalne.
			</p>
			<p>
				W zależności od konstrukcji dekodera adresu szyna adresowa może być równoległa (w najprostszym przypadku - przez całą transmisję do danego urządzenia jego adres musi być wystawiony na szynie a dekoder jest układem bramek NOT i wielowejściowej bramki AND) lub szeregowa (w takim wypadku powinna posiadać własny zegar lub sygnał informujący o nadawaniu adresu z taktami zegara głównego, a dekoder powinien być wyposażony w rejestr przesuwny do odebrania i przechowywania aktualnego adresu z magistrali). Natomiast jeżeli magistrala byłaby oparta tylko na połączonych szeregowo rejestrach (wyjście serial-out do wejścia serial-in) to szyna adresowa nie jest potrzebna, ale konieczne może być każdorazowe wpisanie wszystkich wartości na szynę (czas zapisu rośnie z ilością podłączonych rejestrów).
			</p>
		</section>
		<section>
			<h4>Standardowe interfejsy</h4>
			<p>
				Istnieje wiele zestandaryzowanych interfejsów zarówno szeregowych jak i równoległych, wśród najważniejszych należy wymienić:
				<dl>
					<dt><dfn>SPI</dfn> (Serial Peripheral Interface)</dt>
					<dd>
						jest to szeregowa magistrala full-duplex działająca w układzie master-slave złożona z linii zegarowej (SCLK), nadawania przez mastera (MOSI), odbioru przez mastera (MISO) oraz linii służących do aktywacji urządzenia slave (SS / CS).
					</dd>
					<dt><dfn>I<sup>2</sup>C</dfn> (TWI)</dt>
					<dd>
						jest to szeregowa magistrala half-duplex złożona z linii sygnałowej (SDA) i zegara (SCL) posiadająca zdefiniowany format ramki wraz z adresowaniem. Z wyjątkiem bitu startu i stopu stan linii danych może zmieniać się tylko przy niskim stanie linii zegarowej.
						Nadajniki są typu open-drain przez co realizowany jest iloczyn na drucie, co pozwala na wykrywanie kolizji (jeżeli dany nadajnik nie nadaje zera a linia jest w stanie zera to nadaje także ktoś inny).  Pozwala to także na uzyskanie układów multimaster, pomimo iż typowo na magistrali takiej występuje tylko jeden układ master (nadający sygnał zegara i inicjujący transmisję).
					</dd>
					<dt><dfn>1 wire</dfn> (one-wire)</dt>
					<dd>
						jest to szeregowa magistrala half-duplex złożona z jedynie z linii sygnałowej (która może także służyć do zasilania urządzeń)  posiadająca zdefiniowany format ramki wraz z adresowaniem. Standardowe nadawanie jest realizowane jako open-drain (wyjątkiem jest nadawanie tzw power-byte).
					</dd>
					<dt><dfn>USART</dfn></dt>
					<dd>
						<p>jest to uniwersalny synchroniczny i asynchroniczny nadajnik i odbiornik, umożliwia realizację szeregowej transmisji synchronicznej (zgodnie z zegarem) lub asynchronicznej (wykrywanie początku ramki na podstawie linii danych). Interfejs korzysta z rozdzielonych linii nadajnika i odbiornika (wyjście danych TxD oraz wejście danych RxD, co umożliwia realizację transmisji full-duplex) oraz może korzystać z dodatkowych sygnałów sterujących (wyjście RTS informujące o gotowości do odbioru oraz wejście CTS informacji o gotowości odbioru / zezwolenia na nadawanie). Niekiedy dostępne jest także wyjście załączenia nadajnika używane do pracy w trybie half-duplex (linie TxD i RxD połączone buforem trój-stanowym nadajnika).</p>
						<p>Interfejs ten najczęściej wykorzystywany jest w trybie asynchronicznym jako <dfn>UART</dfn>. W połączeniach UART zarówno nadajnik jak i odbiornik muszą mieć ustawione takie same parametry transmisji (szybkość, znaczenie 9 bitu (typowo bit parzystości, ale może także oznaczać np. pole adresowe), itp).
						Głównymi standardami elektrycznymi dla UART są: poziomy napięć układów elektronicznych używających tych portów (3.3V, 5V), RS-232 (w pełnym wariancie używa sygnałów kontroli przepływu, poziom logiczny 1 wynosi od -15V do -3V, a poziom logiczny 0 od +3V do +15V), RS-422 (transmisja różnicowa full-duplex pomiędzy dwoma urządzeniami) i RS-485 (transmisja różnicowa half-duplex w oparciu o szynę łączącą wiele urządzeń, kompatybilny elektrycznie z RS-422), możliwia jest też transmisja światłowodowa i bezprzewodowa.</p>
					</dd>
					<dt><dfn>CAN</dfn></dt>
					<dd>
						jest to dwu przewodowa magistrala multi-master działająca na zasadzie rozgłoszeniowej, obsługująca 11-to lub 29-bitowe identyfikatory komunikatów (nie są to adresy odbiorców), bazuje na niej wiele protokołów komunikacyjnych (np. CANopen).
					</dd>
					
					<dt><dfn>Ethernet</dfn></dt>
					<dd>
						<p>jest to interfejs szeregowy przeznaczony dla sieci komputerowych, występuje w różnych odmianach od których zależy wykorzystywane medium transmisyjne oraz topologia połączeń. Posiada ustalony format ramki (niezależny od odmiany) wraz z adresacją (ramka zawiera zarówno MAC adres nadawcy, jak i odbiorcy).</p>
						<p>W przypadku połączeń przewodowych (zarówno elektrycznych jak i optycznych) najczęściej stosowane są połączenia punkt-punkt w topologii gwiazdy, można się także spotkać z układem typu ring. Pętle w topologii fizycznej są zabronione i w przypadku ich wystąpienia konieczne jest stosowanie protokołu ich wykrywania i rozłączania (dotyczy to także połączenia typu ring).</p>
						<p>Typowo połączenia fizyczne realizowane są z wykorzystaniem switchy odpowiedzialnych za przesyłanie ramek na odpowiednie porty w oparciu o adresy MAC. W tym celu switch pamięta z którego portu przychodzą ramki z danym adresem źródłowym i tam wysyła ramki z takim adresem docelowym, jeżeli switch nie posiada informacji gdzie wysłać daną ramkę wysyła ją na wszystkie swoje porty.</p>
					</dd>
					
					<dt><dfn>ISA</dfn></dt>
					<dd>
						magistrala równoległa stworzona dla architektury PC (x86), początkowo z 8-bitową szyną danych i niezależną 20 bitową szyną adresową, następnie rozszerzona do 16 bitowej szyny danych i 24 bitowej szyny adresowej, wariancie 16 bitowym taktowana zegarem 8Mhz (wcześniej 4.77Mhz, a następnie 6Mhz).
						<p>
							W skład magistrali wchodzą m.in. następujące sygnały sterujące związane z szyną adresową i szyną danych:<ul>
								<li>ALE - polecenie zatrzaśnięcia adresu / adres poprawny (wystawiane przez CPU)</li>
								<li>IOR / IOW - odczyt / zapis w przestrzeni IO (2 osobne sygnały wystawiane przez CPU)</li>
								<li>MEMR / MEMW - odczyt / zapis w przestrzeni pamięci (2 osobne sygnały, wystawiane przez CPU)</li>
								<li>IO CH RDY - rządanie opóźnienia w obsłudze odczytu / zapisu (wystawiane przez kartę)</li>
								<li>IOCS16 / MEMCS16 - informacja o obsłudze w trybie 16 bitowym (wystawiane przez kartę)</li>
								<li>DRQ*, DACK*, AEN, TC - sygnały DMA</li>
							</ul>
							Ponadto złącze magistrali zapewnia dostęp do 6 (w podstawowej 62 stykowej części złącza) + dodatkowych 5 (w rozszerzającej do 16 bitów 36 stykowej części złącza) linii przerwań IRQ*, sygnału MASTER pozwalającego na przejęcie sterowania nad systemem przez procesor umieszczony na karcie oraz napięć zasilających +12V, -12V, +5V, -5V, kilku linii masy (GND) i zegara systemowego oraz zegara synchronizowanego z zegarem procesora.
						</p><p>
							Magistrala (w innej postaci złącza) obecna jest także w standardzie PC/104.
							Standard <dfn>EISA</dfn> określa rozszerzoną, kompatybilną w dół (także pod względem gniazda), wersję z 32 bitową szyną danych.
						</p>
					</dd>
					<dt><dfn>PCI</dfn></dt>
					<dd><ul>
						<li>magistrala równoległa występująca w odmianie 32 i 64 bitowej, kilka sygnałów związanych z arbitrażem prowadzonych jest do każdego gniazda / urządzenia PCI bezpośrednio z kontrolera magistrali,</li>
						<li>linie przerwań są poprzeplatane między slotami, specyfikacja dopuszcza też przerwania sygnalizowane w ramach komunikatu (przesyłanego szyną danych);</li>
						<li>stosowanie mostków PCI pozwala na rozgałęzianie / łączenie magistrali (zarówno szeregowo jak i równolegle);</li>
						<li>często spotykane są karty PCI o niepełnych wymiarach (prawie zawsze krótsze od maksymalnej dopuszczalnej długości, często także niższe), magistrala PCI jest także spotykana w ramach innych typów złącz - takich jak Mini-PCI, czy PCMCIA</li>
					</ul></dd>
					<dt><dfn>PCI Express</dfn></dt>
					<dd><ul>
						<li>szeregowy interfejs różnicowy full-duplex do połączeń punkt-punkt, w zależności od wariantu złożony z 1, 4, 8 lub 16 zestawów par nadawania i odbioru;</li>
						<li>stosowanie mostków pozwala na rozgałęzianie / łączenie magistrali oraz np. podłączanie klasycznych magistral PCI;</li>
						<li>standardowe złącze zapewnia także m.in. sygnał zegara referencyjnego, resetu, sygnały SMBus (I2C);</li>
						<li>standard występuje na kilku rodzajach złącz (oprócz standardowego) także m.in. miniPCI Express, SATA Express, M.2, Thunderbolt / USB-C.</li>
					</ul></dd>
					
					<dt><dfn>IDE</dfn>, <dfn>ATA</dfn>, <dfn>P-ATA</dfn></dt>
					<dd><ul>
						<li>wywodzący się z magistrali ISA standard służący zapewnieniu komunikacji z urządzeniami pamięci masowej takimi jak dyski twarde, czy napędy optyczne;</li>
						<li>określa także pełny protokół komunikacji z urządzeniami;</li>
						<li>stosowany także (z niewielkimi zmianami) w kartach Compact Flash.</li>
					</ul></dd>
					<dt><dfn>SATA</dfn></dt>
					<dd><ul>
						<li>szeregowy interfejs różnicowy full-duplex do połączeń punkt-punkt, złożony z jednej pary nadawczej, jednej pary odbiorczej oraz linii GND;</li>
						<li>służący do podłączania urządzeń pamięci masowej takich jak dyski twarde, czy napędy optyczne;</li>
						<li>standard SATA określa także pełny protokół komunikacji z urządzeniami;</li>
						<li>standard występuje na kilku rodzajach złącz - oprócz standardowego także m.in. eSATA (zewnętrzne), mSATA, SATA Express, M.2.</li>
					</ul></dd>
					
					<dt><dfn>USB</dfn></dt>
					<dd><ul>
						<li>szeregowy interfejs różnicowy half-duplex do połączeń punkt-punkt posiadający (w wersjach do 2.0 włącznie) jedną parę używana zarówno do nadawania jak i odbioru;</li>
						<li>pozwala na tworzenie topologii gwiazdy z wykorzystaniem hub'ów USB;</li>
						<li>stosuje kilka rodzajów złącz oraz występuje w ramach złącz innych standardów (np. w M.2).</li>
					</ul></dd>
					<dt><dfn>TMDS</dfn>, <dfn>HDMI</dfn>, <dfn>DVI</dfn></dt>
					<dd><ul>
						<li>TMDS jest standardem jednokierunkowej różnicowej transmisji szeregowej, stosowany w interfejsach HDMI i DVI-D;</li>
						<li>korzysta z osobnej pary różnicowej dla każdego koloru składowego RGB (lub YCbCr) oraz osobnej pary dla danych zegarowych;</li>
						<li>pomocniczo (dla dwukierunkowego przekazywania parametrów kontrolnych/sterujących związanych z trybem wyświetlania) wykorzystywany jest także dwuprzewodowy interfejs DDC oparty na I2C;</li>
						<li>dane w kanałach TMDS przesyłane są w postaci (zakodowanych przy pomocy 8b/10b) 10 bitowych ciągów, które mogą być interpretowane jako 8 bitowa wartość koloru, 2 bitowa wartość sterująca (na kanale zerowym wykorzystywane do synchronizacji poziomej i pionowej);</li>
						<li>złącze DVI pozwala na przesyłanie dwóch kanałów cyfrowego wideo (6 kanałów TMDS) oraz przesyłanie analogowego sygnału VGA (RGB, Hsync, Vsync), standard DVI zakłada wykorzystanie łącz TMDS do przesyłania wyłącznie obrazu RGB;</li>
						<li>standard HDMI pozwala na przesyłanie z użyciem TMDS obrazu RGB ablo YCbCr, ponadto standard HDMI korzystając z bitów sterujących transmisji TMDS i kodowania 4b/10 pozwala na przesyłanie poprzez TMDS dźwięku oraz danych sterujących CEC, ponadto złącze HDMI pozwala na przesyłanie (osobną parą) zwrotnego sygnału audio lub sygnału Ethernetowego;</li>
					</ul></dd>
					<dt><dfn>DisplayPort</dfn></dt>
					<dd><ul>
						<li>interfejs złożony z 1 do 4 szybkich jednokierunkowych kanałów różnicowej transmisji pakietowej oraz 1 dwukierunkowego kanału pomocniczego (także z transmisją różnicową)</li>
						<li>wersja "Dual-mode" (DisplayPort++) pozwala na przesyłanie sygnałów zgodnych z HDMI / jednokanałowym DVI-D</li>
						<li>występuje także w złączu Thunderbolt / USB-C</li>
					</ul></dd>
				</dl>
			</p>
		</section>
		<!-- END: Elektronika - Typy transmisji -->
	</section>
	<section>
		<h3>Układy programowalne</h3>
		<p>Układy programowalne można podzielić na dwa rodzaje:
			<dl>
				<dt><dfn>układy o programowalnej strukturze</dfn> (PLD)</dt>
				<dd>
					to układy w których programowany jest układ bramek, przerzutników, itp. "umieszczanych" w kości oraz ich połączeń.
					<p>Program dla takich układów tworzony jest w Hardware Description Language (najczęściej VHDL lub Verilog) i zamiast wykonywanego kodu opisuje strukturę układu logicznego (połączenia bramek, tablice prawdy, etc), która następnie jest programowana w fizycznej kości.</p>
					<p>Najprostszym przykładem układu o programowalnej strukturze logicznej jest układ pamięci 2<sup>n</sup> bitowej z n-bitową szyną adresową adresującą pojedyncze bity - pozwala on na realizację dowolnej funkcji logicznej o n wejściach i pojedynczym wyjściu.</p>
					<p>Do kategorii tej zaliczają się układy typu:<ul>
						<li>SPLD<ul>
							<li>PLE - programowalna matryca bramek OR</li>
							<li>PAL i GAL - programowalna matryca AND z dodatkowymi bramkami OR (często także obudowana rejestrami i multiplekserami na wyjściach)</li>
							<li>PLA - programowalne matryce AND i OR</li>
						</ul></li>
						<li>CPLD</li>
						<li>FPGA - programowalny element pamięciowy (możliwość zdefiniowania dowolnej - na ogół 4 wejściowej - funkcji w każdym elemencie logicznym, programowalne połączenia między elementami logicznymi i pinami, itd)</li>
					</ul></p>
				</dd>
				<dt><dfn>systemy procesorowe</dfn></dt>
				<dd>
					to systemy realizujące ciąg instrukcji pobieranych z jakiejś pamięci.
					<p>System taki składa się z procesora odpowiedzialnego za interpretację i wykonywanie kolejnych instrukcji oraz pamięci z której pobierane są instrukcje i dane (może to być jedna pamięć, mogą to być rozdzielone pamięci). Do kategorii tej zaliczają się zarówno typowe systemy komputerowe, systemy obliczeniowe jak i różnego rodzaju programowalne mikrokontrolery.</p>
					<p>Procesor pracuje w cyklach rozkazowych, w ramach których przetwarza pojedynczą instrukcję. Cykl taki może trwać od 1 do kilku lub więcej cykli zegarowych i typowo składa się z następujących kroków:<ol>
						<li>
							pobranie instrukcji z pamięci - realizowane jest poprzez wystawienie na szynę adresową zawartości <i>licznika programu</i> (zawierające adres instrukcji do wykonania) oraz wygenerowanie cyklu odczytu z pamięci, po wykonaniu odczytu danych następuje ich zapamiętanie w <i>rejestrze instrukcji</i> oraz zwiększenie wartości <i>licznika programu</i> o jeden;<br/>
							(zawartość rejestru <i>licznika programu</i> po resecie procesora określa skąd pobierana będzie pierwsza instrukcja, pod takim adresem zazwyczaj umieszczana jest jakaś pamięć typu ROM lub flash)
						</li>
						<li>dekodowanie instrukcji - układ dekodera (np. oparty o PLA) dokonuje zdekodowania instrukcji znajdującej się w <i>rejestrze instrukcji</i> i konfiguracji procesora w zależności od jej kodu i (opcjonalnie) jej argumentów; może to być np.:<ul>
							<li>odpowiednie ustawienie multiplekserów pomiędzy rejestrami a jednostką ALU oraz wystawienie odpowiedniego kod operacji dla ALU (celem wykonania operacji arytmetycznej na wartościach rejestrów)</li>
							<li>wystawienie zawartości wskazanego rejestru na szynę adresową, podłączenie wskazanego rejestru do szyny danych oraz skonfigurowanie operacji odczytu/zapisu (celem wykonania odczytu lub zapisu wartości rejestru z/do pamięci)</li>
						</ul></li>
						<li>wykonanie instrukcji - realizacja wcześniej zdekodowanej instrukcji zgodnie z ustawioną konfiguracją procesora</li>
					</ol>
					Instrukcje skoku polegają na załadowaniu nowej wartości do <i>licznika programu</i>, w przypadku skoków warunkowych jest to uzależnione od stanu <i>rejestru flag</i>, które ustawiane są w oparciu o wynik ostatniej operacji wykonywanej przez ALU.<br /> 
					Przedstawiony model działania jest przykładowym i w rzeczywistym procesorze może to wyglądać odmiennie - np. długość instrukcji może być większa niż długość słowa używanego przez procesor / szerokość szyny danych co rozbudowuje fazę pobierania instrukcji z pamięci, mogą występować instrukcje bardziej złożone (np. operacje wykonywane z argumentem pobieranym z pamięci a nie rejestru), może także występować więcej faz (np. poprzez wydzielenie faz dostępu do pamięci, czy zapisywania wyników działania instrukcji).
					Procesor może także działać potokowo, czyli nakładać na siebie kolejne fazy wykonywania różnych instrukcji (np. w czasie wykonywania jednej instrukcji realizować pobieranie kolejnej).</p>
				</dd>
			</dl>
		</p>
		<section>
			<h4>Mikrokontrolery</h4>
			<p>Mikrokontroler jest układem typu "System on Chip" zawierającym w jednym układzie procesor, pamięć RAM, układy wejścia-wyjścia (np. GPIO, porty szeregowe typu USART, SPI, I2C, przetworniki ADC), pamięć typu Flash (dla programu).</p>
			<p class="examples">
				ATmega8A (ADC (6-8ch), 3xTimer, I2C, USART, SPI, 28-32pin, 8kB Flash, 1kB RAM, 8bit, 16MHz),
				STM32F072V8 (1xADC (12ch), 1xDAC (2ch), 12xTimer, 2xI2C, 4xUSART, 2xSPI, CAN, USB, 100pin, 64kB Flash, 16kB RAM, 32bit, 48MHz),
				STM32F103VC (3xADC (21ch), 2xDAC, 11xTimer, 2xI2C, 5xUSART, 3xSPI, CAN, USB, 100pin, 256kB Flash, 48kB RAM, 32bit, 72MHz)
				i wiele innych
			</p>
		</section>
		<!-- TODO: więcej o architekturach komputerów -->
	</section>
</section>

<section>
	<h2>Programowanie</h2>
	
	<p>Zagadnienia są ilustrowane przykładowymi kodami w jednym lub kilku z pośród następujących języków: C++ (niekiedy z podziałem na podejście w stylu C i w stylu C++), Python, Bash, PHP i JavaScript. Wybór takiego zbioru języków wynika z odmiennych cech każdego z nich:<ul>
		<li>C++ / C są najpopularniejszymi językami kompilowanymi do kodu maszynowego (a jeżeli traktować je łącznie to najpopularniejszymi językami w ogóle), pozwalają na stosowanie niskopoziomowych mechanizmów (łącznie z wstawkami asemblerowymi), są użyteczne do bezpośredniego programowania sprzętu (bez warstwy systemu operacyjnego) czy też tworzenia systemów operacyjnych</li>
		<li>Python - najpopularniejszy język skryptowy, wygodny (w miarę łatwy / szybki) w pisaniu i nauce, oferuje bardzo wiele gotowych bibliotek, pozwala na dość prostą integrację z kodem C/C++</li>
		<li>Bash - najpopularniejsza powłoka tekstowa, stanowiąca jednocześnie (specyficzny) język programowania</li>
		<li>PHP - popularny i wygodny język do tworzenia serwisów www</li>
		<li>JavaScript - najpopularniejszy język skryptowy dla WWW, element HTML5</li>
	</ul>Ponadto każdy z tych języków wykorzystywany jest w wielu projektach (od jądra Linuxa do systemu MediaWiki) i ich przynajmniej zgrubna znajomość może okazać się przydatna.</p>
	
	<p>Język C++ oraz C są językami kompilowalnymi to znaczy (po zmodyfikowaniu źródeł) przed uruchomieniem programu konieczne jest dokonanie tłumaczenia kodu źródłowego na kod maszynowy przy pomocy odpowiedniego programu (np. <code>clang++</code> lub <code>g++</code>). Kompilacja C i C++ przebiega kilku etapowo. W pierwszej kolejności wywoływany jest preprocesor, który jest odpowiedzialny za włączanie plików określonych poprzez <code>#include</code> (jest to literalne włączenie zawartości wskazanego pliku w danym miejscu, obsługę rozwijania stałych makr preprocesora (definiowanych z użyciem <code>#define</code>) oraz kompilację warunkową z wykorzystaniem poleceń takich jak <code>#ifdef</code> czy <code>#if</code>. Kompilatory pozwalają na uzyskanie nie tylko wynikowego pliku binarnego, ale także plików po przetworzeniu przez preprocesor czy też po konwersji na assembler.</p>
	<p>Python, Bash i PHP są językami interpretowanymi, czyli uruchamianiu podlega bezpośrednio kod źródłowy który jest analizowany i wykonywany przez interpreter danego języka. Mogą one uruchamiać kod z podanego pliku lub interaktywnie wprowadzany w konsoli interpretera. Kod wprowadzany interaktywnie może być wykonywany bezpośrednio po jego wprowadzeniu (tzn. wprowadzeniu znaku nowej linii, a w przypadku bloków instrukcji - zakończenia takiego bloku). W Bashu i Pythonie jest to zachowanie domyślne, natomiast w przypadku PHP wymaga podania opcji <code>-a</code> (jej podanie zakłada że podawany kod jest tylko częścią ujętą w <code>&lt;?php</code> i <code>?&gt;</code>, bez tej opcji kod zostanie zinterpretowany i wykonany dopiero po wczytaniu znaku końca pliku, który można wprowadzić Ctrl+D).</p>
	<p>Zarówno kompilatory jak i interpretery mogą generować błędy lub ostrzeżenia dotyczące przetwarzanego kodu, przy jego poprawianiu ważne jest ich czytanie z próbą zrozumienia (niekiedy potrafią być dziwne i odnosić się nie do tego co jest przyczyną problemu). Rozwiązując problem należy skupić się na pierwszym błędzie, gdyż kolejne mogą być jego wynikiem (jest to szczególnie ważne w przypadku kompilacji C++ / C, gdzie możemy uzyskać bardzo wiele błędów). Programy mogą także generować błędy typu "run time error" w trakcie działania, przykładami takich błędów są rzucane i nie obsługiwane wyjątki oraz błędy związane z odwołaniami do pamięci (np. przekroczeniem zakresu tablicy w C) komunikowane zazwyczaj jako "Segmentation fault".</p>
	<section>
		<h3>Pamięć danych - zmienne</h3>
		<p>
			Wszelkie dane na których operuje program komputerowy przechowywane są w jakimś rodzaju pamięci - najczęściej jest to pamięć operacyjna. W pewnych sytuacjach niektóre dane mogą być przechowywane np. tylko w rejestrach procesora lub rejestrach urządzeń wejścia-wyjścia.
		</p>
		<p>
			W programowaniu na poziomie wyższym od kodu maszynowego i asemblera używa się pojęcia zmiennej i (niemal zawsze) pozostawia kompilatorowi/interpretatorowi decyzję o tym gdzie ona jest przechowywana. Oczywistym wyjątkiem są grupy zmiennych, czy też bufory alokowane w sposób jawny w pamięci.
			Ze względu na ograniczoną liczbę rejestrów procesora większość zmiennych (w szczególności tych dłużej istniejących i większych) będzie znajdowała się w pamięci i będą przenoszone do rejestrów celem wykonania jakiś operacji na nich po czym wynik będzie przenoszony do pamięci.
		</p>
		<p>
			Z każdą zmienną przechowywaną w pamięci związany jest adres pamięci pod którym się ona znajduje. Niektóre z języków programowania pozwalają na odwoływanie się do niego poprzez wskaźnik na zmienną lub referencję do zmiennej (odwołania do adresu zmiennej mogą wymusić umieszczenie jej w pamięci nawet gdyby normalnie znajdowała się tylko w rejestrze procesora).
		</p>
		<p>
			Wszystkie dane są zapisywane w postaci liczb lub ciągów liczb. Typ zmiennej (jawny lub nie) informuje o tym jakiej długości jest dana liczba i jak należy ją interpretować (jak należy interpretować ciąg liczb).
		</p>
		
		<div class="demo_codes"><div>
			<insertSourceCode file="code-src/podstawy/Pamięć_danych_-_zmienne.cpp" />
			<insertSourceCode file="code-src/podstawy/Pamięć_danych_-_zmienne.py" />
			<insertSourceCode file="code-src/podstawy/Pamięć_danych_-_zmienne.sh" />
			<insertSourceCode file="code-src/podstawy/Pamięć_danych_-_zmienne.php" />
			<insertSourceCode file="code-src/podstawy/Pamięć_danych_-_zmienne.js" />
		</div></div>
	</section>
	
	<section>
		<h3>Kod programu - instrukcje, ...</h3>
		<p>
			Program komputerowy składa się z instrukcji wykonywanych kolejno przez procesor. Instrukcje te można podzielić na:
			<ul>
				<li>instrukcje przenoszenia danych (m.in. pomiędzy pamięcią i rejestrami procesora),</li>
				<li>instrukcje modyfikujące dane (wykonujące na nich jakieś operacje arytmetyczne, logiczne itp.),</li>
				<li>instrukcję modyfikujące sterowanie w programie.</li>
			</ul>
			Dwie pierwsze kategorie instrukcji odpowiadają za modyfikowanie wartości zmiennej na skutek przypisań wartości oraz operacji wykonywanych na zmiennych.
			Trzecia kategoria to instrukcje odpowiedzialne za warunkowe lub bez warunkowe modyfikowanie licznik programu.
			Mogą występować także instrukcje złożone realizujące zadania z różnych grup w ramach jednej instrukcji (np. instrukcje wykonywane warunkowo).
		</p>
		
		<section>
			<h4>Podstawowe operacje arytmetyczne, bitowe i logiczne</h4>
			<p>
				Z punktu widzenia procesora (kodu maszynowego) podstawowymi operacjami wykonywanymi na danych (oprócz przenoszenia) są typowe operacje arytmetyczne i logiczne oraz operacje binarne. Wiele architektur posiada także bardziej złożone instrukcje (np. wykonywane nie na pojedynczych liczba a całych wektorach liczb lub też wykonujących jakąś bardziej złożoną operację matematyczną w sposób sprzętowy), które odgrywają istotną rolę w optymalizacji kodu na daną architekturę.
			</p>
			<p>
				Z punktu widzenia języków programowania najczęściej za podstawowe operacje uważa się:<ul>
					<li>operacje arytmetyczne: dodawanie, odejmowanie, mnożenie, dzielenie całkowite, dzielenie zmiennoprzecinkowe, obliczanie reszty z dzielenia, niekiedy podnoszenie do potęgi</li>
					<li>operacje logiczne: AND, OR, NOT, niekiedy XOR, porównania (równość, nierówność, większe, mniejsze, większe równe, mniejsze równe)</li>
					<li>operacje bitowe(wykonywane niezależnie na każdym bicie argumentów): AND, OR, NOT, XOR, przesunięcia bitowe</li>
				</ul>
				Dość istotnym wyjątkiem są niektóre języki skryptowe (takie jak bash), których głównym zadaniem jest uruchamianie innych programów i to jest operacją podstawową w tych językach.</p>
			
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/podstawy/Podstawowe_operacje_arytmetyczne_bitowe_i_logiczne.cpp" />
				<insertSourceCode file="code-src/podstawy/Podstawowe_operacje_arytmetyczne_bitowe_i_logiczne.py" />
				<insertSourceCode file="code-src/podstawy/Podstawowe_operacje_arytmetyczne_bitowe_i_logiczne.sh" />
				<insertSourceCode file="code-src/podstawy/Podstawowe_operacje_arytmetyczne_bitowe_i_logiczne.js" />
			</div></div>
		</section>
		
		<section>
			<h4>Przepływ sterowania w programie - skoki, warunki, pętle, funkcje</h4>
			<p>
				<dfn>Licznik programu</dfn> (program counter, instruction pointer lub instruction address register) jest rejestrem procesora który określa adres następnej (w niektórych architekturach aktualnej) instrukcji która ma zostać przetworzona procesor.
			</p>
			
			<p>Skoki bezwarunkowe, instrukcje warunkowe, pętle, wywołania funkcji są realizowane poprzez modyfikację licznika programu. W przypadku wywołań funkcji dodatkowo wykonywane są operacje związane z obsługą stosu (zachowywaniem stanu rejestrów, umieszczaniem argumentów na stosie, ...). Instrukcja <code>goto</code> (realizująca skok bezwarunkowy) jest pełnoprawną instrukcją skoku, jedyną wadą jej stosowania jest to że przy niewłaściwym / zbyt częstym wykorzystywaniu (zamiast wywołań funkcji, warunków i pętli) kod programu staje się mniej czytelny.</p>
			
			<p>W większości przypadków pętle realizowane są na poziomie kodu maszynowego jako zestaw instrukcji (np. inkrementacji zmiennej, sprawdzania warunku, skoku), jednak w niektórych rozwiązaniach pętle (np. typu "powtórz n razy") mogą być realizowane sprzętowo przy pomocy pojedynczej instrukcji.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/podstawy/Skoki_warunki_pętle_funkcje.cpp" />
				<insertSourceCode file="code-src/podstawy/Skoki_warunki_pętle_funkcje.py" />
				<insertSourceCode file="code-src/podstawy/Skoki_warunki_pętle_funkcje.sh" />
				<insertSourceCode file="code-src/podstawy/Skoki_warunki_pętle_funkcje.php" />
				<insertSourceCode file="code-src/podstawy/Skoki_warunki_pętle_funkcje.js" />
			</div></div>
			<p>
				Typowo funkcja przyjmuje określoną ilość argumentów (może ich nie posiadać) i zwraca pojedynczą wartość. Istnieje możliwość zwracania przez funkcję struktury złożonej z kilku wartości, jednak na ogół odebranie z funkcji dodatkowych wyników działania odbywa się poprzez argument typu wskaźnikowego, wskazujący na zmienną w której mają zostać zapisane. Wiele języków pozwala także na definiowanie funkcji przyjmujących dowolną ilość argumentów.
				</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/podstawy/Funkcje_dowolną_ilością_argumentów.cpp" />
				<insertSourceCode file="code-src/podstawy/Funkcje_dowolną_ilością_argumentów.py" />
				<insertSourceCode file="code-src/podstawy/Funkcje_dowolną_ilością_argumentów.sh" />
				<insertSourceCode file="code-src/podstawy/Funkcje_dowolną_ilością_argumentów.php" />
				<insertSourceCode file="code-src/podstawy/Funkcje_dowolną_ilością_argumentów.js" />
			</div></div>
			<section>
				<h5>Punkt startu</h5>
				<p>
					Jako że program komputerowy jest sekwencją wykonywanych instrukcji musi rozpoczynać się od określonego miejsca.<br />
					W przypadku języków interpretowanych jest to na ogół początek pliku z kodem programu. Często w pierwszej linii znajduje się specjalny komentarz (postaci <code>#!/ścieżka/do/programu</code>) stanowiący informację dla programu uruchamiającego skrypt jakiego interpretera ma użyć w celu wykonania kodu zawartego w pliku (niekiedy zawiera też opcje z jakimi należy uruchomić interpreter).<br />
					Natomiast w przypadku skompilowanego kodu C/C++ punktem startu jest funkcja <code>main</code>. Zakończenie tej funkcji oznacza zakończenie programu, a wartość przez nią zwracana odpowiedzialna jest za tzw. kod powrotu przekazany procesowi wywołującemu program.
				</p>
			</section>
			<section>
				<h5>Rekurencja</h5>
				<p>Rekurencja jest mechanizmem, polegającym na wywoływaniu funkcji przez samą siebie, który ma na celu implementację niektórych algorytmów. Może być zastosowana chyba w każdym języku pozwalającym na definiowanie funkcji. Ograniczeniem jest maksymalna ilość wywołań funkcji związana z wielkością stosu - w przypadku zbyt wielu wywołań kolejnych funkcji program zakończy się błędem. Każdy algorytm zapisywany rekurencyjnie może zostać zamieniony na algorytm iteracyjny (wykorzystujący pętle).</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/podstawy/Rekurencja-Iteracja-1.py" />
					<insertSourceCode file="code-src/podstawy/Rekurencja-Iteracja-2.py" />
				</div></div>
			</section>
		</section>
	</section>
	
	<section>
		<h3>Więcej o (bardziej złożonych) zmiennych</h3>
		<section>
			<h4>Grupowanie zmiennych</h4>
			<section>
				<h5>Struktury i klasy</h5>
				<p>
					<dfn>Struktura</dfn> jest złożonym typem danych służącym do grupowania powiązanych ze sobą logicznie zmiennych. Zmienne wchodzące w skład struktury (<dfn>pola</dfn>) identyfikowane są nazwami i mogą być różnych typów. Struktura zajmuje ciągły obszar pamięci, w którym umieszczane są wartości kolejnych pól.
				</p>
				<p>
					<dfn>Klasa</dfn> oprócz pól może zawierać także funkcje (metody) - zarówno operujące na tych polach jak i z nimi nie powiązane. W niektórych przypadkach także struktury mogą zawierać metody - np. w C++ nie ma silnego rozróżnienia pomiędzy strukturami a klasami (różnią się tylko domyślną widocznością pól i metod).
				</p>
				<p>
					Zmienne których typem jest jakaś klasa często określa się jako <dfn>obiekt</dfn> danej klasy. Niekiedy mówi się także o instancji danej klasy (reprezentowanej przez zmienną).
				</p>
				<p>
					Niektóre z języków pozwalają na definiowanie w ramach struktury lub klasy pól i/lub metod <dfn>statycznych</dfn>, które nie są powiązane z żadnym istniejącym egzemplarzem danej struktury czy klasy - są wspólne dla wszystkich i można się do nich odwoływać bez istnienia obiektu.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Struktury_i_klasy.cpp" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Struktury_i_klasy.py" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Struktury_i_klasy.php" />
				</div></div>
				<p>
					Metody wchodzące w skład struktury oraz pola statyczne nie wpływają na rozmiar obiektów których jest typem.
				</p>
			</section>
			<section>
				<h5>Tablice</h5>
				<p>
					Tablica jest strukturą danych w której elementy (takiego samego typu) są ułożone w porządku liniowym i są dostępne za pomocą indeksów (kluczy). Typowo tablica indeksowana jest liczbami całkowitymi nie ujemnymi oraz zajmuje ciągły obszar pamięci.<br />
					Dostęp do elementów tablicy odbywa się w oparciu o obliczanie ich adresu na podstawie zależności: AdresElementu = AdresPoczatkuTablicy + IndexElementu * RozmiarElementu.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice.cpp" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice.sh" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice.js" />
				</div></div>
			</section>
			<section>
				<h5>Listy</h5>
				<p>
					Lista jest strukturą danych w której elementy są ułożone w porządku liniowym na zasadzie poprzedni-następny. Wyróżnia listy:
					<dl>
						<dt><dfn>jednokierunkowe</dfn></dt>
						<dd>w których w oparciu o element listy można uzyskać tylko element następny lub ustalić że jest ostatni - można przemieszczać się po takiej liście tylko w jednym kierunku</dd>
						
						<dt><dfn>dwukierunkowe</dfn></dt>
						<dd>w których w oparciu o element listy można uzyskać następny i poprzedni, lub ustalić że jest pierwszym lub ostatnim - umożliwia to przemieszczanie się po elementach listy w obu kierunkach</dd>
						
						<dt><dfn>cykliczne</dfn></dt>
						<dd>(zarówno jedno i dwukierunkowe) w których ostatni element wskazuje jako następny pierwszy element, a (w przypadku dwukierunkowych) pierwszy element wskazuje ostatni jako swojego poprzednika</dd>
					</dl>
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Listy.cpp" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Listy.py" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Iteratory_generatory.py" />
				</div></div>
				<p>
					Listy umożliwiają łatwą implementację m.in.:
					<dl>
						<dt>kolejki typu <dfn>FIFO</dfn> (First In First Out)</dt>
						<dd>poprzez dodawanie elementów na koniec listy, a pobieranie z początku listy</dd>
						<dt>stosu, czyli kolejki typu <dfn>LIFO</dfn> (Last In First Out)</dt>
						<dd>poprzez dodawanie elementów na koniec listy i pobieranie także z końca listy</dd>
					</dl>
				</p>
				<p>
					Listy nie muszą zajmować ciągłego obszaru pamięci - każdy z elementów może być alokowany osobno i tylko zawierać wskaźniki na następny i ew. poprzedni element.
					Utrudnia (wydłuża) to dostęp do n-tego elementu listy, ale usprawnia dodawanie i usuwanie elementów (zarówno z początku, środka jak i końca listy).
				</p>
			</section>
			<section>
				<h5>Tablice asocjacyjna (mapy)</h5>
				<p>
					Tablica asocjacyjna (nazywana także mapą lub słownikiem) podobnie do zwykłej tablicy jest zbiorem par klucz-wartość, z tym że klucze nie muszą tutaj być kolejnymi liczbami całkowitymi zaczynającymi się od zera a mogą być dowolnymi wartościami (napisami, wskaźnikami, etc). Często (np. C++) tablice takie implementowane są jako posortowane drzewa binarne, dzięki czemu dostęp do szukanego elementu realizowany jest w czasie logarytmicznym.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice_asocjacyjna_mapy.cpp" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice_asocjacyjna_mapy.py" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice_asocjacyjna_mapy.php" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych/Tablice_asocjacyjna_mapy.js" />
				</div></div>
				<p>
					W standardowej mapie klucz jest unikalny (tzn. nie mogą występować elementy z takim samym kluczem), zapewnia to jednoznaczność odwołań poprzez operator tablicowy [].
					W C++ jeżeli chcemy mieć kilka jednakowych kluczy z różnymi wartościami można skorzystać <code>std::multimap&lt;&gt;</code>.
				</p>
				<p>
					Strukturami zbliżonymi w działaniu do mapy są <dfn>zbiory</dfn> (<code>std::set&lt;&gt;</code> i <code>std::multiset&lt;&gt;</code> z C++ oraz <code>set([k1, k2, ...])</code> z Pythona). Różnią się one od map tym że nie przechowują one wartości a jedynie same klucze.
				</p>
			</section>
		</section>
		
		<section>
			<h4>Wskaźniki i referencje</h4>
			<p>
				Wskaźnik jest zmienną, która przechowuje adres pamięci, pod którym znajdują się jakieś dane (inna zmienna). Jako że wskaźnik jest zmienną która też jest umieszczona gdzieś w pamięci można utworzyć wskaźnik do wskaźnika itd.
				Na wskaźnikach można wykonywać operacje arytmetyczne (najczęściej jest to dodawanie offsetu). Na wskaźniku można wykonać operację wyłuskania czyli odwołania się do wartości zmiennej pod adresem na który wskazuje, a nie do zmiennej wskaźnikowej (zawierającej adres).
			</p>
			<p>
				Wskaźniki pozwalają na operowanie dużymi zbiorami danych (duże struktury, napisy, etc) bez konieczności ich kopiowania przy przekazywaniu do funkcji, umieszczaniu w różnych strukturach danych, sortowaniu, itd (kopiowaniu ulega jedynie wskaźnik czyli adres) oraz na współdzielenie tych samych danych pomiędzy różnymi obiektami.
			</p>
			<p>
				Wskaźnik może wskazywać na niewłaściwy adres w pamięci (np. na skutek zwolnienia tego fragmentu lub błędu w operacjach matematycznych na wskaźnikach - wyjściu poza dozwolony zakres), typowo wskaźnikowi który nic nie wskazuje przypisuje się wartość NULL (zero).
				Wyłuskania wskaźników o wartości NULL lub wskazujących niewłaściwy obszar pamięci prowadzą do błędów programu, często do zakończenia programu z powodu naruszenia ochrony pamięci ("Segmentation fault").
			</p>
			<p>
				Referencja jest zbliżona do wskaźników (w zasadzie jest to wskaźnik trochę inaczej traktowany przez kompilator) - także pozwala na unikanie kopiowania dużych danych. W odróżnieniu od wskaźnika odwołania do referencji zawsze skutkują wyłuskaniem, nie jest możliwa arytmetyka wskaźnikowa na referencjach, referencja musi też wskazywać na poprawny obszar pamięci (minimalizacja ryzyka błędu odwołania do niewłaściwego adresu). Możliwa jest referencja na wskaźnik a także wskaźnik do referencji.
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Wskaźniki_i_referencje.cpp" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Wskaźniki_i_referencje.py" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Wskaźniki_i_referencje.sh" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Wskaźniki_i_referencje.php" />
			</div></div>
		</section>
		
		<section>
			<h4>Zasięg zmiennej</h4>
			<p>
				Często (np. C / C++) zasięg zmiennych (widoczność i istnienie) jest limitowany do bloku w którym zostały zadeklarowane, zmienne z bloków wewnętrznych mogą przesłaniać zmienne zadeklarowane wcześniej.
				W niektórych językach (np. Pythonie, Bash'u) mechanizm ten nie jest stosowany (utworzenie zmiennej wewnątrz if'a lub pętli powoduje jej widoczność poza tym blokiem).
			</p>
			<p>
				Wywołanie funkcji powoduje rozpoczęcie nowego kontekstu w którym zmienne z bloku wywołującego funkcję nie są widoczne (ale nadal istnieją). Typowo argumenty do funkcji przekazywane są przez kopiowanie, więc funkcja nie ma możliwości modyfikacji zmiennych z bloku ją wywołującego nawet do niej przekazanych (wyjątkiem jest przekazanie przez referencję lub wskaźnik).
			</p>
			<p>
				W przypadku manualnej alokacji pamięci lub tworzenia obiektów poprzez <code>new</code> limitowana jest widoczność i istnienie otrzymanego wskaźnika, ale nie zaalokowanego bloku pamięci. Zatem ograniczona jest widoczność takich zmiennych ale nie czas ich istnienia, dlatego też przed utratą wskaźnika na nie należy je usunąć (zwolnić zaalokowaną pamięć).
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Zasięg_zmiennej.cpp" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych/Zasięg_zmiennej.py" />
			</div></div>
		</section>
		
		<section>
			<h4>Napisy</h4>
			<p>
				Napisy są to ciągi liczb, w których kolejne liczby (pojedynczo lub grupami) interpretowane są jako kolejne znaki (litery).
				W przypadku kodowań o ustalonej długości znaku (np. UTF-32, ASCI) każda n-bitowa liczba odpowiada jednemu znakowi napisu (przy czym i tak mogą się one graficznie nakładać, ale każdy jest integralną całością).
				W przypadku kodowań o zmiennej długości znaku długość znaku kodowana jest w ramach tego znaku (np. w UTF-8 długość wynosi od 1 do 4 bajtów, informacja o długości zakodowana jest w pierwszym bajcie, a dodatkowe bajty mają ustawione najstarsze bity na 10 co jednoznacznie identyfikuje je jako uzupełniające).
			</p>
			<p>
				Mogą one być przechowywane jako tablica lub lista tablic (ułatwia to operowanie dużymi zmiennymi napisowymi - unikanie relokacji i przepisywania dużej ilości danych).
				Możliwe jest kilka sposobów przechowywania napisu w tablicy różniących się metodą uzyskiwania informacji o końcu napisu - może to być osobna zmienna przechowująca długość napisu (lub adres jego końca) albo znacznik końca przechowywany w samym napisie (w tej roli stosowane jest 0 w tzw. NULL-end stringach z języka C).
			</p>
			<p>
				W przetwarzaniu napisów bardzo często stosowane są wyrażenia regularne służące do dopasowywania napisów do wzorca który opisują, wyszukiwaniu/zastępowaniu tego wzorca. Do typowej, podstawowej składni wyrażeń regularnych zalicza się m.in. następujące operatory:
			</p><pre>.      - dowolny znak
[a-z]  - znak z zakresu
[^a-z] - znak z poza zakresu (aby mieć zakres z ^ należy dać go nie na początku)
^      - początek napisu/linii
$      - koniec napisu/linii

*      - dowolna ilość powtórzeń
?      - 0 lub jedno powtórzenie
+      - jedno lub więcej powtórzeń
{n,m}  - od n do m powtórzeń

()     - pod-wyrażenie (może być używane dla operatorów powtórzeń, a także dla referencji wstecznych)
</pre>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy.cpp" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy.py" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy.php" />
			</div><br /><div>
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy-wbudowane.sh" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy-komendy.sh" />
				<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/Napisy.js" />
			</div></div>
			<section>
				<h5>XML</h5>
				<p>Extensible Markup Language (XML) jest tekstowym formatem wymiany danych. W odróżnieniu od formatu klasycznego formatu utożsamiającego linię z rekordem złożonym z pól oddzielanych wskazanym separatorem może on w łatwy sposób opisywać bardziej złożoną (drzewiastą a nie tabelkową) postać danych.
					Dokument XML składa się z zagnieżdżonych w sobie znaczników, każdy z nich może posiadać atrybuty oraz wartość, którą jest tekst zawierający lub nie kolejne znaczniki. Kolejność występowania elementów w dokumencie jest znacząca.
					Każdy znacznik otwierający posiada odpowiadający mu znacznik zamykający (np. <code>&lt;b&gt;aa&lt;/b&gt;</code>), znaczniki bez wartości mogą być samo-zamykające (np. <code>&lt;g /&gt;</code>).
					Dokumenty HTML mogą być zgodne z wymogami formalnymi XML tym samym stanowiąc dokumenty XML.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/XML.cpp" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/XML.py" />
				</div><br/><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/XML.xml" />
				</div></div>
			</section>
			<section>
				<h5>JSON</h5>
				<p>JavaScript Object Notation (JSON) jest tekstowym formatem wymiany danych. Podobnie jak XML reprezentuje on drzewiasta strukturę, jednak w odróżnieniu od XML kolejność elementów w danych wejściowych nie zawsze przekłada się na kolejność w danych zinterpretowanych. Wiąże się to z tym iż wyróżnia się dwa typu elementów.
					Pierwszy z nich obejmowany w nawiasy klamrowe i składa się z par klucz-wartość, jest on interpretowany jako słownik / tablica asocjacyjna i w jego wypadku identyfikacja elementu odbywa się wyłącznie po kluczu (który musi być unikalny), a kolejność nie ma znaczenia.
					Drugi jest obejmowany w nawiasy kwadratowe i składa się wyłącznie z kolejnych wartości, jest on interpretowany jako zwykła tablica lub lista.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/JSON.py" />
				</div></div>
			</section>
			<section>
				<h5>wykonywanie napisu</h5>
				<p>Często wygodnie jest mieć możliwość wykonania kawałka kodu danego języka, który jest zapisany w zmiennej napisowej. Większość języków skryptowych pozwala to zrobić. Jako że funkcje te pozwalają na wykonywanie dowolnego kodu to szczególną ostrożność należy zachować przekazując do nich dane wprowadzane przez użytkownika.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/wykonywanie_napisu.py" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/wykonywanie_napisu.sh" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/wykonywanie_napisu.php" />
					<insertSourceCode file="code-src/zmienne_i_struktury_danych--napisy/wykonywanie_napisu.js" />
				</div></div>
			</section>
		</section>
	</section>
	
	<section>
		<h3>Podstawowe I/O</h3>
		<section>
			<h4>Standardowe wejście / wyjście</h4>
			<p>Typowo program posiada trzy strumienie danych: jednen wejściowy (stdin) i dwa wyjściowe (stdout i stderr). Jeżeli nie zostało dokonane przekierowanie strumieni (np. na plik lub strumień innego procesu) to standardowe wejście (stdin) powiązane jest z danymi wprowadzanymi interaktywnie z klawiatury, a standardowe wyjście (stdout) i standardowe wyjście błędu (stderr) z danymi wyświetlanymi na terminalu na którym uruchomiono program (i typowo później wyświetlanymi gdzieś na ekranie).</p>
			
			<p>Standardowe wejście i wyjście może być wykorzystywane do:<ul>
				<li>przekazywania między programami kolejnych etapów przetwarzania jakiegoś zbioru danych (zwykle tekstowego): np. <code>grep in.txt | sort &gt; out.txt</code> (grep wybiera linie spełniające kryteria, a sort sortuje wynik)</li>
				<li>interaktywnej obsługi programu: program pyta o kolejne parametry i pobiera je z standardowego wyjścia (podejście należy stosować z rozwagą gdyż takie programy ciężko używa się w skryptach - lepszym rozwiązaniem jest przyjmowanie parametrów z linii poleceń)</li>
			</ul></p>
		<div class="demo_codes"><div>
			<insertSourceCode file="code-src/podstawowe_io/Standardowe_wejście__wyjście--c.cpp" />
			<insertSourceCode file="code-src/podstawowe_io/Standardowe_wejście__wyjście--cpp.cpp" />
			<insertSourceCode file="code-src/podstawowe_io/Standardowe_wejście__wyjście.py" />
		</div><br /><div>
			<insertSourceCode file="code-src/podstawowe_io/Standardowe_wejście__wyjście.sh" />
			<insertSourceCode file="code-src/podstawowe_io/Standardowe_wejście__wyjście.php" />
		</div></div>
		</section>
		<section>
			<h4>Obsługa plików</h4>
			<p>Zasadniczo obsługa plików pod względem operacji wykonywanych pomiędzy otwarciem a zamknięciem pliku niewiele różni się od obsługi standardowego/wejścia i wyjścia. W zdecydowanej większości (jeżeli nawet nie we wszystkich) języków interfejs obsługi standardowego wejścia i wyjścia jest zunifikowany z interfejsem obsługi plików.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/podstawowe_io/Obsługa_plików--c.cpp" />
				<insertSourceCode file="code-src/podstawowe_io/Obsługa_plików--cpp.cpp" />
				<insertSourceCode file="code-src/podstawowe_io/Obsługa_plików.py" />
			</div></div>
			<section>
				<h5>Mapowanie plików w pamięci</h5>
				<p>Możliwe jest także operowanie na plikach zmapowanych do pamięci z użyciem mmap, operacje wykonywane są wtedy na ich zawartości tak jak na tablicach / napisach C.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/podstawowe_io/Mapowanie_plików_w_pamięci.cpp" />
				</div></div>
			</section>
			<section>
				<h5>Operacje na plikach</h5>
				<p>Często oprócz zapisywania i czytania plików zachodzi potrzeba sprawdzenia czy plik istnieje, wylistowania plików z jakiegoś katalogu, zmiany nazwy lub usunięcia pliku. Stosowne funkcje oferuje biblioteka standardowa C (w oparciu o nie realizowane są komendy shellowe wykonujące takie operacje), a także większość innych języków. W przypadku C++ można korzystać z biblioteki standardowej C lub biblioteki boost (jak w poniższym przykładzie).</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/podstawowe_io/Operacje_na_plikach.cpp" />
					<insertSourceCode file="code-src/podstawowe_io/Operacje_na_plikach.py" />
					<insertSourceCode file="code-src/podstawowe_io/Operacje_na_plikach.sh" />
				</div></div>
			</section>
		</section>
		<section>
			<h4>Argumenty linii poleceń</h4>
			<p>
				System pozwala na przekazanie do uruchamianego programu zbioru argumentów / opcji, które program może dowolnie zinterpretować i wykorzystać w swoim działaniu.
			</p><p>
				Od systemu program otrzymuje nie zinterpretowaną tablicę argumentów. Za podział całego zbioru argumentów, na poszczególne elementy tablicy odpowiada program tworzący nowy proces. Typowo napis przekazany w linii poleceń dzielony jest na słowa (ciągi znaków, rozdzielane białymi znakami) i każde słowo stanowi osobny element tablicy, wyjątkiem są napisy ujęte w cudzysłowia które przekazywane są jako pojedynczy argument (element tablicy).
			</p><p>
				W świecie POSIXowym przyjętym standardem jest podawanie opcji jednoliterowych po pojedynczym myślniku z możliwością ich grupowania (np. <code>ls -la</code> to to samo co <code>ls -l -a</code>), a opcji długich po dwóch myślnikach. Ewentualne argumenty opcji podawane są zaraz po opcji i w przypadku opcji krótkich oddzielone od niej spacją, a w przypadku opcji długich po znakiem równości (np. <code>ls --color=auto</code>). Po opcjach występują argumenty pozycyjne (np. lista plików które ma wyświetlić ls).
			</p><p>
				Obsługę takiego stylu przekazywania opcji do programu (w oparciu o surową tablicę argumentów) zapewniają liczne biblioteki (także standardowe biblioteki różnych języków programowania).
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/podstawowe_io/Argumenty_linii_poleceń.cpp" />
				<insertSourceCode file="code-src/podstawowe_io/Argumenty_linii_poleceń.py" />
				<insertSourceCode file="code-src/podstawowe_io/Argumenty_linii_poleceń.php" />
			</div></div>
		</section>
	</section>
	
	<section>
		<h3>Procesy i wątki</h3>
		<section>
			<h4>Rozgałęzienie procesu - fork()</h4>
			<p>
				Aby w systemie mógł działać więcej niż 1 proces konieczna jest możliwość utworzenia nowego procesu (potomka) z poziomu procesu aktualnie działającego (rodzica). Możliwe są dwa podejścia:<ul>
					<li>utworzenie "czystego" procesu uruchamiającego podany kod programu z podanymi argumentami (spawn)</li>
					<li>utworzenie kopii aktualnego procesu, która zacznie wykonywać się niezależnie od momentu rozgałęzienia (fork)</li>
				</ul>
				W przypadku zastosowania fork proces potomny otrzymuje kopię pamięci rodzica (ma dostęp do wszystkich jego zmiennych oraz zasobów uzyskanych przed fork(); dalsze operacje na zmiennych są niezależne). Po utworzeniu kopi procesu można (ale nie trzeba) zastąpić wykonywany w nim program innym poprzez funkcje z rodziny exec. Cechy te powodują że mechanizm fork jest bardziej elastyczny od spawn.
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/procesy_i_watki/Rozgałęzienie_procesu_-_fork.cpp" />
				<insertSourceCode file="code-src/procesy_i_watki/Rozgałęzienie_procesu_-_fork.py" />
			</div></div>
		</section>
		<section>
			<h4>Komunikacja międzyprocesowa</h4>
			<p>W systemie wieloprocesowym konieczne jest zapewnienie mechanizmów komunikacji pomiędzy procesami, zwłaszcza jeżeli grupa procesów ma realizować wspólne zadanie.</p>
			<p>Jednym z takich mechanizmów (można powiedzieć że nawet podstawowym) jest pokazane wcześniej łącze nie nazwane (pipe) pozwalające na przekazywanie strumienia danych od jednego do kolejnego procesu. Podobnie działa łącze nazwane z tym że nie jest uzyskiwane w wyniku funkcji <code>pipe()</code> a otwarcia specjalnego pliku (utworzonego <code>mkfifo()</code>) przez dwa procesy (jeden do czytania drugi do pisania).</p>
			<p>Istnieją także inne mechanizmy komunikacji (zarówno prostsze od łącz jak i bardziej od nich zaawansowane), z których część została opisana poniżej.</p>
			<section>
				<h5>Sygnały</h5>
				<p>
					Najprostszą formą komunikacji międzyprocesowej są sygnały. Podstawowe sygnały niosą tylko i wyłącznie informację o swoim numerze (istnieją także sygnały rozszerzone, tzw. czasu rzeczywistego, które niosą także dodatkową wartość liczbową). Sygnał może zostać wysłany przez dowolny proces do dowolnego innego procesu, przy czym warunkiem jego dostarczenia są odpowiednie uprawnienia (procesu użytkowników mogą wysyłać tylko do procesów tego samego użytkownika, root może wysyłać do wszystkich).
				</p><p>
					Każdy sygnał ma zdefiniowane domyślne zachowanie procesu po jego otrzymaniu. Wiele sygnałów związanych jest z standardowymi operacjami (np. wciśnięcie Ctrl+C, Ctrl+Z, Ctrl+/, wykonanie <code>kill <var>$PID</var></code>) i ma odpowiednie do tego zachowania domyślne. Proces może zablokować lub zdefiniować własną obsługę większości (ale nie wszystkich) sygnałów.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/procesy_i_watki/Sygnały.cpp" />
					<insertSourceCode file="code-src/procesy_i_watki/Sygnały.py" />
				</div></div>
			</section>
			<section>
				<h5>Kolejki komunikatów</h5>
				<p>W przypadku gdy grupa procesów ma ze sobą współpracować potrzebne są bardziej zaawansowane (od sygnałów) mechanizmy komunikacji - pozwalające na przekazywanie jakiś danych między procesami. Jednym z takich mechanizmów są kolejki wiadomości. W pewnym stopniu są one podobne do omówionych wcześniej łącz (pipe-ów), jednak w odróżnieniu od nich zamiast jednolitego strumienia danych pomiędzy dwoma procesami (producentem i konsumentem) służą do przekazywania wiadomości pomiędzy grupą producentów i grupą konsumentów.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/procesy_i_watki/Kolejki_komunikatów.cpp" />
					<insertSourceCode file="code-src/procesy_i_watki/Kolejki_komunikatów.py" />
				</div></div>
			</section>
			<section>
				<h5>Pamięć współdzielona</h5>
				<p>Kolejnym mechanizmem komunikacji międzyprocesowej jest współdzielenie części pamięci, które pozwala na operowanie na tych samych danych przez grupę procesów (a nie tylko przekazywanie danych od procesu do procesu jak wyżej opisane metody). Przy pomocy tego mechanizmu możliwe jest stworzenie własnej implementacji łącz (pipe-ów) czy też kolejek wiadomości.</p>
				<p>
					W przypadku korzystania z wspólnej pamięci konieczne jest mechanizm zabezpieczenia przed możliwością równoczesnej modyfikacji tego samego fragmentu przez kilka procesów. Pierwszym nasuwającym się rozwiązaniem jest zastosowanie zmiennej współdzielonej informującej o tym że ktoś blokuje dany fragment celem jego modyfikacji np.:
<pre class="cpp">int blokada=false;
zrownoleglijKod();
if (!blokada) {
	blokada=true;
	sekcjaKrytyczna();
	blokada=false;
}</pre>
					Niestety takie rozwiązanie nie gwarantuje skuteczności blokady, gdyż:<ol>
						<li>może się zdarzyć że na dwóch rdzeniach kod jest wykonywany dokładnie równolegle i dwa procesy sprawdzą wartość zmiennej "blokada" w tej samej chwili a dopiero potem zmienią jej wartość (w efekcie czego oba wejdą do sekcji krytycznej wejdą oba procesy)</li>
						<li>nastąpi przełączenie procesów wykonywanych na jednym rdzeniu pomiędzy sprawdzeniem warunku a modyfikacją zmiennej, co pozwoli wejść drugiemu procesowi do sekcji krytycznej gdy pierwszy już sprawdził warunek wejścia</li>
					</ol>
					Dlatego też korzysta się z mechanizmów systemowych (semaforów, lock'ów, etc) które zapewniają atomowość (nie podzielność) operacji sprawdzenia wartości zmiennej i jej modyfikacji.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/procesy_i_watki/Pamięć_współdzielona.cpp" />
					<insertSourceCode file="code-src/procesy_i_watki/Pamięć_współdzielona.py" />
				</div></div>
			</section>
		</section>
		<section>
			<h4>Wątki</h4>
			<p>
				Oprócz możliwości rozgałęzienia procesu (utworzenia potomka) z użyciem np. <code>fork()</code> możliwe jest także tworzenie wątków (zwanych tez lekkimi procesami) w ramach procesu. Podstawowa różnica między procesem a wątkiem polega na tym iż wszystkie wątki (w ramach danego procesu) współdzielą całość pamięci (przestrzeni adresowej), podczas gdy każdy z procesów posiada niezależną pamięć i co najwyżej jakiś współdzielony z innymi fragment.
				Każdy z wątków posiada natomiast niezależny stos (umieszczony we wspólnej przestrzeni adresowej), który jest używany m.in. do przechowywania zmiennych lokalnych (w tym argumentów funkcji). Jednak ze względu na umieszczenie tych danych w wspólnej przestrzeni adresowej są one także dostępne dla innych wątków (poprzez wskaźnik lub referencję).
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/procesy_i_watki/Wątki-pthread.cpp" />
				<insertSourceCode file="code-src/procesy_i_watki/Wątki-boost.cpp" />
				<insertSourceCode file="code-src/procesy_i_watki/Wątki.py" />
			</div></div>
		</section>
	</section>
	
	<section>
		<h3>Komunikacja sieciowa</h3>
		<p>
			W systemach POSIXowych komunikacja sieciowa wymaga otwarcia tzw. gniazda (socket), przy otwarciu określone muszą zostać:<ol>
				<li>rodzina protokołów sieciowych która będzie używana (np. AF_INET dla IPv4 lub AF_INET6 dla IPv6)</li>
				<li>typ komunikacji realizowanej z użyciem gniazda, do istotniejszych typów zaliczyć należy:<dl>
					<dt><dfn>SOCK_STREAM</dfn></dt>
					<dd>oznaczającego dwukierunkową niezawodną łączność zapewniającą zachowanie kolejności danych (w przypadku rodzin IPv4 i IPv6 będzie to oznaczało użycie TCP)</dd>
					<dt><dfn>SOCK_DGRAM</dfn></dt>
					<dd>oznaczającego bezpołączeniowe przesyłanie wiadomości o limitowanej długości maksymalnej (w przypadku rodzin IPv4 i IPv6 będzie to oznaczało użycie UDP)</dd>
					<dt><dfn>SOCK_RAW</dfn></dt>
					<dd>oznaczającego odbieranie i wysyłanie surowych pakietów warstwy sieciowej (pozwala m.in. na obsługę pakietów ICMP, swobodne manipulowanie adresami w pakietach IP, itd)</dd>
				</dl></li>
			</ol>
			Opcjonalnie może zostać określony konkretny protokół jeżeli w ramach wskazanej rodziny i wskazanego typu występuje ich kilka.
		</p>
		<p>Otwarcie gniazda skutkuje uzyskaniem deskryptora plikowego, na którym zależnie od parametrów przekazanych przy tworzeniu gniazda mogą być wykonywane operacje takie jak wysyłanie / odbieranie danych, ustawiany adres nasłuchiwania, zestawione połączenie, itd.</p>
		
		<section>
			<h4>UDP</h4>
			<p>User Datagram Protocol (UDP) jest protokołem działającym powyżej protokołu IP umożliwiającym proste przesyłanie danych przez sieć. Pakiet UDP oprócz źródłowego i docelowego adresu IP, zawiera też źródłowy i docelowy numer portu. Numer portu określa usługę / proces działający w ramach hosta (określanego numerem IP) który wygenerował / ma otrzymać dany pakiet.</p>
			<p>Po otwarciu gniazda obsługującego UDP możliwe jest:<ul>
				<li>wysyłanie danych pod wskazany adres IP i numer portu</li>
				<li>oczekiwanie na odbiór danych i ich odbiór</li>
				<li>wskazanie adresu i numeru portu na którym oczekujemy na dane (jeżeli nie zostanie wykonane, co jest typowe w klientach UDP, będzie użyty losowy numer portu)</li>
			</ul></p>
			<p>W UDP nie ma zestawionego połączenia zatem nie ma silnego rozróżnienia pomiędzy klientem (nawiązującym połączenie) a serwerem (odczekującym na połączenie / odbierającym je). Jedyna różnica polega na tym że: klient (typowo) nie wywołuje funkcji bind() służącej do określenia adresu wraz z numerem portu używanego do odbioru danych, a zamiast tego korzysta z automatycznie przydzielonego przez system operacyjny (losowego) numeru portu.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/sieciowe/UDP.cpp" />
				<insertSourceCode file="code-src/sieciowe/UDP.py" />
			</div></div>
		</section>
		<section>
			<h4>TCP - klient</h4>
			<p>Transmission Control Protocol (TCP) jest protokołem działającym powyżej protokołu IP gwarantującym niezawodność i kolejność dostarczania danych. Podobnie jak w przypadku UDP pakiety TCP oprócz numerów IP także zawierają docelowy i źródłowy numer portu, służący do identyfikacji procesu otrzymującego i nadającego.</p>
			<p>Działanie TCP opiera się na zestawianiu (i kontrolowaniu) połączenia, w związku z tym klient po otwarciu gniazda musi nawiązać połączenie z wskazanym adresem IP i numerem portu, a dopiero potem może wysyłać lub odbierać dane (nie określając już adresów, gdyż odbywa się to w ramach nawiązanego połączenia) nawet poprzez zwykłe funkcje write() i read(). Połączenie należy zamknąć korzystając z funkcji <code>close()</code>, co informuje zarówno nasz system jak i serwer o zakończeniu połączenia.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/sieciowe/TCP_-_klient.cpp" />
				<insertSourceCode file="code-src/sieciowe/TCP_-_klient.py" />
			</div></div>
		</section>
		<section>
			<h4>TCP - serwer</h4>
			<p>
				Ze względu na nawiązywanie połączenia w przypadku TCP serwer wygląda i działa odmiennie od klienta. Po otworzeniu gniazda serwer musi:
				<ol>
					<li>określić adresu i numeru portu na którym oczekuje na przychodzące połączenia (funkcja <code>bind</code>)</li>
					<li>określić że gniazdo to używane jest do nasłuchiwania połączeń przychodzących (funkcja <code>listen</code>)</li>
					<li>rozpocząć oczekiwanie na odbiór połączenia (funkcja <code>accept</code>)</li>
				</ol>
				Po nawiązaniu połączenia TCP (realizowanym na poziomie systemu operacyjnego) funkcja <code>accept()</code> zwraca nowe gniazdo związane z nawiązanym połączeniem TCP. Ma ono ustawiony adresem IP i portem używany przez klienta oraz inny (niż używany do nasłuchiwania) numer portu po stronie serwera.
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/sieciowe/TCP_-_serwer.cpp" />
				<insertSourceCode file="code-src/sieciowe/TCP_-_serwer.py" />
			</div></div>
		</section>
	</section>
	
	<section>
		<h3>Inne funkcje systemowe</h3>
		<section>
			<h4>Alokacja pamięci</h4>
			<p>
				Zadeklarowanie zmiennej w kodzie programu (prawie zawsze) wiąże się z przydzieleniem jej jakiegoś obszaru pamięci. Kompilator typowo zmienne lokalne umieszczane są w obszarze pamięci nazywanym stosem (znajdują się tam też m.in. argumenty funkcji, stany rejestrów procesora w momencie wywołania funkcji i adresy powrotu funkcji).
			</p><p>
				Stos posiada ograniczony rozmiar, którego przekroczenie (np. na skutek zbyt długiego ciągu wywołań funkcji lub zdefiniowania zbyt dużych zmiennych lokalnych) kończy się błędem przepełnienia stosu. Rozmiar stosu może jednak być zmieniony zarówno przed uruchomieniem procesu (przy pomocy <code>ulimit -s</code>), lub w trakcie jego pracy (przy pomocy <code>setrlimit(RLIMIT_STACK, ...)</code>), pod warunkiem że mieści się w ramach ogólnosystemowego limitu. Zwiększenie rozmiaru stosu wpływa na rozmiar pamięci wirtualnej przydzielonej procesowi, jednak (samo w sobie) nie wpływa na rzeczywiste zużycie pamięci przez proces.
			</p>
			<p>Często nawet samo zadeklarowanie dużej tablicy nie wpływa na rzeczywistą zajętość pamięci, wpływ ma dopiero używanie takiej tablicy:</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/inne_funkcje_systemowe/Alokacja_pamięci--1.cpp" />
			</div></div>
			<p>Mimo możliwości zwiększenia rozmiaru stosu typowo większe bufory czy też obiekty alokowane są poza stosem. W C++ stosowane są dwie techniki takie alokacji: operator <code>new</code> i funkcje z rodziny <code>malloc</code>. Alokacja pamięci poza stosem powoduje konieczność jawnego zwalniania pamięci (nie jest ona zwalniana wraz z zniknięciem zmiennej) przy pomocy odpowiednio operatora <code>delete</code> lub funkcji <code>free</code>.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/inne_funkcje_systemowe/Alokacja_pamięci--2.cpp" />
			</div></div>
		</section>
		<section>
			<h4>Czas</h4>
			<p>Bieżący czas w systemach komputerowych może być reprezentowany na różne sposoby. W przypadku systemów POSIXowych jest to ilość sekund od początku epoki czyli 1970-01-01 00:00:00 UTC. Na podstawie tej wartości może zostać obliczona przez funkcje biblioteczne aktualna data i godzina w ustawionej (poprzez zmienną środowiskową TZ) strefie czasowej.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/inne_funkcje_systemowe/Czas.cpp" />
				<insertSourceCode file="code-src/inne_funkcje_systemowe/Czas.py" />
			</div></div>
		</section>
		<section>
			<h4>Timery</h4>
			<p>Jeżeli program ma wykonywać jakąś czynność co określony czas może korzystać z funkcji <code>sleep</code> lub podobnych celem przeczekania podanego czasu lub skorzystać z timerów celem otrzymania sygnału po zadanym czasie.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/inne_funkcje_systemowe/Timery.cpp" />
			</div></div>
		</section>
		<!-- TODO:  asynchroniczne IO także sieciowe - http://opcode.eu.org/programing/c_cpp/semafory_posix.c/ i TheGame.git/SRC/engine/utils/misc/asioSyn.cpp -->
	</section>
	
	<section>
		<h3>Biblioteki</h3>
		<p>
			Celem uniknięcia konieczności wielokrotnego tworzenia funkcji realizujących te same zadania w programowaniu powszechnie wykorzystuje się różnego rodzaju biblioteki programistyczne. Biblioteka jest zbiorem funkcji i powiązanych z nimi typów danych oraz danych. Praktycznie każdy z języków oferuje zbiór podstawowych funkcji zgromadzony w tzw. bibliotece standardowej, oprócz biblioteki standardowej danego języka można korzystać także z zewnętrznych (w tym własnych) bibliotek.
		</p><p>
			Biblioteka posiada określony interfejs programistyczny (API), definiowany na poziomie kodu źródłowego, który w przypadku programów w C/C++ jest zazwyczaj opisany w plikach nagłówkowych związanych z daną biblioteką (najczęściej z rozszerzeniem .h). Zmiany API biblioteki wraz z kolejnymi jej wersjami mogą (ale nie muszą - zależy od zachowywania tzw. kompatybilności wstecznej przez twórców biblioteki) wymagać zmian w programach z niej korzystających. Interfejs biblioteki typowo dostępny jest natywnie tylko dla języka w którym została stworzona. Dla innych języków wymaga on obudowania w taki spsób aby był zrozumiały dla kompilatora / interpretara danego języka, zadanie to realizują tzw. wrappery.
		</p><p>
			Oprócz API biblioteki posiadają także określony interfejs binarny (ABI), który odpowiada za możliwość wywoływania odpowiednich procedur z biblioteki przez skompilowany i zlinkowany program. Typowo ABI jest mniej stabilne od API i zmiany wymagające skompilowania i zlinkowania programu z nową wersją biblioteki zachodzą częściej niż zmiany API nie zachowujące kompatybilności wstecznej.
		</p><p>
			Kod biblioteki może być włączony na stałe w kod programu (biblioteka statyczna) - zapewnia to brak problemów z zgodnością ABI biblioteki pomiędzy systemem na którym program został skompilowany i zlinkowany, a systemem na którym jest uruchamiany. Skutkuje to jednak wzrostem rozmiaru pliku wykonywalnego oraz zapotrzebowaniem na pamięć uruchomionego programu. Alternatywą są biblioteki ładowane dynamicznie, które dostarczane są jako osobne (w stosunku co do binarki programu) pliki i ładowane do pamięci w momencie startu programu lub podczas jego działania. Kilka różnych programów używających tej samej biblioteki dynamicznej będzie używało jednej jej kopi umieszczonej w pamięci RAM.
		</p>
		<section>
			<h4>API, skrypty, ...</h4>
			<section>
				<h5>API pythonowe biblioteki C++</h5>
				<p>
					Podstawowy interpreter Pythona stworzony jest w C, podobnie wiele z popularnych modułów (bibliotek) pythonowych jest tworzony w C lub C++.
					Python potrafi korzystać z zwykłych bibliotek C (poprzez moduł ctypes), jednak aby z biblioteki korzystało się wygodnie powinna ona wystawiać bardziej natywny interfejs pythonowy w postaci modułu. Na utworzenie takiego interfejsu z poziomu C pozwala biblioteka programistyczna dostarczana wraz z Pythonem, w przypadku C++ można także korzystać z obudowującego wywołania tej biblioteki boost::python.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/biblioteki/API_pythonowe_biblioteki_C++.cpp" />
					<insertSourceCode file="code-src/biblioteki/API_pythonowe_biblioteki_C++.py" />
					<insertSourceCode file="code-src/biblioteki/natywna_biblioteka_C_w_Pythonie.py" />
				</div></div>
			</section>
			<section>
				<h5>interfejs skryptowy programu C++</h5>
				<p>W wielu przypadkach zachodzi potrzeba połączenia zalet programów kompilowanych (szybkość działania) i interpretowanych (elastyczność, łatwość modyfikacji). Jednym z rozwiązań to umożliwiających jest utworzenie w ramach kodu kompilowanego C++ interfejsu modułu pythonowego, przy jednoczesnej możliwości zapewnienia wywoływania skryptów pythonowych z poziomu kodu C++ korzystających do komunikacji z tym kodem z tego interfejsu.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/biblioteki/interfejs_skryptowy_programu_C++.cpp" />
					<insertSourceCode file="code-src/biblioteki/interfejs_skryptowy_programu_C++.py" />
				</div></div>
			</section>
		</section>
		<section>
			<h4>Bazy danych</h4>
			<p>
				Standardowym językiem używanym do komunikacji z systemami bazodanowymi jest SQL. Pomimo jego standaryzacji istnieją różnice w składni zapytań dla poszczególnych silników bazodanowych (takich jak: MariaDB, PostgreSQL, SQLite, ...).
			</p><p>
				Typowo komunikacja z bazą danych odbywa się za pośrednictwem biblioteki odpowiedzialnej za nawiązanie połączenia z serwerem i przekazywanie do niego zapytań SQL. Wymaga to działania osobnego procesu (często nawet na innej maszynie) obsługującego silnik bazodanowy, co jest pożądanym rozwiązaniem dla baz danych z których równocześnie może korzystać wielu klientów. Typowym przykładem może być komunikacja skryptów jakiegoś serwisu interetowego z bazą danych.
			<br />
				Jednak takie podejście nie jest wygodne w rozwiązaniach nie wymagających współdzielenia bazy danych. Do zastosowań takich można użyć biblioteki SQLite, która pozwala na łatwe stosowanie bazy SQLowej do wewnętrznych potrzeb aplikacji, bez konieczności uruchamiania osobnego systemu bazodanowego.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/biblioteki/Bazy_danych.cpp" />
				<insertSourceCode file="code-src/biblioteki/Bazy_danych.py" />
			</div><br /><div>
				<insertSourceCode file="code-src/biblioteki/Bazy_danych.php" />
			</div></div>
		</section>
		<section>
			<h4>(Graficzny) interfejs użytkownika</h4>
			<p>
				Jeżeli zachodzi potrzeba interakcji z użytkownikiem programu, zamiast wspomnianego wcześniej prostego pytania o kolejne parametry z użyciem standardowego wyjścia i wejścia, często stosuje się pseudo-graficzny lub graficzny interfejs użytkownika.
				
				Interfejs pseudo-graficzny jest zasadniczo bardziej wyrafinowaną formą interakcji przez standardowe wyjście i wejście programu i wykorzystuje standardowe wyjście do rysowania różnego typu okienek dialogowych, itp. w trybie tekstowym.
			</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/biblioteki/Graficzny_interfejs_użytkownika.py" />
				<insertSourceCode file="code-src/biblioteki/Graficzny_interfejs_użytkownika-qt4.py" />
				<insertSourceCode file="code-src/biblioteki/Graficzny_interfejs_użytkownika-gtk3.py" />
			</div></div>
		</section>
	</section>
	
	<section>
		<h3>Programowanie sprzętu</h3>
		<p>Typowo programy komputerowe uruchamiane są pod kontrolą jakiegoś systemu operacyjnego, który odpowiada za realizację sporej części funkcji określonych przez bibliotekę standardową (np. operacji plikowych, standardowego wejścia i wyjścia) oraz zapewnia możliwość równoczesnego działania wielu procesów (ich przełączania). Jednak niekiedy zachodzi potrzeba stworzenia programu który będzie działał bezpośrednio na sprzęcie bez pośrednictwa systemu operacyjnego. Może to mieć miejsce np. wtedy gdy zasoby danej platformy sprzętowej są zbyt ograniczone aby uruchomić na niej system operacyjny i naszą aplikację lub tworzymy system operacyjny.</p>
		
		<section>
			<h4>Przerwania</h4>
			<p>Przerwanie (żądanie przerwania, IRQ) jest sygnałem powodującym wstrzymanie wykonywania aktualnego kodu i wykonanie zdefiniowanej (dla danego przerwania) procedury jego obsługi. Przerwania mogą być związane z:<ul>
				<li>sygnałem otrzymanym od zewnętrznego układu (tzw. przerwania sprzętowe) - mające na celu np. poinformowanie o zakończeniu jakiejś operacji wejścia wyjścia, otrzymaniu danych na jakimś interfejsie,</li>
				<li>wykonywanym kodem (tzw. przerwania programowe) - zarówno wywołane celowo (np. celem komunikacji z systemem operacyjnym), jak też pojawiające się na skutek nietypowych / błędnych działań - tzw. "wyjątki" (np. dzielenia przez zero).</li>
			</ul></p>
			
			<p>Na wielu architekturach program może wygenerować dowolne z przerwań (także tych związanych z sprzętem, czy też wyjątków) poprzez wywołanie stosownej instrukcji procesora której argumentem jest numer przerwania. Generowanie przerwań instrukcją procesora jest wykorzystywane m.in. celem realizacji wywołań systemowych (czyli wywołań funkcji jądra z poziomu programu użytkownika). W przypadku Linuxa na architekturze x86 za wywołania systemowe odpowiada przerwanie o numerze 0x80, numer funkcji systemowej musi być uprzednio umieszczony w rejestrze eax, a jej kolejne argumenty w rejestrach ebx, ecx, edx, edi, esi, ebp; podobnie status operacji i wartość zwracana jest umieszczana w odpowiednich rejestrach procesora.</p>
			
			<p>Istnieje możliwość zablokowania obsługi wszystkich przerwań pochodzących z zewnątrz (z wyjątkiem przerwań nie maskowanych) stosowaną instrukcją procesora. Obsługa przerwań przez procesor polega na zidentyfikowaniu (w oparciu o numer/źródło przerwania i dane zawarte w obszarze pamięci często nazywanym tablicą wektorów przerwań) adresu procedury obsługi przerwania i wykonaniu jej w sposób podobny do wykonania funkcji, czyli z odłożeniem aktualnego stanu procesora na stos (celem umożliwienia powrotu do niego po zakończeniu procedury obsługi przerwania w celu kontynuowania przerwanego kodu). Jeżeli procedura obsługi przerwania ma inny poziom uprzywilejowania (np. działa na prawach jądra systemu operacyjnego) to procesor może także dokonać przełączenia stosu.</p>
			
			<p>Z punktu widzenia wielozadaniowego systemu operacyjnego szczególnie istotne jest przerwanie sprzętowe związane z odmierzeniem ustalonego czasu (zwane przerwaniem zegarowym), pozwala ono na odebranie kontroli aktualnie wykonywanemu procesowi, przekazanie jej systemowi operacyjnemu i umożliwienia przełączenia na inny proces.</p>
		</section>
		
		<section>
			<h4>Mikrokontrolery AVR</h4>
			<p>Jest to rodzina 8-bitowych mikrokontrolerów RISC, które mogą być programowane z wykorzystaniem języka C z pomocą odpowiedniej wersji gcc i biblioteki avr-libc.</p>
			
			<p>Niżej prezentowane kody dedykowane są dla mikrokontrolera ATmega328, będą działać poprawnie także na wielu innych układach, jednak w niektórych wypadkach konieczna może być zmiana nazw niektórych z rejestrów np dla ATmega8:</p>
<pre class="cpp">#define USART_RX_vect USART_RXC_vect
#define UDR0          UDR
#define UBRR0L        UBRRL
#define UBRR0H        UBRRH
#define UCSR0B        UCSRB
#define UCSR0A        UCSRA
#define TXEN0         TXEN
#define RXEN0         RXEN
#define RXCIE0        RXCIE
#define UDRE0         UDRE
</pre>
			<p>Kompilację poniższych kodów dla ATmega328 oraz wgranie ich do mikrokontrolera można wykonać przy pomocy następujących poleceń:</p>
<pre class="bash"># kompilacja
avr-gcc -mmcu=atmega328p -Os -o avrdemo.o $INPUT_FILE

# konwersja do formatu hex obsługiwanego przez programatory
avr-objcopy -O ihex avrdemo.o avrdemo.hex

# zapis (i weryfikacja) pamięci flash (programator ISP na usb zgodny z usbasp):
sudo avrdude -c usbasp -p atmega328p -U flash:w:avrdemo.hex

# alternatywnie - zapis (i weryfikacja) pamięci flash
# (wgrany w programowanym układzie bootloader z komunikacją UART zgodny z arduino):
sudo avrdude -q -V -p atmega328p -C /usr/share/arduino/hardware/tools/avrdude.conf -D \
  -c arduino -b 57600 -P /dev/ttyUSB0 -U flash:w:avrdemo.hex:i
</pre>
			<section>
				<h5>obsługa GPIO</h5>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/avr/obsługa_GPIO.cpp" />
					<insertSourceCode file="code-src/avr/obsługa_GPIO--input.cpp" />
				</div></div>
			</section>
			<section>
				<h5>obsługa portu szeregowego</h5>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/avr/obsługa_portu_szeregowego.cpp" />
					<insertSourceCode file="code-src/avr/obsługa_portu_szeregowego--przerwania.cpp" />
					<insertSourceCode file="code-src/avr/obsługa_portu_szeregowego--biblioteczka.cpp" />
				</div></div>
			</section>
			<section>
				<h4>obsługa przetwornika analogo-cyfrowego</h4>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/avr/obsługa_przetwornika_analogo-cyfrowego.cpp" />
				</div></div>
			</section>
			<section>
				<h5>obsługa I2C</h5>
				<section>
					<h6>master</h6>
					<p>w tym trybie mikrokontroler zarządza magistralą - generuje sygnał zegara, wybiera układ z którym chce się komunikować oraz tryb tej komunikacji (zapis czy odczyt)</p>
					<div class="demo_codes"><div>
						<insertSourceCode file="code-src/avr/obsługa_I2C--slave.cpp" />
					</div></div>
				</section>
				<section>
					<h6>slave</h6>
					<p>w tym trybie mikrokontroler czeka na zainicjowanie komunikacji przez mastera i postępuje zgodnie z otrzymanymi od niego instrukcjami</p>
					<div class="demo_codes"><div>
						<insertSourceCode file="code-src/avr/obsługa_I2C--master.cpp" />
					</div></div>
				</section>
			</section>
		</section>
		<section>
			<h4>obsługa sprzętu w ramach OS</h4>
			<p>Obsługa sprzętu nie zawsze wiąże się z tworzeniem kodu działającego bez systemu operacyjnego, na większych układach może działać normalny system operacyjny (np. Linux na płytkach typu Raspberry Pi czy Orange Pi). W takiej sytuacji obsługę sprzętu można zrealizować poprzez własny moduł jądra za nią odpowiedzialny lub (gdy to jest możliwe) poprzez funkcje udostępnione do przestrzeni użytkownika przez system operacyjny i jakąś bibliotekę. Przykładem drugiego podejścia może być wykorzystywanie plików funkcji operujących na przestrzeni I/O (plik nagłówkowy asm/io.h), funkcji realizujących komunikację I2C (plik nagłówkowy linux/i2c-dev.h), czy też biblioteki libusb pozwalającej na obsługę komunikacji USB.</p>
			<section>
				<h5>komunikacja I2C</h5>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/inne_funkcje_systemowe/komunikacja_I2C.cpp" />
				</div></div>
			</section>
		</section>
	</section>
	
	<section>
		<h3>Wzorce projektowe, algorytmy, itp</h3>
		<section>
			<h4>Obiektowość</h4>
			<p>
				Obiektowość jest podejściem do programowania polegającym na łączeniu danych i powiązanych z nimi procedur w obiekty. W rezultacie zamiast grupy funkcji operujących na jakiejś strukturze danych i osobnych instancjach tej struktury (np. napis typu <code>char*</code> i funkcje z rodziny <code>string.h</code>) operuje się obiektami zawierającymi w sobie dane i posiadającym metody na nich operujące (np. napis typu <code>std::string</code>).
				Z obiektowością związane są zagadnienia takie jak: określanie interfejsów klas odnoszących się jedynie do kluczowych dla danego zagadnienie elementów i ukrywaniu pozostałych aspektów wewnątrz implementacji klasy, wydzielanie wspólnych cech obiektów różnego typu do klas bazowych po których dziedziczą.
			</p>
		</section>
		
		<section>
			<h4>Dziedziczenie, polimorfizm, itp</h4>
			<p>Dziedziczenie jest jednym z mechanizmów pozwalających na konstrukcję klas opisujących bardziej złożone obiekty z klas prostszych.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/Dziedziczenie_polimorfizm_itp.cpp" />
			</div></div>
		</section>
		
		<section>
			<h4>Tworzenie i rozbudowa obiektów</h4>
			<section>
				<h5>metoda wytwórcza</h5>
				<p>jest to kreacyjny wzorzec projektowy (inaczej nazywany <dfn>wirtualny konstruktor</dfn>) realizowany poprzez utworzenie klasy fabryki z metodą statyczną odpowiedzialną za tworzenie różnych produktów (dziedziczących po wspólnej klasie bazowej).</p>
				<p>Efektem zastosowanie jest ukrycie szczegółów implementacji poszczególnych produktów przez użytkownikiem (korzysta on tylko z klasy bazowej produktu i fabryki).</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/metoda_wytwórcza.cpp" />
				</div></div>
			</section>
			<section>
				<h5>fabryka abstrakcyjna</h5>
				<p>jest to kreacyjny wzorzec projektowy realizowany poprzez utworzenie klasy fabryki z metodą statyczną odpowiedzialną za tworzenie różnych typów fabryk dziedziczących po wspólnej klasie bazowej. Klasa bazowa fabryki określa gamę produktów z użyciem klas bazowych produktów, w efekcie każda z fabryk produkuje taką samą gamę produktów, ale do ich tworzenia może korzystać z specyficznych dla danej implementacji fabryki klas dziedziczących po produktach bazowych.</p>
				<p>Efektem zastosowanie jest ukrycie szczegółów implementacji poszczególnych produktów przez użytkownikiem (korzysta on tylko z klasy bazowej produktu i fabryki).
					W odróżnieniu od metody wytwórczej stosowany jest do produkcji spójnych gam produktów dzięki jednokrotnemu określaniu typu produktów przy tworzeniu fabryki (zamiast niezależnego określania typu każdego produktu). Pozwala tylko raz określić używany typ fabryki i wytwarzać produktu uzyskaną fabryką konkretnego typu, jest to przydatne wtedy gdy konkretna implementacja fabryki jest zależna np. od stosowanej biblioteki lub systemu.
				</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/fabryka_abstrakcyjna.cpp" />
				</div></div>
			</section>
			<section>
				<h5>budowniczy</h5>
				<p>jest to kreacyjny wzorzec projektowy realizowany poprzez utworzenie klasy kierownika korzystającego z bazowego interfejsu klasy budowniczego do realizacji jakiegoś algorytmu (często konwersji formatów). Użytkownik odpowiedzialny jest za utworzenie konkretnego budowniczego, przekazanie wskaźnika na niego kierownikowi (ewentualnie wraz z danymi potrzebnymi do budowy, np. danymi które mają zostać poddane konwertowaniu) oraz odebraniu wyniku od budowniczego.</p>
				<p>Efektem jest pełne ukrycie szczegółów implementacji przed klasą implementującą kierownika (nie wie nic o produkcie, używa tylko bazowego budowniczego).</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/budowniczy.cpp" />
				</div></div>
			</section>
			<section>
				<h5>singleton</h5>
				<p>Singleton jest kreacyjnym wzorcem projektowym zapewniającym istnienie tylko jednej instancji (jednego obiektu) klasy go implementującej. Uzyskiwane jest to poprzez ukrycie konstruktorów i zastąpienie ich metodą statyczną zwracającą zawsze ten sam obiekt danej klasy.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/singleton.cpp" />
				</div></div>
			</section>
			<section>
				<h5>dekorator</h5>
				<p>jest strukturalnym wzorcem projektowym pozwalającym na rozbudowę funkcjonalności jakiejś klasy bez ingerencji w nią, realizowany jest poprzez dziedziczenie po wspólnym z obudowywaną klasą interfejsie i zawieranie w sobie wskaźnika na obudowywaną klasę. Dekorator reimplementuje wybrane funkcje klasy oryginalnej jednak wywołując w nich funkcje klasy oryginalnej, co pozwala na wielokrotne obudowywanie pierwotnego obiektu.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/dekorator.cpp" />
				</div></div>
			</section>
			<section>
				<h5>kompozyt</h5>
				<p>jest strukturalnym wzorcem projektowym pozwalającym na zapewnienie interfejsu zgodnego z interfejsem obiektu dla grupy obiektów.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/kompozyt.cpp" />
				</div></div>
			</section>
		</section>
		
		<section>
			<h4>Komunikacja między obiektami</h4>
			<section>
				<h5>listener</h5>
				<p>Obserwator (określany też jako listener) jest czynnościowym wzorcem projektowym pozwalającym jednemu obiektowi powiadomić wiele innych obiektów o jakimś zdarzeniu, obiekty te powinny być uprzednio zarejestrowane w klasie powiadamiającej jako zainteresowane danym zdarzeniem). Może być też wykorzystywany do realizacji wzorca <dfn>łańcuch zobowiązań</dfn> wtedy gdy powiadamiane obiekty mają / mogą wykonać jakieś operacje i od kodu powrotu funkcji powiadamiającej zależy powiadamianie dalszych obiektów.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/listener.cpp" />
				</div></div>
			</section>
			<section>
				<h5>Mediator</h5>
				<p>jest czynnościowym wzorcem projektowy realizującym przekazywanie wiadomości pomiędzy obiektami poprzez pośrednika, w przypadku nie natychmiastowego wysyłania wiadomości przez mediatora pozwala także na realizację <dfn>kolejki wiadomości</dfn> / <dfn>pętli komunikatów</dfn>.</p>
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/Mediator.cpp" />
				</div></div>
			</section>
		</section>
		
		<!-- TODO: wspomnieć o innych wzorcach projektowych:
			prototyp
				trywialne - klasa bazowa (interfejs) ma metodę klonującą implementowaną w pochodnych i używaną do tworzenia nowych obiektów ...
			
			Adapter
				dostosowuje interfejs klasy A do interfejsu opisanego klasą B, może być zrealizowany
				- obiektowo (adapter zawiera obiekt klasy A, dziedziczy po B)
				- klasowo (obiekt dziedziczy prywatnie po A i publicznie po B)
			Fasada
				zakrywa prawdziwą implementację uproszczonym interfejsem
			
			Most
				klasy obiektów (dziedziczące po wspólnym przodku) korzystają z przekazanej do nich konkretnej implementacji abstrakcyjnej klasy realizującej jakieś zadanie tylko przy pomocy jej interfejsu
				https://pl.wikibooks.org/wiki/Kody_%C5%BAr%C3%B3d%C5%82owe/Most_(wzorzec_projektowy)
				IMHO zmaist w klasie bazowej Shape dawać DrawCircle, lepiej w klasie Circle dać _da->DrawCircle()
				mozna by go opisać ale bardziej w wariancie pokazanym dla C#
			
			Pełnomocnik
				obudowuje obiekt celem jakiejś formy kontroli dostępu do niego (np. sprytne wskaźniki do zliczania ilości odwołań)
			
			Pyłek
				
			
			Interpreter 
				
			
			Polecenie
				opisanie akcji jako obiektu, gdzie konkretne akcje dziedziczą po klasie bazowej
			
			Iterator
				jak std::list::iterator
			
			Memento
				klasy dziedziczą po interfejsie pozwalającym na zapisanie lub odtworzenie ich stanu w postaci pamiątki (podobne do serializacji)
			
			Metoda szablonowa
				metoda wywołująca inne metody (które mogą lub muszą być zaimplementowane w klasie pochodnej) do realizacji swojej funkcjonalności ... zasadniczo trywialny
			
			Stan
				klasa trzyma wskaźnik na obiekt ustawiany jakąś metodą, który potem jest używany wewnętrznie przez inne metody ... zasadniczo trywialny
			
			Strategia
				wywołanie funkcji z obiektu klasy dziedziczącej po interfejsie danej strategii w ramach realizacji swojego algorytmu ... trochę jak metoda szablonowa, ale nie dziedziczymy po, a za to mamy obiekt ...
			
			Odwiedzający
				klasa odwiedzająca definiuje abstrakcyjny interfejs, klasy po niej dziedziczące mogą implementować różne funkcjonalności
				klasa ta ma metody visit() dla każdego obsługiwanego typu
				obsługiwane typy maja metode accept() przyjmująca obiekt odwiedzający i wołający jego metodę visit() z wskaźnikiem na siebie jako arguimentem
				tylko po co ta zabawa z accept() zamiast od razu wołania visit()
			
			RAII
				trywialne - używamy konstruktora do rezerwacji zasobów i destruktora do ich zwolnienia
			
			leniwa inicjalizacja
				zasadniczo to samo co w moim singletonie tylko że bez static
		-->
		
		<section>
			<h4>Regulator PID</h4>
			<p>Regulator PID jest to algorytm regulacji parametru procesu działający w pętli sprzężenia zwrotnego posiadający człony: proporcjonalny (P), całkujący (I) i różniczkujący (D).</p>
			<p>Wyjściem algorytmu jest wartość zmiany jakiegoś sygnału sterującego - może być wykorzystana bezpośrednio przy sterowaniu krokowym lub akumulowana celem uzyskania stałej wartości sygnału sterującego.</p>
			<p>Wejściem algorytmu jest wartość mierzona (bądź od razu różnica wartości zadanej i mierzonej). Jeżeli kierunek zmiany sterowania jest zgodny ze zmianą wartości mierzonej (zwiększenie wartości sygnału sterującego powoduje zwiększenie wartości mierzonej) to należy odejmować wartość mierzoną od zadanej, w przeciwnym razie od zadanej mierzoną.</p>
			<div class="demo_codes"><div>
				<insertSourceCode file="code-src/wzorce_projektowe_i_algorytmy/pid.cpp" />
			</div></div>
		</section>
	</section>
</section>

<section>
	<h2>Sieci komputerowe</h2>
	<p>Sieć komputerowa jest to zbiór hostów (urządzeń wykorzystujących sieć do komunikacji, takich jak komputery, drukarki sieciowe, ...) oraz infrastruktury sieciowej (okablowanie, urządzania pośredniczące w komunikacji). W przypadku bardziej abstrakcyjnego patrzenia na zagadnienia sieciowe (właśnie od strony protokołów wyższych warstw niż sprzętowa - takich jak IP) na sieć można patrzeć tylko jako na zbiór hostów (posiadających identyfikujące je numery). Dla funkcjonowania sieci konieczne jest zapewnienie dobrze określonych zasad jej działania - właśnie zbiorami takich zasad wymiany informacji są protokoły sieciowe.</p>
	
	<!-- BEGIN: Sieci - intro -->
	<p>Sieci komputerowe działają na zasadzie przesyłania informacji w postaci porcji, z których każda posiada co najmniej informację o adresie odbiorcy (zwykle też nadawcy), nazywanych ramkami lub pakietami. Kierowanie pakietów w odpowiednie miejsce odbywa się na podstawie adresu pakietu i nie jest związane z fizycznym zestawianiem łącza pomiędzy nadawcą a odbiorcą - każdy pakiet jest kierowany niezależnie, a w ramach pojedynczego łącza (kanału transmisji) mogą być przekazywane pakiety adresowane do różnych odbiorców. Nazywane jest to komutacją pakietów, w odróżnieniu od komutacji łącza (która występowała np. w klasycznej, analogowej telefonii, gdzie przekaźniki w centralach dokonywały zestawienia połączeń elektrycznych między dwoma aparatami telefonicznymi).</p>
	
	<p>Komunikacja sieciowa typowo posiada strukturę warstwową. W modelu OSI wyróżnia się 7 warstw:<ul>
		<li>fizyczną (pierwszą) definiującą aspekty związane z fizycznym przesyłem sygnału takie jak częstotliwości radiowe, poziomy napięć, etc.;<br />
			określa sposób transmisji kolejnych bajtów</li>
		<li>łącza danych (drugą) definiującą aspekty związane z formatem ramki, protokoły ustalania zasad dostępu do medium transmisyjnego, itd.;<br />
			określa sposób transmisji porcji danych pomiędzy hostami w jednej sieci</li>
		<li>sieciową (trzecią) definiującą aspekty związane z formatem pakietu, adresacją i zasady routingu umożliwiające zapewnienie łączności pomiędzy różnymi sieciami;<br />
			określa sposoby transmisji porcji danych pomiędzy sieciami</li>
		<li>transportową (czwartą) odpowiedzialną za podział strumienia na porcje informacji, kontrolę nad poprawnością transmisji, adresację usług w ramach hosta</li>
		<li>sesji (piątą)</li>
		<li>prezentacji (szóstą)</li>
		<li>aplikacji (siódmą)</li>
	</ul>W modelu TCP/IP wyróżnia się 4 warstwy:<ul>
		<li>Dostępu do sieci - obejmującą warstwy 1 i 2 modelu OSI</li>
		<li>Internetu - obejmującą warstwę 3 modelu OSI</li>
		<li>Transportową - obejmującą warstwę 4 modelu OSI</li>
		<li>Aplikacji - obejmującą warstwy 5, 6 i 7 modelu OSI</li>
	</ul>Z punktu widzenia modelu TCP/IP można powiedzieć o enkapsulacji danych kolejnych warstw w ramach warstwy niższej, czyli "surowe" dane (np. strona HTML) obudowywane są strukturą opisywaną przez warstwę aplikacji (np. nagłówkami HTTP), następnie całość ta umieszczana jest w polu danych pakietu warstwy transportowej (np. TCP), ten z kolei w polu danych pakietu IP (warstwy sieciowej), na koniec pakiet IP jest umieszczany w polu danych ramki warstwy dostępu do sieci (np. ramki ethernetowej). W ramach podróży przez kolejne sieci pakiet IP jest wyjmowany i wkładany w kolejne ramki warstwy dostępu do sieci, na ogół tylko z niewielkimi ingerencjami w zawartość tego pakietu (prawie zawsze nie dochodzącymi do pola danych pakietu TCP lub datagramu UDP, czyli nie wykraczającymi poza warstwę 4 OSI).</p>
	<!-- END: Sieci - intro -->
	
	<section>
		<!-- BEGIN: Warstwa sprzętowa -->
		<h3>Warstwa sprzętowa</h3>
		<p>Od strony sprzętowej sieć składa z:<ul>
			<li>hostów stanowiących nadawców i odbiorców informacji</li>
			<li>urządzeń sieciowych pośredniczących w ich przekazywaniu, takich jak nadajniki, switche, mediakonwertery</li>
			<li>okablowania miedzianego bądź światłowodowego (jeżeli nie jest siecią bezprzewodową)</li>
		</ul></p>
		<section>
			<h4>Ethernet</h4>
			<p>W przypadku sieci w standardzie Ethernet stosowane są 48 bitowe adresy MAC (pierwsza część identyfikuje producenta karty) oraz wspólny dla wszystkich odmian (przewodowych i bezprzewodowych) format ramki (określający położenie w ramce adresów, informacji dodatkowych oraz danych). Pakiety protokołu warstwy wyższej (np. pakiety IP wraz ich strukturą zawierającą adresy itd) z punktu widzenia ramki ethernetowej są danymi, w które ta warstwa nie wnika. Do mapowania adresów IP na adresy MAC wykorzystywany jest protokół ARP (dla IPv4) lub Neighbor Discovery (dla IPv6) - odbywa się to poprzez wysłanie ramki ethernetowej na adres rozgłoszeniowy (odbierany przez wszystkie hosty) z pytaniem o to jaki MAC adres ma host o podanym numerze IP.</p>
			
			<p>Sieć ethernetowa typowo posiada strukturę wielokrotnej gwiazdy (drzewa), w węzłach której stosowane są switche. Kierują one ramki do odpowiednich gałęzi na podstawie adresu docelowego i wpisów w tablicy adresów MAC, utworzonej w oparciu o źródłowe nadawców przechodzących przez dany switch ramek. W przypadku gdy adresu docelowego nie ma w tablicy ramka kierowana jest na wszystkie porty switcha z wyjątkiem tego na którym została odebrana. W taki sposób zawsze są też przesyłane ramki wysyłane na adres rozgłoszeniowy (bradcast).</p>
			
			<p>Ethernet pozwala na wirtualne podzielenie pojedynczej sieci lokalnej na wiele niezależnych (nie komunikujących się ze sobą w warstwie ethernetu) sieci, nazywanych VLAN. Działanie tego mechanizmu opiera się na zastosowaniu zarządzalnych switchy, które programowo mogą być dzielone na części zapewniające separację ruchu poszczególnych VLANów. Ponadto wybrane porty takiego switcha mogą być przypisane do różnych części (celem udostępnienia do innego switcha lub hosta kilku sieci wirtualnych), w takim przypadku do ramek ethernetowych wysyłanych tym portem dodawana jest informacja do którego VLANu należą (dwu bajtowy numer), a w przypadku ramek otrzymywanych na podstawie tego numeru odbywa się ich kierowanie do odpowiedniej "części" przełącznika (mówimy o VLANach tagowanych). Możliwe jest aby jeden wybrany VLAN na takim porcie był nie tagowany (do jego ramek nie będzie dodawany numer, a otrzymywane pakiety bez numeru będą kierowane do niego.</p>
			
			<p>Ethernet pozwala również na grupowanie kilku portów w jeden port wirtualny (tzw port trunking / bonding) celem zwiększenia przepustowości lub niezawodności łącza. A dzięki zastosowaniu w różnych typach sieci ethernet tego samego formatu ramki możliwe jest też stosunkowo proste zmienianie medium transmisyjnego (np. z kabla miedzianego na światłowód) z użyciem media-konwerterów.</p>
			
			<p>W przewodowych sieciach Ethernet wykrywaniem zajętości medium transmisyjnego oraz wykrywaniem kolizji zajmuje się protokół CSMA/CD (Carrier Sense Multiple Access with Collision Detection - wielodostęp z rozpoznawaniem stanu kanału oraz wykrywaniem kolizji). Przed rozpoczęciem nadawania stacja musi sprawdzić czy medium jest wolne, jeżeli tak może zacząć nadawać, jeżeli dwie stacje zaczną nadawać równocześnie zostaje to wykryte, obie przerywają nadawanie i wznawiają po losowym czasie. Jednak ze względu na stosowanie głównie połączeń punkt-punkt full-duplex (osobne przewody do nadawania i osobne do odbioru), co ogranicza tzw. domenę kolizji do pojedynczego hosta, protokół ten nie odgrywa obecnie szczególnie istotnej roli.</p>
		</section>
		<!-- END: Warstwa sprzętowa -->
	</section>
	<section>
		<!-- BEGIN: adresacja IP -->
		<h3>Sieci IP</h3>
		<p>Protokół IP (Internet Protocol) odpowiedzialny jest przede wszystkim za sposób adresacji hostów oraz reguły komutacji pakietów (routing). Jest on wspomagany przez kolejny protokół z tej rodziny - ICMP (Internet Control Message Protocol), którego zadaniem jest przekazywanie informacji kontrolnych np. o nieosiągalności hosta docelowego, odrzuceniu przetwarzania pakietu ze względu na zbyt dużą liczbę skoków (gdy wartość pola TTL z nagłówka IP wyniesie zero) a także pingi (zarówno żądanie jak i odpowiedź).</p>
		<section>
			<h4>Adresacja i routing</h4>
			<p>Adresy hostów (nazywane adresami IP) są to 32-bitowe (w IPv4) lub 128-bitowe (w IPv6) liczby.</p>
			
			<p>Adresy IPv4 zapisywane są najczęściej w notacji kropkowo-dziesiętnej, gdzie każdy bajt (ciąg 8 bitów) zapisywany jest jako liczba dziesiętna rozdzielana kropką od pozostałych. Adresy IPv6 zapisywane są zazwyczaj w notacji dwukropokowej, polegającej na zapisywaniu 16 bitowych części adresu liczbami szesnastkowymi oddzielanymi dwukropkiem, dodatkowo jeden ciąg zer (o długości będącej wielokrotnością 16 bitów) może być skompresowany (pominięty) co daje w zapisie dwa dwukropki <code>::</code>.</p>
			
			<section>
				<h5>Długość prefixu i maska</h5>
				<p>Adresy hostów grupuje się w adresy sieci, bazując na jednakowym (bitowo) początku takiego adresu (zwanym adresem sieci lub prefixem). Ilość bitów stanowiących adres sieci w danym adresie IP nazywana jest długością prefixu i zapisywana jest zazwyczaj po ukośniku. Np. zapis <code>2001:db8::a17/48</code> oznacza że pierwsze 48 bity stanowią adres sieci a kolejne 128-48 = 80 bitów stanowi adres hosta w tej sieci.</p>
			
				<p>Długość prefixu jednoznacznie określa maskę danej podsieci, czyli liczbę odpowiadającą długości adresu (32 bity lub 128 bitów), złożoną z ciągu jedynek o długości prefixu oraz ciągu zer (o długości adresu hosta). W przypadku IPv4 spotykane jest także podawanie maski sieci w notacji kropkowo-dziesiętnej zamiast długości prefixu.</p>
			
				<p>Sieć może zostać podzielona na mniejsze sieci (z większą wartością prefixu), jak też grupa sieci może zostać zagregowana w jedną większą (2<sup>n</sup> raza) sieć (z prefixem mniejszym o n). Agregacja hostów i sieci w większe całości jest wykorzystywana w mechanizmach routingu, co pozwala na redukcję wielkości tablic routingowych.</p>
			</section>
			
			<section>
				<h5>Przynależność do sieci</h5>
				<p>Adres sieci zapisuje się typowo z wyzerowanymi bitami stanowiącymi adres hosta (czyli po dokonaniu bitowego <i>and</i> z maską danej sieci) oraz podaną informacją o długości prefixu, dla powyższego przykładu będzie to <code>2001:db8::/48</code>. Informacja taka jest wystarczająca do sprawdzenia czy dowolny inny adres IP należy do tej sieci czy nie.</p>
				
				<div class="demo_codes"><div>
					<insertSourceCode file="code-src/sieciowe/Adresacja_i_routing--ipv6.py" />
					<insertSourceCode file="code-src/sieciowe/Adresacja_i_routing--ipv4.py" />
				</div></div>
			</section>
			
			<section>
				<h5>Routing</h5>
				<p>Router kieruje każdy z pakietów do kolejnego routera lub bezpośrednio do hosta docelowego na podstawie jego adresu docelowego i tablicy routingu. Tablica taka zawiera adresy sieci wraz z adresami następnych routerów do nich prowadzących bądź wskazaniem lokalnego interfejsu sieciowego poprzez który powinny być osiągalne hosty z danej sieci. W tym celu korzysta z sprawdzania przynależności adresu do sieci, w celu ustalenia adresu następnego routera i/lub interfejsu sieciowego na który ma zostać przekazany pakiet.</p>
				
				<p>Tablica przeglądana jest od wpisów najbardziej precyzyjnych, czyli z największym prefixem do wpisów najbardziej ogólnych (ostatnim wpisem jest na ogół trasa domyślna czyli sieć ::/0 dla IPv6 lub 0.0.0.0/0 dla IPv4). Dzięki czemu jeżeli kilka wpisów (sieci) z tablicy routingu pasuje do adresu docelowego z nagłówka pakietu, wybierany jest wpis najbardziej precyzyjny (o najdłuższym prefixie), a pasująca do każdego adresu trasa domyślna wybierana jest tylko gdy nie ma żadnej lepszej. Może się zdarzyć że kilka wpisów (nawet z tą samą maską) pasuje do adresu docelowego hosta, w takiej sytuacji do wyboru ścieżki używane są inne dane z tablicy routingu (takie jak metryka).</p>
				
				<p>Tablice routingu mogą zawierać wpisy dodawane statycznie (wpisane do konfiguracji danego urządzenia), jak też wpisy dodawane dynamicznie w oparciu o protokołu wymiany informacji routingowych (protokoły routingu) takie jak: IGRP, OSPF, BGP. Protokoły routingu dynamicznego mogą być wykorzystywane m.in. do rozkładania obciążenia na różne łącza, zapewnienia redundancji łącz, blokowania ataków (D)DoS.</p>
				
				<p>Także każdy z hostów ma tablice routingu, typowo składa się z dwóch pozycji – trasy do sieci lokalnej (tej sieci z której adres posiada dany host) wskazującej bezpośrednio na urządzenie sieciowe oraz trasy domyślnej wskazującej na router zapewniający dostęp do innych sieci, nazywany bramką (gateway). Jeżeli router nie posiada adresu w tej samej sieci co host konieczna jest dodatkowa trasa wskazująca poprzez jakie urządzenie dostępny jest router domyślny.</p>
				
				<p>Oprócz opisanego powyżej routingu unicastowego (kierowania do jednego odbiorcy) realizowane są także transmisje:<ul>
					<li><dfn>anycast</dfn> – do dowolnego / najbliższego hosta o danym adresie; zasadniczo jest to transmisja unicast, tyle że adres docelowy nie jest unikalny w skali globalnej a różne routery kieruje te pakiety do różnych hostów docelowych (typowo wybierając najbliższy taki host)</li>
					<li><dfn>multicast</dfn> – do grupy hostów, w tym wypadku (multicastowy) adres IP identyfikuje "kanał nadawczy" a nie unikalny host docelowy</li>
					<li><dfn>broadcast</dfn> – do wszystkich hostów (w ramach danej sieci – nie są routowne), transmisje rozgłoszeniowe można traktować jako szczególny przypadek transmisji multicastowych w których grupa multicastowa obejmuje wszystkie hosty (można je zastąpić takimi transmisjami multicastowymi)</li>
				</ul></p>
			</section>
		</section>
		<!-- END: adresacja IP -->
		<section>
			<h4>Klient-serwer</h4>
			<!-- BEGIN: TCP / UDP -->
			<p>
				W oparciu o protokół IP działają protokoły warstwy transportowej takie jak UDP, TCP, czy też (mniej znane protokoły czasu rzeczywistego, transmisji strumieniowych): RTP, RTCP i SCTP.
				Najprostszym protokołem warstwy transmisji wydaje się być UDP, protokół ten umożliwia przesłanie informacji pomiędzy dwoma hostami IP i nie kontroluje on tego czy została ona przesłana poprawnie.
				Natomiast TCP kontroluje to czy przesłana informacja dotarła do adresata i nie została uszkodzona, a w przypadku problemów informacja wysyłana jest ponownie. TCP w związku z tym w przeciwieństwie do UDP musi otworzyć połączenie i wykorzystywać je do kontroli poprawności przesłania informacji, wymaga zatem przesłania większej liczby pakietów (co może prowadzić do pewnych opóźnień itp).
				W związku z tym TCP używany jest tam gdzie konieczna jest kontrola poprawności transmisji (oraz ponowne wysłanie zgubionego pakietu), UDP tam gdzie nie jest to potrzebne (a liczy się czas).
			</p>
			<p>
				Dodatkowo zarówno UDP jak i TCP na każdym z hostów wyróżniają numeryczny identyfikator dla aplikacji/procesu/usługi będącego odbiorcą czy też nadawcą informacji zwany numerem portu.
			</p>
			<!-- END: TCP / UDP -->
			<p>
				RTP często jest zaliczany jest do warstwy transportowej gdyż działa poniżej typowych protokołów warstwy aplikacji, jednak dane które opisują nie są informacjami systemowymi/sieciowymi a właśnie aplikacyjnymi, ponadto działa on powyżej protokołów transportowych (zazwyczaj nad UDP). Może przenosić w jednej sesji kilka strumieni, ale zazwyczaj dla każdego strumienia tworzona jest osobna sesja (zestaw portów).
				Protokół ten umożliwia identyfikację zawartości pakietu, identyfikację kolejności pakietów w strumieniu. Pozwala także na przepuszczanie ruchu przez mostki maskujące oryginalne adresy, zmieniające medium, replikujące strumień (replikowany unicast, który wydaje się być bardzo dobrym rozwiązaniem gdy z jakiś powodów multicast nie może zadziałać), czy też nawet łączące strumienie z kilku źródeł. Współpracujący z nim RTCP służy do przesyłania raportów z informacjami o stratach, opóźnieniach itp oraz wzajemnej synchronizacji mediów pomiędzy strumieniami - np. synchronizacji audio z wideo).
			</p>
		</section>
		<section>
			<!-- BEGIN: Polularne usługi -->
			<h4>Polularne usługi</h4>
			<p>
				W ramach sieci mogą być realizowane różne usługi w oparciu o różne protokoły warstwy aplikacyjnej. Standardowe usługi posiadają zdefiniowane domyślne adresy portów dla swoich protokołów. Wśród usług i protokołów sieciowych należy wymienić przynajmniej:
				<ul>
					<li>DNS (Domain Name System) - odpowiedzialny za system mapujący nazwy alfanumeryczne hostów na adresy IP.
						Domeny posiadają budowę hierarchiczną / drzewiastą (precyzja rośnie od prawej do lewej, a kolejne poziomy oddzielane są kropkami).
						Realizacja odpowiedzi na zapytanie DNS wygląda następująco:
						<ol>
							<li>host kieruje zapytanie do określonego w jego konfiguracji serwera "rozwijającego" DNS (DNS resolver),</li>
							<li>serwer taki sprawdza w swojej pamięci podręcznej czy zna odpowiedź na to zapytanie (i nie jest ona przeterminowana - nie upłynął czas TTL od odnalezienia), jeżeli nie ma jej w swojej pamięci to</li>
							<li>serwer taki zna adresy głównych serwerów DNS (root serwerów) zawierających informacje na temat serwerów obsługujących domeny najwyższego rzędu i kieruje do jednego z nich zapytanie o serwer obsługujący skrajnie prawą część adresu (np. <var>.org</var>),</li>
							<li>do otrzymanego serwera kierowane jest zapytanie o większą część adresu (np. <var>eu.org</var>),</li>
							<li>itd. aż do uzyskania odpowiedzi o pytany adres</li>
						</ol>
					</li>
					<li>mechanizmy auto konfiguracji hostów - DHCP, rozgłaszanie informacji routingowej poprzez ICMPv6 (protokół warstwy 3)</li>
					<li>WWW - udostępnianie treści z użyciem protokołu HTTP</li>
					<li>pocztę elektroniczną - przesyłanie wiadomości (protokoły SMTP, IMAP, POP)</li>
					<li>komunikację natychmiastową i telefonię IP (protokoły SIP, XMPP, IAX)</li>
					<li>SSH - zdalny, szyfrowany dostęp do systemów IT, przesył plików oraz tunelowanie innych usług</li>
				</ul>
				Na uwagę zasługuje fakt że większość z wymienionych protokołów warstwy aplikacyjnej to protokoły tekstowe (istotne wyjątki stanowią DNS, DHCP i SSH).</p>
			<!-- END: Polularne usługi -->
		</section>
		<section>
			<h4>Translacja adresów</h4>
			<p>Routery oprócz zwykłego kierowania pakietów na odpowiednie łącze, mogą także modyfikować adresy IP i numery portów. Mechanizm ten określany jest mianem translacji adresów sieciowych (Network Address Translation). Modyfikowaniu mogą ulegać zarówno źródłowe (SNAT) jak i docelowe (DNAT) adresy IP, jak też numery portów protokołów warstwy transportowej (takich jak TCP, czy UDP).</p>
			<p>Translacja może odbywać się w oparciu o stałe reguły (dany adres, port lub zestaw adres+port zawsze mapowany jest na takie same wartości) jak też w sposób dynamiczny, gdzie mapowanie odbywa się np. na grupę adresów lub pojedynczy adres i dynamicznie dobierane porty. Dynamiczne mapowanie wymaga od routera śledzenia przechodzących przez niego połączeń i ich stanu, celem umożliwienia przekazania pakietu z odpowiedzią oraz zwolnienia mapowania po zakończeniu połączenia TCP.</p>
		</section>
		<section>
			<h4>Filtracja pakietów</h4>
			<p>Względy bezpieczeństwa często wymuszają filtrację ruchu sieciowego docierającego do danego hosta lub przechodzącego przez router. Filtracja taka może odbywać się zarówno w oparciu o dane z nagłówków IP (np. adresy źródłowe i docelowe), dane z nagłówków warstwy transportowej (np. numery portów TCP lub UDP), jak również informację z systemu śledzenia połączeń czy też zawartość samego pakietu.</p>
		</section>
		<section>
			<h4>Tunelowanie i VPN</h4>
			<p>Możliwa jest enkapsulacja pakietów IP w pakietach innych protokołów (w szczególności także IP). Pozwala to na realizację różnego rodzaju tuneli IP. Przykładem takiego tunelu jest VPN zapewniający szyfrowany dostęp (w warstwie trzeciej - IP lub nawet w warstwie drugiej - LAN) do jakiejś innej sieci.</p>
		</section>
		<section>
			<h4>Multicast</h4>
			<p>
				Multicast jest transmisją jeden do wielu, pozwalającą na uniknięcie powielania identycznych pakietów (różniących się tylko adresem odbiorcy). Metoda ta jest użyteczna np. przy streamingu audio-video na żywo.
				Multicastowy adres IP identyfikuje dynamiczną (mogącą zmieniać się w czasie) grupę odbiorców i jest on przydzielany danej transmisji przez jej nadawcę, a nie przyznawany administracyjnie konkretnemu odbiorcy.
				W związku z tym często wszystkie pakiety adresowane do danej grupy multicastowej (mające taki sam multicastowy adres docelowy) pochodzą od tego samego hosta (a więc mają taki sam unicastowy adres źródłowy).
				Zależność ta została wykorzystana w <dfn>source-specific multicast</dfn>, który eliminuje problem przydzielania adresów multicastowych nadawcom – dowolnego adresu multicastowego z puli przeznaczonej na potrzeby source-specific multicast może użyć każdy, a kanał multicastowy (grupa odbiorców) identyfikowana jest w oparciu o dwa adresy (unicastowy nadawcy i multicastowy odbiorcy).
			</p>
			<p>
				W celu obsłużenia transmisji multicastowych router musi posiadać informacje o aktualnie "zasubskrybowanych" przez jego klientów transmisjach multicastowych.
				Posiadając takie dane (czyli adres multicastowy na który kierowane są pakiety danej transmisji i ewentualnie unicastowy adres źródłowy z którego są wysyłane) może on pozyskać stosowne transmisje od routerów z którymi jest połączony i przekazać je swoim klientom.
				Do poinformowania routera o żądaniu dostarczenia transmisji multicastowej (a także do przekazania informacji o zakończeniu odbioru takiej transmisji) hosty wykorzystują protokół Internet Group Management Protocol (dla IPv4) lub Multicast Listener Discovery (dla IPv6).
				Celem obsługi zaprzestania transmisji gdy host nie poinformował o zakończeniu odbioru, router z wykorzystaniem tych protokołów co pewien czas zadaje pytanie czy nadal są hosty zainteresowane dana transmisją.
			</p>
		</section>
		<section>
			<h4>Quality of Service</h4>
			<p>QoS są to techniki gwarantujące jakość usługi. Najczęściej stosowaną techniką zaliczaną do QoS jest dynamiczny podział przepustowości łącza z wykorzystaniem algorytmów takich jak: HTB (Hierarchical Token Bucket), CBQ (Class Based Queueing). Nie jest to jednak prawdziwy QoS, gdyż mechanizmy te to coś więcej niż tylko prosty podział pasma. O QoS'ie możemy zaczynać mówić gdy system kolejkowania uwzględnia priorytety dla pewnych typów ruchu (m.in. na podstawie pola ToS - Type of service). Kolejki priorytetowe mogą być realizowane jako wagowe - cyklicznie z każdej klasy wysyłamy proporcjonalnie do wagi, lub bez-wagowy (klasa ważniejsza może zagłodzić klasy o mniejszym priorytecie, gdyż brany jest z ważniejszej dopóki są lub nie pojawią się jeszcze ważniejsze). Istnieją dwie podstawowe architektury systemów QoS:<ul>
				<li>DiffServ - nie ma ścisłych gwarancji dla jakiegokolwiek strumienia, na brzegu użytkownik negocjuje SLA i ruch jest kontrolowany pod względem tego SLA (m.in. ustawianie i kontrola pola ToS). Może występować także zarządca pasma (Bandwidth Broker), z którym klienci komunikują się przy pomocy protokołu RSVP (Resource Reservation Protocol) i negocjują z nim kontrakty SLA, natomiast sam BB dokonuje rezerwacji zasobów w routerach i kontroluje ich stan (zazwyczaj z wykorzystaniem protokołu Common Open Policy Service).</li>
				<li>IntServ - odbiorca w oparciu o informacje uzyskane od nadawcy na temat parametrów transmisji dokonuje rezerwacji zasobów w wszystkich routerach na ścieżce łączącej go z nadawcą (wykorzystuje do tego protokół RSVP), każdy z routerów decyduje czy może spełnić te wymagania (gdy jeden nie może cała operacja nie udaje się). Każdy strumień negocjowany jest indywidualnie, poprzez mechanizm Addmision Control (podawane są specyfikacje filtru - jak identyfikować ten ruch, specyfikacje przepływu, itd), ponadto informacje o rezerwacji muszą być okresowo odnawiane. Wyróżnia się klasy ruchu: Best Effort (standardowa), Guaranteed Service (gwarancja dostępności pasma i opóźnienia), Control Load Service (zapewniamy mało obciążony kanał, ale bez gwarancji).</li>
			</ul></p>
		</section>
	</section>
</section>

<section>
	<h2>Systemy operacyjne</h2>
	<section>
		<h3>Co robi system operacyjny?</h3>
		<p>System operacyjny jest oprogramowaniem odpowiedzialnym za zarządzanie zasobami systemu komputerowego (sprzętem, ale nie tylko) oraz uruchomionymi na nim aplikacjami. Do najistotniejszych zadań systemu operacyjnego zalicza się podział czasu procesora i szeregowanie zadań oraz zarządzanie pamięcią - w szczególności obsługa pamięci wirtualnej, najczęściej z wykorzystaniem mechanizmu stronicowania.</p>
		
		<p>Oprócz tego system zajmuje się także zarządzaniem plikami, wejściem/wyjściem (najczęściej jest ono realizowane w oparciu o przerwania (IRQ), ale znane są także modele programowego we/wy polegającego na aktywnym czekaniu), obsługą urządzeń (wejście/wyjście, sterowniki, dostęp), obsługą sieci (stos protokołów sieciowych), itd. Część zadań realizowana jest z minimalnym udziałem procesora (a więc także i systemu) jest to na przykład transfer danych w trybie DMA polegający na tym iż dane kopiowane są całymi blokami bez udziału procesora do/z pamięci (system zajmuje się tylko inicjacją transmisji). Należy tu jednocześnie zaznaczyć iż w przypadku nie stosowania tej technologii dane też kopiowane są pomiędzy dyskiem a procesorem całymi blokami (minimum sektor) gdyż dysk (w odróżnieniu od pamięci operacyjnej) nie jest bezpośrednio dostępny dla procesora.</p>
		
		<p>Współczesne systemy korzystają z co najmniej dwóch poziomów pracy - uprzywilejowanego poziomu "nadzorcy" w którym działa jądro systemu operacyjnego oraz trybu użytkownika. Operacje I/O muszą odbywać się w trybie uprzywilejowanym. Również pamięć posiada obszar chroniony, w którym umieszczany jest m.in. tablica wektorów przerwań (inaczej zmiana adresu w tym wektorze mogłaby doprowadzić do przejęcia systemu w trybie uprzywilejowanym).</p>
		
		<section>
			<h4>Procesy i szeregowanie zadań</h4>
			
			<p>Istotną rolą systemu operacyjnego w zarządzaniu procesami (obok czynności administracyjnych jak ich tworzenie powielanie, usuwanie, czy też wstrzymywanie itp) jest zapewnienie ochrony pamięci (każdy proces może pisać po swojej i ewentualnie współdzielonej gdy dostał do tego prawo) oraz procesora (przerwanie zegarowe powoduje wywołanie planisty, który ustala jaki proces dostanie następny kwant czasu procesora). Niektóre systemy wyróżniają obok procesów także wątki, które różnią się od nich współdzieloną (między wątkami jednego procesu) pamięcią i zasobami (np. otwartymi plikami). System operacyjny zapewnia także zestaw usług i funkcji (wywołań) systemowych zapewniających pośrednictwo między interfejsem trybu użytkownika a sprzętem.</p>
			
			<p>Istotnym zadaniem systemu operacyjnego jest przeciwdziałaniem tzw. blokadom, czyli sytuacji gdy dwa lub więcej procesów blokują się wzajemnie w oczekiwaniu na zasoby (a ma zasób X, którego potrzebuje b aby zwolnić zasób Y, którego potrzebuje a do zwolnienia X). Realizowane to może być na kilka sposobów:</p>
			<ul>
				<li>zapobieganie blokadzie (czyli niedopuszczenie do zajścia warunków koniecznych) - np. poprzez konieczność deklarowania wszystkich zasobów na początku, zwalniania przydzielonych zasobów przed zgłoszeniem zapotrzebowania na następne</li>
				<li>unikanie blokady (czyli określamy maksymalne zapotrzebowanie i tak przydzielamy zasoby aby uniknąć zajścia blokady) - np. poprzez kontrolę czy po spełnieniu żądania dalej będziemy działać w stanie "bezpiecznym", tj takim że istnieje sekwencja (zwana bezpieczną) w której maksymalne zapotrzebowanie każdego procesu może być spełnione w oparciu o zasoby zwolnione przez procesy będące wcześniej w tej sekwencji oraz zasoby wolne</li>
				<li>wykrywanie i usuwanie blokady gdy do niej doszło</li>
			</ul>
			
			<p>Planista procesora, czyli fragment systemu odpowiedzialny za przydzielanie procesora procesom, może pracować w trybie z wywłaszczaniem lub bez. W tym pierwszym wypadku proces otrzymuje kwant czasu procesora który może wykorzystać w całości (wtedy przejdzie z stanu wykonywania w stan gotowości) lub z niego wcześniej zrezygnować (gdy np. czeka na I/O, wtedy przejdzie z stanu wykonywania w stan oczekiwania). W drugim przypadku proces wykonuje swój kod do momentu aż sam odda procesor. Forma ta zbliżona jest do wykorzystywanej w szeregowaniu czasu rzeczywistego - proces będzie wywłaszczony tylko przez proces o wyższym priorytecie i będzie to natychmiastowe (przy najbliższym przerwaniu zegarowym). Istnieje wiele algorytmów szeregowania takich jak:</p>
			<ul>
				<li>FCFS - pierwszy zgłoszony = pierwszy obsłużony</li>
				<li>SJF - najkrótszy zgłoszony będzie pierwszym wykonanym (wersja z wywłaszczaniem - SRTF - gdy nowy najkrótszy pozostały), algorytm raczej nie do zastosowania praktycznego - trzeba by przewidywać długość wykonania</li>
				<li>priorytetowe - zawsze o najwyższym priorytecie (jak wspomniałem wyżej wykorzystywane w systemach real-time</li>
				<li>rotacyjne - każdy po kawałku, potem na koniec kolejki</li>
				<li>kolejki wielopoziomowe - system z priorytetami, podziałem czasu pomiędzy kolejki, przenoszeniem procesów między kolejkami, ...</li>
			</ul>
		</section>
		
		<section>
			<h4>Zarządzanie pamięcią</h4>
			
			<p>Drugą podstawową funkcją systemu operacyjnego, wspomnianą na początku, jest zarządzanie pamięcią. Zarządzanie pamięcią polega na odpowiednim mapowaniu adresów logicznych (używanych przez procesy) na adresy fizyczne (używane przez procesor), korzysta ono z wsparcia sprzętowego ze strony procesora.
				Jest to najczęściej realizowane w oparciu o wspomniany mechanizm stronicowania. Polega to na podziale pamięci dostępnej pamięci fizycznej na jednakowe bloki zwane ramkami oraz podziale pamięci logicznej na jednakowe bloki (o tej całej wielkości co ramki) zwane stronami. Strony które są wykorzystywane przez program są mapowane na dowolne ramki pamięci fizycznej (w przypadku gdy dana strona nie zamapowana - w zależności od okoliczności błąd braku strony lub błąd ochrony strony).
				Rozwiązuje to problem fragmentacji zewnętrznej, polegającej na braku spójnego obszaru pamięci o żądanej długości pomimo iż łączna ilość wolnej pamięci jest dostateczna, jednak nie rozwiązuje problemu fragmentacji wewnętrznej, polegającej na przydzielaniu zbyt dużych fragmentów pamięci dla procesu (a wręcz można powiedzieć że go pogłębia).
				Mechanizm ten wymaga trzymania tablicy wolnych ramek, tablicy stron dla każdego procesu (zawierającej przypisania mapowań stron danego procesu na ramki) oraz wykonywania tłumaczenia adresów logicznych (strona + przesunięcie na stronie). Także sama tablica stron procesu procesu może być stronicowania (mamy tablicę która informuje nas że przypisania stron w danym zakresie adresów są przechowywane w jakiejś ramce).</p>
			
			<p>Strony i ramki mogą być współdzielone pomiędzy procesami (np. przy rozgałęzianiu procesu strony są kopiowane dopiero gdy zajdzie taka potrzeba). W przypadku braku miejsca w pamięci fizycznej wybrane strony nieaktywnego aktualnie procesu mogą być umieszczane na dysku (swap). Niekiedy może to powodować szamotanie procesu polegające na zbyt dużej liczbie wymian stron. Zawsze jednak prowadzi to do konieczności ustalania które strony najlepiej jest przenieść na dysk. Optymalne byłoby przenoszenie tych które najdłużej nie będą potrzebne (jednak z oczywistych względów jet to praktycznie nie do zrealizowania). Stosuje się różne algorytmy tego wyboru:</p>
			<ul>
				<li>FIFO - usuwamy najdłużej będącą w pamięci</li>
				<li>LRU - usuwanie tej do której najdawniej się odwoływano (licznik czasu, bit odniesienia, bit odniesienia w określonym czasie, bit modyfikacji)</li>
				<li>LFU - usuwamy z najmniejszą liczbą odwołań</li>
				<li>MFU - usuwamy z dużą liczbą odwołań</li>
			</ul>
			
			<p>Alternatywną (i mniej wymagającą) wobec stronicowanie metodą zarządzania pamięcią jest segmentacja. W przypadku architektury x86 jest ona zawsze wykorzystywana jednak może być przykryta dużym segmentem na którym wykorzystujemy stronicowaniem. Wspomniany już mechanizm pamięci wirtualnej często rozumiany jest tylko jako stronicowaniem (lub segmentacja) na żądanie. Polega to na tym iż strony mapowane są na ramki dopiero w momencie zapisu do segmentu pamięci należącego do </p>
		</section>
	</section>
	<section>
		<h3>Proces uruchamiania komputera</h3>
		<p>Po otrzymaniu sygnału resetu (także przy uruchamianiu systemu - "Power-on Reset") procesor po inicjalizacji rejestrów zaczyna wykonywanie kodu znajdującego się pod jakimś ustalonym adresem (typowo w wbudowanej lub zewnętrznej pamięci typu ROM lub Flash). W zależności od danej architektury / procesrora może to być m.in.: bezpośrednio kod programu użytkownika, wbudowany bootloader danego procesora umożliwiający dalsze ładowanie np. z karty SD, zewnętrzny niskopoziomowy bootloader (np. u-boot).</p>
		
		<p>W przypadku architektur zgodnych z x86 jest to BIOS, który po zakończeniu procesu inicjalizacji sprzętu i testów rozruchowych ładuje do pamięci kod znajdujący się w pierwszym sektorze dysku twardego (sektorze rozruchowym rozpoczynającym się od adresu zerowego) i uruchamia go (przekazuje do niego kontrolę).</p>
		
		<p>W przypadku sektorów rozruchowych typu MBR (i kompatybilnych z nim), kod ten może liczyć maksymalnie 446 bajtów (gdyż na kolejnych pozycjach znajduje się tablica partycji) i jego zadaniem jest załadowanie i uruchomienie pozostałej części programu rozruchowego (musi znać jej położenie na dysku). Pozostała część programu rozruchowego może znajdować się tuż za MBR (w przerwie pomiędzy MBR a pierwszą partycją - dla tablicy partycji MBR/msdos), w dedykowanej partycji BIOS boot partition (dla tablicy partycji GPT) lub w partycji oznaczonej jako bootowalna. Część ta zawiera moduły pozwalające na dostęp do systemu plików zawierającego konfigurację, obraz jądra, itp oraz informację o jego położeniu (dysk, partycja, ścieżka).</p>
		
		<p>W przypadku komputerów opartych na UEFI firmware odpowiedzialny jest za zinterpretowanie tablicy partycji (GPT) i załadowanie programu rozruchowego z pliku znajdującego się na specjalnej partycji EFI (EFI System partition) z systemem plików FAT32. W pliku tym umieszczana jest całość (obie opisane powyżej części programu rozruchowego).</p>
		
		<p>Start systemu rozpoczyna się od załadowania do pamięci obrazu jądra wraz z parametrami oraz (opcjonalnie) initrd i przekazania kontroli do jądra przez program rozruchowy (np. GRUB). W przypadku jądra linuxowego i korzystania z initrd obraz ten przekształcany jest na RAM-dysk w trybie zapisu-odczytu i montowany jako rootfs z którego uruchamiany jest <code>/sbin/init</code> (którego podstawowym zadaniem jest zamontowanie właściwego rootfs). Po jego zakończeniu (lub od razu gdy nie używamy initrd) uruchamiany jest program wskazany w opcji <code>init=</code> jądra (domyślnie typowo <code>/sbin/init</code>) z rootfs wskazanego w opcji <code>root=</code> jądra. W opcji <code>init=</code> można wskazać dowolny program lub skrypt (uruchomiony zostanie z prawami root'a).</p>
	</section>
	<section>
		<h3>Systemy "unix-owate"</h3>
		<p>Jest to grupa systemów operacyjnych, będących (przynajmniej w jakimś stopniu) zgodnych z specyfikacją POSIX / Single UNIX Specification. Charakteryzują się zbliżonym zbiorem wywołań systemowych dostępnych z poziomu jęzka C oraz funkcji biblioteki standardowej C, co ułatwia zapewnienie przenośności oprogramowania (w postaci źródłowej). Zapewniają podobny zbiór podstawowych komend linii poleceń (konsoli).</p>
		<!-- BEGIN: Struktura katalogów -->
		<p>
			Systemy unix'owe posiadają drzewiasty system plików zaczynający się w katalogu głównym oznaczanym przez ukośnik (<code>/</code>), w którym zamontowany jest główny system plików (rootfs), inne systemy plików mogą być montowane w kolejnych katalogach. Do najistotniejszych katalogów należy zaliczyć: <dl class="cmdlist">
				<dt><dfn>/bin</dfn></dt>
					<dd>zawierający pliki wykonywalne podstawowych programów</dd>
				<dt><dfn>/sbin</dfn></dt>
					<dd>zawierający pliki wykonywalne podstawowych programów administracyjnych</dd>
				<dt><dfn>/lib</dfn></dt>
					<dd>zawierający pliki podstawowych bibliotek</dd>
				<dt><dfn>/usr</dfn></dt>
					<dd>zawierający oprogramowanie dodatkowe (wewnętrznie ma podobną strukturę do głównego - tzn. katalogi <dfn>/usr/bin</dfn>, <dfn>/usr/sbin</dfn>, <dfn>/usr/lib</dfn>, itd)</dd>
				
				<dt><dfn>/etc</dfn></dt>
					<dd>zawierający konfiguracje ogólnosystemowe</dd>
				<dt><dfn>/var</dfn></dt>
					<dd>zawierający dane programów i usług (takie jak kolejka poczty, harmonogramy zadań, bazy danych)</dd>
				<dt><dfn>/home</dfn></dt>
					<dd>zawierający katalogi domowe użytkowników (często montowany z innego systemu plików, dlatego też root ma swój katalog domowy w <code>/root</code>, aby był dostępny nawet gdy takie montowanie nie doszło do skutku)</dd>
				<dt><dfn>/tmp</dfn></dt>
					<dd>zawierający pliki tymczasowe (typowo czyszczony przy starcie systemu); w Linuxie występuje też <code>/run</code> przeznaczony do trzymania danych tymczasowych działających usług takich jak numery pid, blokady, itp</dd>
				
				<dt><dfn>/dev</dfn></dt>
					<dd>zawierający pliki reprezentujące urządzenia; w Linuxie występuje też <code>/sys</code> zawierający informacje i ustawienia dotyczące m.in. urządzeń</dd>
				<dt><dfn>/proc</dfn></dt>
					<dd>zawierający informacje o działających procesach (w Linuxie także interfejs konfiguracyjny dla wielu parametrów jądra)</dd>
			</dl>
			Pliki i katalogi których nazwa rozpoczyna się od kropki traktowane są jako pliki ukryte.
		</p>
		<p>Z punktu widzenia programisty czy też użytkownika (prawie) wszystko jest plikiem, których istnieją różne rodzaje (zwykły plik, katalog, urządzenie znakowe, urządzenie blokowe, link symboliczny, kolejka FIFO, ...); pewnym wyjątkiem są urządzenia sieciowe (które nie mają reprezentacji w systemie plików (ale gniazda związane z nawiązanymi połączeniami obsługuje się zasadniczo tak jak pliki).</p>
		<!-- END: Struktura katalogów -->
		
		<section>
			<h4>Najważniejsze polecenia</h4>
			<p>Wiele z poniższych komend stanowi standardowe polecenia określone w POSIX / Single UNIX Specification, co gwarantuje ich obecność na kompatybilnych systemach (jednak nie jest to pełna lista poleceń wymaganych przez POSIX). Część z nich jest powszechnie dostępnym, wieloplatformowym oprogramowaniem dla systemów "unix-owatych". Niektóre (zwłaszcza związane z działaniami administracyjnymi) są specyficzne dla Debiana lub Linuxa.</p>
			
			<section>
				<h5>Uzyskiwanie pomocy</h5>
				<dl class="cmdlist">
					<dt><dfn>man</dfn> <var>[nazwa polecenia]</var></dt>
						<dd>wyświetla stronę podręcznika systemowego na temat wskazanego polecenia, funkcji systemowej, pliku konfiguracyjnego</dd>
					<dt><dfn>pinfo</dfn> <var>[nazwa polecenia]</var> lub <dfn>info</dfn> <var>[nazwa polecenia]</var></dt>
						<dd>wyświetla stronę nowego podręcznika systemowego na temat wskazanego polecenia</dd>
					<dt><dfn>apropos</dfn> <var>[tekst]</var></dt>
						<dd>wyszukiwanie w opisach stron podręcznika systemowego<br />
							<code>apropos -s 1 ''</code> pozwala zapoznać się z spisem wszystkich stron w rozdziale pierwszym (co jest w którym rozdziale można zobaczyć w <code>man man</code>)
						</dd>
				</dl>
				<p>Większość poleceń obsługuje także opcje <code>--help</code> lub <code>-h</code>, które wyświetlają informację na temat ich użycia. W tym miejscu warto też zauważyć że typowo opcje krótkie (pojedyncza litera) poprzedzane są pojedynczym myślnikiem (i po jednym myślniku może wystąpić kilka kolejnych opcji), natomiast opcje długie poprzedzane są dwoma myślnikami.</p>
				<p>Zarówno w tekstach pomocy jak i w tym dokumencie stosowana jest konwencja polegająca na oznaczaniu opcjonalnych argumentów poprzez umieszczanie ich w nawiasach kwadartowych (jeżeli podajemy ten argument do komendy nie obejmujemy go już tymi nawiasami) oraz rozdzielaniu alternatywnych opcji przy pomocy~<code>|</code>. Np. <code>a [b] c|d</code> oznacza iż polecenie <code>a</code> wymaga argumentu postaci <code>c</code> albo <code>d</code>, który może być poprzedzony argumentem <code>b</code>.</p>
			</section>
			<section>
				<h5>Powłoka (i okolice)</h5>
				<dl class="cmdlist">
					<dt><dfn>bash</dfn> <var></var></dt>
						<dd>popularna powłoka (interpreter poleceń) zgodna z sh, zapewnia m.in. obsługę zmiennych (zasadniczo napisowych) oraz znaków uogólniających takich jak:<br />
							<code>?</code> oznaczający dowolny znak<br />
							<code>*</code> oznaczający dowolny (także pusty) ciąg znaków<br />
							<code>[<var>a-z AD</var>]</code> oznaczający dowolny znak z wymienionych w zbiorze ujętym w nawiasach kwadratowych, zbiór może być definiowany z użyciem zakresów, np. <var>a-z AD</var> oznacza dowolną małą literę od a do z włącznie, spację, dużą literą A lub D<br />
							<code>[!<var>a-z</var>]</code> oznaczający dowolny znak z wyjątkiem znaków wymienionych w podanym zbiorze, zbiór może być definiowany z użyciem zakresów, np. <var>a-z</var> oznacza dowolną małą literę od a do z włącznie<br />
							Argumenty linii poleceń przekazywane do wywoływanych przez powłokę poleceń rozdzielane są dowolną ilością spacji. Jeżeli argument ma być napisem zawierającym spacje konieczne jest zabezpieczenie ich przy pomocy odwrotnego ukośnika (<code>\</code>, np. <code><var>aaa</var>\ <var>bbb</var></code>) lub ujęcie całego napisu w cudzysłowie pojedynczym (<code>'</code>, np. <code>'<var>aaa bbb</var>'</code>) lub podwójnym (<code>"</code>, np. <code>"<var>aaa bbb</var>"</code>). Oba typy cudzysłowów zabezpieczają przed rozwijaniem znaków uogólniających (zastępowaniem napisu ze znakami listą pasujących nazw / ścieżek). Cudzysłów pojedynczy (w odróżnieniu od podwójnego) zabezpiecza także przed interpretacją umieszczonych wewnątrz innych znaków specjalnych takich jak czy odwołania do zmiennych.
						</dd>
					<!-- BEGIN: ssh -->
					<dt><dfn>ssh</dfn> <var>[user@]host</var></dt>
						<dd>umożliwia uzyskanie powłoki zdalnego systemu poprzez szyfrowane połączenie, przydatne opcje:<br />
							<code>-L <var>portLokalny</var>:<var>hostZdalny</var>:<var>portZdalny</var></code> tworzy tunel przekierowujący dane kierowane na <var>portLokalny</var> komputera na którym działa klient ssh do portu <var>portZdalny</var> na serwerze <var>hostZdalny</var> poprzez serwer SSH (przydatne gdy <var>hostZdalny</var> jest osiągalny z <var>hostSSH</var> ale nie z komputera lokalnego)<br />
							<code>-D <var>port</var></code> tworzy tunel dynamiczny na wskazanym porcie (może on być użyty jako proxy typu SOCKS np. w Firefoxie w celu zapewnienia dostępu do zasobów WWW dostępnych z serwera SSH a niedostępny z komputera lokalnego)<br />
							<code>-p <var>port</var></code> określa inny niż domyślny port serwera SSH<br />
							<code>-X</code> aktywuje przekazywanie komend X serwera ze strony zdalnej do klienta (pozwala na uruchomienie po stronie zdalnej aplikacji z GUI, które zostanie wyświetlone na lokalnym X serwerze)
						</dd>
					<!-- END: ssh -->
					<dt><dfn>tmux</dfn> lub <dfn>screen</dfn></dt>
						<dd>multiplexer terminala - pozwala na uzyskanie wielu okien konsoli (także wyświetlanych jedno obok drugiego) na pojedynczym terminalu; ponadto pozwalają na odłączanie i podłączanie sesji, co pozwala na łatwe pozostawienie działającego programu po wylogowaniu i powrót do niego później</dd>
					<dt><dfn>watch</dfn> <var>[opcje]</var> <var>polecenie</var></dt>
						<dd>okresowo uruchamia <var>polecenie</var> i wyświetla jego wynik, opcja <code>-i</code> pozwala na określenie co ile sekund ma aktualizować wynik polecenia</dd>
					<dt><dfn>script</dfn></dt>
						<dd>tworzy zapis sesji (stdin, stdout, ...)</dd>
				</dl>
			</section>
			<section>
				<h5>wyświetlanie i edycja plików</h5>
				<dl class="cmdlist">
					<!-- BEGIN: vi i vim -->
					<dt><dfn>vim</dfn> lub <dfn>vi</dfn></dt>
						<dd>vi jest chyba najbardziej zaawansowanym edytorem, którego obecność gwarantuje standard POSIX.
							vim jest mocno rozbudowanym jego klonem, oferującym bardzo zaawansowane funkcjonalności, powszechnie stosowanym jako zamiennik oryginalnego vi.
							vim obsługuje 3 podstawowe tryby pracy: komend (służący do wydawania opisanych niżej poleceń), wizualny (służący do zaznaczania i wydawania niektórych komend), edycji (wstawiania/nadpisywania - służący do wprowadzania tekstu).
							Podstawowa klawiszologia:<br />
							<code>Esc</code> powrót do trybu komend<br />
							<code>i</code> tryb wstawiania<br />
							<code>R</code> tryb zastępowania<br />
							<code>Insert</code> zmiana trybu wstawiania i zastępowania<br />
							<code>v</code> tryb wizualny (umożliwia zaznaczenie przy pomocy strzałek)<br />
							
							<code>y</code> skopiuj; <code>d</code> - wytnij (skopiuj i usuń)
								po <code>y</code>, <code>d</code> można podać np. <code>20l</code> lub <code>20[strzałka w prawo]</code> co oznacza 20 kolejnych znaków, <code>2w</code> oznacza dwa słowa<br />
							<code>x</code> wytnij (skopiuj i usuń) znak (może być poprzedzone ilością znaków do wycięcia)<br />
							<code>yy</code> skopiuj linię; <code>dd</code> - wytnij (skopiuj i usuń)
								w obu wypadkach może być poprzedzone ilością linii do skopiowania/wycięcia<br />
							
							<code>p</code> wkleja po; <code>P</code> - wkleja przed<br />
							<code>u</code> cofa ostatnią operację<br />
							
							<code>/</code> szukanie<br />
							<code>n</code> wyszukanie następnego wystąpienie; <code>N</code> wyszukanie poprzedniego wystąpienie<br />
							<code>G</code> przejście do wskazanej linii, numer podajemy przed G, 0 oznacza ostatnią linię w pliku, więc <code>0G</code> spowoduje przejście do niej
							
							<code><var>:[zakres]</var>s@<var>regexp</var>@<var>napis</var>@[g]</code> wyszukaj i zastąp wyrażenie regularne <var>regexp</var> przez <var>napis</var>;
								<var>zakres</var> może być:
									numerem linii,
									przedziałem z numerami linii postaci <code><var>pierwsza</var>,<var>ostatnia</var></code>, gdzie:
										<code>.</code> oznacza bieżącą linię,
										<code>$</code> oznacza ostatnią linię w pliku,
										wartość numeryczna poprzedzona <code>+</code> oznacza tyle kolejnych linii od bieżącej, a poprzedzona <code>-</code> przed bieżącą,
									znakiem <code>%</code> (co oznacza cały plik),
									zakresem zaznaczonym w trybie wizualnym;
								podanie opcji <var>g</var> powoduje zastępowanie wszystkich wystąpień a nie tylko pierwszego;
								znak <code>@</code> pełni rolę separatora i może zostać zamiast niego użyty inny znak
							
							<code>:e <var>ścieżka</var></code> otwarcie wskazanego pliku<br />
							<code>:w</code> zapis (można także podać ścieżkę pod jaka ma zostać zapisany plik)<br />
							<code>:q</code> wyjście<br />
							<code>:q!</code> wyjście bez zapisywania<br />
							<code>:wq</code> zapis i wyjście<br />
							
							<code>:n</code> - następny plik<br />
							<code>:N</code> - poprzedni plik<br />
							<code>:split</code> - podział okna<br />
							<code>:vs</code> - pionowy podział okna<br />
							<code>Ctrl</code>+<code>W</code> a następnie strzałka - przełączanie między oknami<br />
							
							<code>:%!xxd</code> pokazanie wartości numerycznych i umożliwienie edycji pliku jako binarnego;
							<code>:%!xxd -r</code> powrót do normalnej edycji
						</dd>
						<!-- END: vi i vim -->
					<dt><dfn>less</dfn> lub <dfn>more</dfn></dt>
						<dd>przeglądanie tekstu ekran po ekranie,<br />
							less posiada większe możliwości od more (w szczególności posiada możliwość przeglądanie dokumentu w tył), przydatne opcje:<br />
								<code>-X</code> nie czyści ekranu przy wychodzeniu z less'a (całość historii wyświetlania pliku pozostaje w historii terminala)<br />
								<code>-F</code> automatycznie kończy gdy wyświetlany tekst mieści się na jednym ekranie
						</dd>
						
					<dt><dfn>bvi</dfn> </dt>
						<dd>wzorowany na vim'ie edytor hexalny (binarny)</dd>
					<dt><dfn>od</dfn> lub <dfn>xxd</dfn> lub <dfn>hexdump</dfn></dt>
						<dd>wypisywanie plików interperowanych binarnie w postaci liczby oktalne, szesnastkowe, itd, przykłady:<br />
							<code>hexdump -e <var>'1/4 "%010d " 1/2 "%05d " 2/1 "%02x " "\n"'</var> <var>plik</var></code> każde kolejne 8 bajtów pliku zostanie zinterpretowane jako:
								jedna liczba 32 bitowa liczba całkowita (4 bajty), 16 bitowowa liczba całkowita (2 bajty) i dwie liczby jedno bajtowe (wyświetlane szesnastkowo)
						</dd>
				</dl>
			</section>
			<section>
				<!-- BEGIN: Operacje na systemie plików -->
				<h5>Operacje na systemie plików</h5>
				<h6>katalog roboczy</h6>
				<dl class="cmdlist">
					<dt><dfn>cd</dfn> <var>[ścieżka]</var></dt>
						<dd>zmiana bieżącego katalogu,<br />
							warto zauważyć, iż katalogi w ścieżce oddzielamy ukośnikami <code>/</code>, bieżący katalog oznaczamy kropką <code>.</code>, nadrzędny oznaczamy dwiema kropkami <code>..</code>,<br />
							ścieżki zaczynające się od ukośnika <code>/</code> oznaczają ścieżki bezwzględne (od korzenia systemu plików), pozostałe oznaczają ścieżkę względną (wyrażoną względem bierzącego katalogu),<br />
							katalog domowy oznacza się tyldą <code>~</code>
						</dd>
					<dt><dfn>pwd</dfn></dt>
						<dd>wyświetla ścieżkę do bieżącego katalogu</dd>
				</dl>
				
				<h6>wyświetlanie i wyszukiwanie</h6>
				<dl class="cmdlist">
					<dt><dfn>ls</dfn> <var>[opcje]</var> <var>[ścieżka]</var></dt>
						<dd>listowanie zawartości katalogu, do ważniejszych opcji należy zaliczyć:<br />
							<code>-a</code> wyświetlaj pliki ukryte (zaczynających się od kropki)<br />
							<code>-l</code> wyświetlaj pliki w formie listy z szczegółowymi informacjami (uprawnienia, rozmiar, data modyfikacji, właściciel, grupa, rozmiar)<br />
							<code>-1</code> wyświetlaj pliki w formie 1 plik w jednej linii (bez dodatkowych informacji; stosowane domyślne gdy wynik komendy przekazywany jest strumieniem do innej komendy lub pliku)<br />
							<code>-h</code> stosuj jednostki typu k, M, G zamiast podawać rozmiar w bajtach<br />
							<code>-t</code> sortuj wg daty modyfikacji<br />
							<code>-S</code> sortuj wg rozmiaru<br />
							<code>-r</code> odwróć kolejność sortowania<br />
							<code>-c</code> użyj daty utworzenia zamiast daty modyfikacji (stosowane w połączeniu z <code>-l</code> i/lub <code>-t</code>)<br />
							<code>-d</code> wyświetlaj informacje o katalogu zamiast jego zawartości
						</dd>
					<dt><dfn>find</dfn> <var>[opcje]</var> <var>[katalog startowy]</var> <var>[wyrażenie]</var></dt>
						<dd>wyszukiwanie w systemie plików w oparciu o nazwę/ścieżkę lub właściwości pliku, do ważniejszych opcji należy zaliczyć:<br />
							<code>-P</code> wypisuj informacje o linkach symbolicznych a nie plikach przez nie wskazywanych (domyślne)<br />
							<code>-L</code> wypisuj informacje o wskazywanych przez linki symboliczne plikach<br />
						do ważniejszych elementów wyrażenia należy zaliczyć:<br />
							<code>-name "<var>wyrażenie</var>"</code> pliki których nazwa pasuje do wyrażenia korzystającego z shellowych znaków uogólniających<br />
								komenda find (w odróżnieniu np. od ls) samodzielnie interpretują wyrażenia zawierające shellowe znaki uogólniające, w związku z czym konieczne może się okazać zabezpieczenie ich przed interpretacją przez powłokę np. przy pomocy umieszczenia wewnątrz pojedynczych cudzysłowów<br />
							<code>-iname "<var>wyrażenie</var>"</code> jak -name, tyle że nie rozróżnia wielkości liter<br />
							<code>-path "<var>wyrażenie</var>"</code> pliki których ścieżka pasuje do wyrażenia korzystającego z shellowych znaków uogólniających<br />
							<code>-ipath "<var>wyrażenie</var>"</code> jak -path, tyle że nie rozróżnia wielkości liter<br />
							<code>-regex "<var>wyrażenie</var>"</code> pliki których ścieżka pasuje do wyrażenia regularnego<br />
							<code>-iregex "<var>wyrażenie</var>"</code> jak -regexp, tyle że nie rozróżnia wielkości liter<br />
							
							<code><var>warunek</var> -o <var>warunek</var></code> łączy warunki sumą logiczną OR zamiast domyślnego iloczynu logicznego AND<br />
							<code>! <var>warunek</var></code> negacja warunku<br />
							
							<code>-mtime <var>[+|-]n</var></code> pliki których modyfikacja odbyła się <var>n</var>*24 godziny temu<br />
							<code>-mmin <var>[+|-]n</var></code> pliki których modyfikacja odbyła się <var>n</var> minut temu<br />
							<code>-ctime <var>[+|-]n</var></code> pliki które zostały utworzone <var>n</var>*24 godziny temu<br />
							<code>-cmin <var>[+|-]n</var></code> pliki które zostały utworzone <var>n</var> minut temu<br />
							<code>-size <var>[+|-]n[c|k|M|G]</var></code> pliki których rozmiar wynosi <var>n</var> (c - bajtów, k - kilobajtów, M - Megabajtów, G - gigabajtów)<br />
						w powyższych testach <var>+</var> oznacza więcej niż, <var>-</var> oznacza mniej niż, uwaga: porównywaniu podlegają liczby całkowite, np. +1 oznaczacza <m>&gt;1</m> w liczbach całkowitych tzn. <m>\ge2</m><br />
							
							<code>-exec <var>polecenie \{\}</var> \;</code> dla każdego znalezionego pliku wykonaj <var>polecenie</var> podstawiając ścieżkę do tego pliku pod <var>\{\}</var> (zastosowane odwrotne ukośniki służą zabezpieczeniu nawiasów klamrowych i średnika przed zinterpretowaniem ich przez powłokę)<br />
							<code>-execdir <var>polecenie \{\}</var> \;</code>, podobnie jak <code>-exec</code> tyle że polecenie zostanie uruchomione w katalogu w którym znajduje się wyszukany plik
						</dd>
						
					<dt><dfn>tree</dfn> <var>[ścieżka]</var></dt>
						<dd>wyświetla drzewo katalogów i plików</dd>
					<dt><dfn>stat</dfn> <var>ścieżka</var></dt>
						<dd>wyświetla informacje o podanym pliku lub katalogu</dd>
					<dt><dfn>realpath</dfn> <var>ścieżka</var></dt>
						<dd>wypisuje uproszczoną / rozwiniętą ścieżkę (tzn. ze zredukowanymi nadmiarowymi odniesieniami względnymi),<br />
							standardowo wypisuje ścieżkę bezwzględną (opcja <code>--relative-to=<var>katalog</var></code> powoduje wypisanie względnej w stosunku co do <var>katalog</var>),<br />
							standardowo zastępuje linki symboliczne wskazywaną przez nie ścieżką (opcja <code>-s</code> wyłącza tą funkcjonalność),<br />
							opcja <code>-m</code> pozwala na operowanie nie istniejącymi ścieżkami,<br />
							standardowe zachowanie odpowiada działaniu komendy <code>readlink</code>
						</dd>
						
					<dt><dfn>du</dfn> <var>[opcje]</var> <var>ścieżka1 [ścieżka2 [...]]</var></dt>
						<dd>wyświetlanie informacji o zajętej przestrzeni dyskowej przez wskazane pliki / katalogi, do ważniejszych opcji należy zaliczyć:<br />
							<code>-s</code> podaje łączną ilość zajętego miejsca dla każdego argumentów (zamiast wypisywać rozmiar każdego pliku)<br />
							<code>-c</code> podaje łączną ilość zajętego miejsca dla wszystkich argumentów<br />
							<code>-h</code> stosuje jednostki typu k, M, G<br />
							podawany rozmiar może się różnić (w obie strony) od wyniku ls: ls podaje rozmiar pliku (ile zawiera informacji lub ile zostało zadekarowane że może jej zawierać), a du to ile zajmuje na dysku
						</dd>
					<dt><dfn>df [opcje]</dfn></dt>
						<dd>wyświetlanie informacji o zajętości miejsca na poszczególnych systemach plików</dd>
				</dl>
					
				<h6>kopiowanie, przenoszenie, usuwanie, ...</h6>
				<dl class="cmdlist">
					<dt><dfn>cp</dfn> <var>[opcje]</var> <var>źródło1 [źródło2 [...]]</var> <var>cel</var></dt>
						<dd>kopiuje wskazany plik (lub pliki) do wskazanej lokalizacji, w przypadku kopiowania wielu plików <var>cel</var> powinien być katalogiem, do ważniejszych opcji należy zaliczyć:<br />
							<code>-r</code> pozwala na (rekursywne) kopiowanie katalogów<br />
							<code>-a</code> podobnie jak <code>-r</code>, dodatkowo zachowując atrybuty plików<br />
							<code>-l</code> zamiast kopiować tworzy twarde dowiązania (hard links)<br />
							<code>-s</code> zamiast kopiować tworzy linki symboliczne do plików<br />
							<code>-f</code> nadpisywanie bez pytania<br />
							<code>-i</code> zawsze pytaj przed nadpisaniem
						</dd>
					<dt><dfn>ln</dfn> <var>źródło1 [źródło2 [...]]</var> <var>cel</var></dt>
						<dd>tworzy link twardy do wskazanego pliku (lub plików) w wskazanej lokalizacji, w przypadku wskazania wielu plików źródłowych <var>cel</var> powinien być katalogiem, do ważniejszych opcji należy zaliczyć:<br />
							<code>-s</code> tworzy dowiązania symboliczne zamiast twardych<br />
							<code>-r</code> używa ścieżki względnej zamiast bezwzględnej przy tworzeniu dowiązań symbolicznych
						</dd>
					<dt><dfn>mv</dfn> <var>[opcje]</var> <var>źródło1 [źródło2 [...]]</var> <var>cel</var></dt>
						<dd>przenosi wskazane pliki / katalogi do wskazanej lokalizacji, w przypadku przenoszenia wielu plików <var>cel</var> powinien być katalogiem, do ważniejszych opcji należy zaliczyć:<br />
							<code>-f</code> nadpisywanie bez pytania<br />
							<code>-i</code> zawsze pytaj przed nadpisaniem
						</dd>
					<dt><dfn>rm</dfn> <var>[opcje]</var> <var>ścieżka1 [ścieżka2 [...]]</var></dt>
						<dd>usuwa wskazane pliki, do ważniejszych opcji należy zaliczyć:<br />
							<code>-r</code> pozwala na na (rekursywne) kasowanie katalogów wraz z zawartością<br />
							<code>-f</code> usuwanie bez pytania<br />
							<code>-i</code> zawsze pytaj przed usunięciem
						</dd>
					<dt><dfn>touch</dfn> <var>[opcje]</var> <var>ścieżka1 [ścieżka2 [...]]</var></dt>
						<dd>zmiana daty modyfikacji pliku (wykorzystywany także do tworzenia plików)</dd>
				</dl>
					
				<h6>katalogi</h6>
				<dl class="cmdlist">
					<dt><dfn>mkdir</dfn> <var>[opcje]</var> <var>ścieżka1 [ścieżka2 [...]]</var></dt>
						<dd>tworzy wskazane katalogi, do ważniejszych opcji należy zaliczyć:<br />
							<code>-p</code> pozwala na tworzenie całej ścieżki a nie tylko ostatniego elementu, nie zgłasza błędu gdy wskazany katalog istnieje
						</dd>
					<dt><dfn>rmdir</dfn> <var>[opcje]</var> <var>ścieżka1 [ścieżka2 [...]]</var></dt>
						<dd>usuwa wskazane katalogi (muszą być puste)</dd>
				</dl>
				<!-- END: Operacje na systemie plików -->
				
				<!-- BEGIN: zdalne kopiowanie -->
				<h6>zdalne kopiowanie</h6>
				<dl class="cmdlist">
					<dt><dfn>scp</dfn> <var>[opcje]</var> <var>źródło1 [źródło2 [...]]</var> <var>cel</var></dt>
						<dd>kopiuje wskazany plik (lub pliki) do wskazanej lokalizacji, w przypadku kopiowania wielu plików <var>cel</var> powinien być katalogiem, do ważniejszych opcji należy zaliczyć:<br />
							<code>-r</code> pozwala na (rekursywne) kopiowanie katalogów<br />
							<code>-P <var>port</var></code> określa port SSH<br />
							W odróżnieniu od <code>cp</code> <var>źródło</var> lub <var>cel</var> w postaci <code><var>[user@]</var><var>host</var>:<var>[ścieżka]</var></code> wskazują na zdalny system dostępny poprzez SSH.
						</dd>
					<dt><dfn>rsync</dfn> <var>[opcje]</var> <var>źródło</var> <var>cel</var></dt>
						<dd>kopiuje (synchronizacjiuje) pliki i drzewa katalogów (zarówno lokalnie jak i zdalnie), do ważniejszych opcji należy zaliczyć:<br />
							<code>-r</code> pozwala na (rekursywne) kopiowanie katalogów<br />
							<code>-l</code> kopiuje linki symboliczne jako linki symboliczne (zamiast kopiowania zawartości pliku na który wskazują)<br />
							<code>-t</code> zachowuje czas modyfikacji plików<br />
							<code>-u</code> kopiuje tylko gdy plik źródłowy nowszy niż docelowy<br />
							<code>-c</code> kopiuje tylko gdy plik źródłowy i docelowy mają inne sumy kontrolne<br />
							<code>--delete</code> usuwa z docelowego drzewa katalogów elementy nie występujące w drzewie źródłowym<br />
							<code>-e 'ssh'</code> pozwala na kopiowanie na/z zdalnych systemów za pośrednictwem ssh, <var>źródło</var> lub <var>cel</var> w postaci <code><var>[user@]</var><var>host</var>:<var>[ścieżka]</var></code> wskazują na zdalny system<br />
							<code>--partial --partial-dir=<var>."-tmp-"</var></code> zachowuje skopiowane częściowo pliki w katalogu <var>.-tmp-</var> (pozwala na przerwanie i wznowienie transferu pliku)<br />
							<code>--progress</code> pokazuje postęp kopiowania<br />
							<code>--exclude="<var>wzorzec</var>"</code> pomija (w kopiowaniu i kasowaniu) pliki pasujące do <var>wzorzec</var> (wzorzec może zawierać znaki uogólniające powłoki)<br />
							<code>-n</code> symuluje pracę (pokazuje co zostałoby skopiowane, ale nie kopiuje)
						</dd>
				</dl>
				<!-- END: zdalne kopiowanie -->
			</section>
			<section>
				<h5>Operacje na archiwach</h5>
				<dl class="cmdlist">
					<dt><dfn>tar</dfn> <var></var></dt>
						<dd>archiwizuje wiele plików w postaci jednego, przykłady:<br />
							<code>tar -xf <var>plik.tar</var></code> - wypakowuje zawartość niekompresowanego archiwum <var>plik.tar</var> interpretując zapisane w archiwum ścieżki względem bieżącego katalogu<br />
							<code>tar -czf - <var>ścieżka1 [ścieżka2 [...]]</var> | ssh <var>[user@]</var><var>host</var> 'cat &gt; <var>plik.tgz</var>'</code> - archiwizuje wskazane pliki/katalogi bezpośrednio na zdalny system z użyciem ssh i kompresji gzip
						</dd>
					<dt><dfn>ar</dfn> <var>polecenie</var><var>[modyfikatory]</var> <var>archiwum</var> <var>[pliki]</var></dt>
						<dd>archiwizuje wiele plików w postaci jednego (format wykorzystywany w plikach bibliotek linkowanych statycznie i w pakietach Debiabna), przykłady:<br />
							<code>ar rcs <var>libAA.a</var> <var>aa*.o</var></code> - tworzy bibliotekę <var>libAA.a</var> z wszystkich plików <var>aa*.o</var><br />
							<code>ar x <var>pakiet.deb</var></code> - wypakowuje zawartość pakietu Debiana z pliku <var>pakiet.deb</var> (będą to dwa archiwa i plik z wersją formatu pakietu)
					</dd>
					<dt><dfn>7z</dfn></dt>
						<dd>archiwizer obsługujące wiele formatów, w tym formaty z silną kompresją</dd>
				</dl>
			</section>
			<section>
				<h5>Operacje na plikach (tekstowych)</h5>
				<dl class="cmdlist">
					<dt><dfn>cat</dfn> <var>[opcje]</var> <var>[plik1 [plik2 [...]]]</var></dt>
						<dd>wypisywanie i łączenie plików</dd>
					<dt><dfn>tac</dfn> <var>[opcje]</var> <var>[plik]</var></dt>
						<dd>wypisywanie plików z odwróceniem kolejności linii (odwrócenie kolejności wypisywania; może być użyte np. do odwrócenie porządku sortowania)</dd>
						
					<!-- BEGIN: tail head -->
					<dt><dfn>tail</dfn> <var>[opcje]</var> <var>[plik]</var></dt>
						<dd>wyświetla ostatnie linie pliku, przydatne opcje:<br />
							<code>-n <var>x</var></code> określa że ma zostać wyświetlone <var>x</var> ostatnich linii<br />
							<code>-f</code> uruchamia dopisywania (gdy do pliku zostaną dopisane nowe linie tail je wyświetli)
						</dd>
					<dt><dfn>head</dfn> <var>[opcje]</var> <var>[plik]</var></dt>
						<dd>wyświetla początkowe linie pliku, przydatne opcje:<br />
							<code>-n <var>x</var></code> określa że ma zostać wyświetlone <var>x</var> pierwszych linii
						</dd>
					<!-- END: tail head -->
					
					<dt><dfn>rev</dfn> <var>[plik]</var></dt>
						<dd>wypisuje plik odwracając kolejność znaków w każdym wierszu</dd>
					<dt><dfn>wc</dfn></dt>
						<dd>liczy linie, słowa, znaki i bajty</dd>
					
					<!-- BEGIN: grep -->
					<dt><dfn>grep</dfn> <var>[opcje]</var> <var>wyrażenie</var> <var>[plik1 [plik2 [...]]]</var></dt>
						<dd>wyszukuje pasujące do wyrażenia regularnego <var>wyrażenie</var> linie w plikach, przydatne opcje:<br />
							<code>-v</code> zamiast pasujących wypisz nie pasujące<br />
							<code>-i</code> ignoruj wielkość liter<br />
							<code>-a</code> przetwarzaj pliki binarne jak tekstowe<br />
							<code>-E</code> korzystaj z <em>Extended Regular Expressions</em> (ERE) zamiast <em>Basic Regular Expressions</em> (BRE)<br />
							<code>-P</code> korzystaj z <em>Perl-compatible Regular Expressions</em> (PCRE) zamiast <em>Basic Regular Expressions</em> (BRE)<br />
							
							<code>-r</code> rekursywnie przetwarzaj podane katalogi wyszukując w wszystkich znalezionych plikach<br />
							<code>-R</code> jak -r, ale zawsze podąża za linkami symbolicznymi<br />
							<code>--exclude="<var>wyrażenie</var>"</code> pomiń pliki pasujące do <var>wyrażenie</var> (może zawierać znaki uogólniające powłoki)<br />
							
							<code>-l</code> wypisuje pliki z pasującymi liniami<br />
							<code>-L</code> wypisuje pliki z bez pasujących linii
						</dd>
					<!-- END: grep -->
					<!-- BEGIN: diff patch -->
					<dt><dfn>diff</dfn> <var>ścieżka1</var> <var>ścieżka2</var></dt>
						<dd>porównuje pliki lub katalogi (w przypadku tych drugich porównuje ze sobą pliki o takich samych nazwach oraz zgłasza fakt występowania pliku tylko w jednym z katalogów), przydatne opcje:<br />
							<code>-r</code> rekursywnie przetwarzaj podane katalogi<br />
							<code>-u</code> wypisuje różnice w formacie "unified"<br />
							<code>-c</code> wypisuje różnice w formacie "context"
						</dd>
					<dt><dfn>patch</dfn></dt>
					<dd>stosuje plik łaty (wynik diff'a) w celu zmodyfikowania plików, typowo:<br />
						<code>patch -p<var>n</var> &lt; <var>plik.diff</var></code> co powoduje zastosowanie zmian opisanych w <var>plik.diff</var> na plikach w bieżącym katalogu,
						<var>n</var> określa ilość poziomów ścieżek podanych w pliku łaty które mają zostać zignorowane
					</dd>
					<!-- END: diff patch -->
					<!-- BEGIN: sort -->
					<dt><dfn>sort</dfn> <var>[plik]</var></dt>
						<dd>sortuje linie w wskazanym pliku, przydatne opcje:<br />
							<code>-n</code> traktuj liczby jako wartości numeryczne a nie napisy<br />
							<code>-i</code> ignoruj wielkość liter<br />
							<code>-r</code> odwróć kolejność sortowania<br />
							<code>-k <var>n</var></code> sortuj wg kolumny <var>n</var><br />
							<code>-t <var>sep</var></code> kolumny rozdzielane są przy pomocy separatora <var>sep</var>
						</dd>
					<!-- END: sort -->
					
					<dt><dfn>tr</dfn> <var>[opcje]</var> <var>zbiór1</var> <var>[zbiór2]</var></dt>
						<dd>zastępuje znaki z <var>zbiór1</var> odpowiadającymi im pod względem kolejności znakami z <var>zbiór2</var>, przydatne opcje:<br />
							<code>-d</code> zamiast zastępować usuwa znaki występujące w <var>zbiór1</var><br />
							uwaga: często działa poprawnie wyłącznie dla znaków jedno bajtowych - można wtedy zastosować <code>sed -e 'y#<var>zbiór1</var>#<var>zbiór2</var>#'</code> lub <code>trs -f '<var>zbiór1</var> <var>zbiór2</var>'</code>
						</dd>
					<!-- BEGIN: sed -->
					<dt><dfn>sed</dfn> <var>[opcje]</var> <var>[pliki]</var></dt>
						<dd>edytuje plik zgodnie z podanymi poleceniami, przydatne opcje:<br />
							<code>-e "<var>polecenie</var>"</code> - wykonuj na pliku <var>polecenie</var> (może wystąpić wielokrotnie celem podania wielu poleceń)<br />
							<code>-f "<var>plik</var>"</code> - wczytaj polecenia z pliku <var>plik</var><br />
							<code>-E</code> - używaj rozszerzonych wyrażeń regularnych<br />
							<code>-i</code> - modyfikuj podany plik zamiast wypisywać zmieniony na stdout<br />
						 przydatne polecenia:<br />
							<code>s@<var>regexp</var>@<var>napis</var>@<var>[g]</var></code> - wyszukaj dopasowania do wyrażenia regularnego <var>regexp</var> i zastąp je przez <var>napis</var>, podanie opcji <var>g</var> powoduje zastępowanie wszystkich wystąpień a nie tylko pierwszego, znak <code>@</code> pełni rolę separatora i może zostać zamiast niego użyty inny znak<br />
							<code>y@<var>zbiór1</var>@<var>zbiór2</var>@</code> - zastąp znaki z <var>zbiór1</var> znakami odpowiadającymi im pod względem kolejności znakami z <var>zbiór2</var>, znak <code>@</code> pełni rolę separatora i może zostać zamiast niego użyty inny znak<br />
						możliwe jest też m.in. adresowanie linii na których ma być wykonywana operacja, np: <code>0,/<var>regexp</var>/ s@<var>regexp</var>@<var>napis</var>@</code> wykona polecenie s na liniach od początku pliku do linii pasującej do wyrażenia regularnego <var>regexp</var>, czyli zastąpi tylko pierwsze wystąpienie w pliku
						</dd>
					<!-- END: sed -->
					<!-- BEGIN: cut -->
					<dt><dfn>cut</dfn> <var>[opcje]</var> <var>[pliki]</var></dt>
						<dd>wybiera z pliku zadany zestaw kolumn, przydatne opcje:<br />
							<code>-f <var>nnn</var></code> wypierz kolumny określone przez <var>nnn</var> (np. <var>1,3-4,6-</var> oznacza kolumnę 1, kolumny od 3 do 4 i od 6, a <var>-3</var> oznacza 3 pierwsze kolumny)<br />
							<code>-d <var>sep</var></code> kolumny rozdzielane są przy pomocy separatora <var>sep</var> (musi być pojedynczym jedno bajtowym znakiem, aby ominąć to ograniczenie należy skorzystać z awk)
						</dd>
					<!-- END: cut -->
					<dt><dfn>awk</dfn></dt>
						<dd>skryptowy język umożliwiający przetwarzanie tekstowych baz danych postaci linia=rekord, pola oddzielane ustalonym separatorem (m.in. łączy funkcjonalność grep, cut, itp), szerzej omówiony w przykładzie przetwarzania napisów w bashu</dd>
					
					<!-- BEGIN: paste join comm uniq -->
					<dt><dfn>paste</dfn></dt>
						<dd>łączy (odpowiadające sobie pod względem numerów) linie z dwóch plików</dd>
					<dt><dfn>join</dfn> <var></var></dt>
						<dd>łączy linie  z dwóch plików w oparciu o porównanie wskazanego pola</dd>
					<dt><dfn>comm</dfn> <var></var></dt>
						<dd>porównuje dwa posortowane pliki pod względem unikalności linii (może wypisać wspólne lub występujące tylko w jednym z plików)</dd>
					<dt><dfn>uniq</dfn> <var></var></dt>
						<dd>usuwa powtarzające się linie z posortowanego pliku, przydatne opcje:<br />
							<code>-c</code> wypisz liczbę powtórzeń<br />
							<code>-d</code> wypisz tylko linie z 2 lub więcej wystąpieniami<br />
							<code>-u</code> wypisz tylko linie z 1 wystąpieniem
						</dd>
					<!-- END: paste join comm uniq -->
					
					<dt><dfn>xmlstarlet</dfn></dt>
						<dd>narzędzie do przetwarzania, modyfikowania plików XML (można powiedzieć taki odpowiednik sed/awk dla xml'a)</dd>
					<dt><dfn>xsltproc</dfn></dt>
						<dd>narzędzie do przetwarzania XSLT 1.0</dd>
				</dl>
			</section>
			<!-- BEGIN: Użytkownicy, uprawnienia i procesy -->
			<section>
				<h5>Uprawnienia do plików</h5>
				<p>
					Podstawowe unixowe uprawnienia do plików składają się z trzech członów: uprawnienia dla właściciela (u), grupy (g) i pozostałych użytkowników (o).<br />
					W każdym z członów mogą być przyznane uprawnienia do czytania (r), pisania (w) i wykonywania (x); w odniesieniu do plików jest to intuicyjne (uprawnienie do wykonywania jest potrzebne do uruchomienia programów), natomiast w stosunku do katalogów wygląda to następująco: uprawnienia do czytania pozwalają na listowanie zawartości, do wykonania pozwalają na dostęp, do zawartości katalogu (wejścia do niego) do pisania na tworzenie nowych obiektów wewnątrz niego i zmienianie nazw istniejących.<br />
					Warto zaznaczyć iż program w pliku nie mającym praw wykonywalności też może być wykonany (w przypadku skryptu poprzez uruchomienie interpretatora i podanie tego programu jako odpowiedniego argumentu wywołania, w przypadku typowych binarek poprzez wywołanie <code>/lib/ld-linux.so.2</code> z tym plikiem i jego opcjami jako parametrem.
				</p>
				<p>
					Rozszerzeniem podstawowych uprawnień opisanych powyżej jest mechanizm Filesystem Access Control List (ACL, fACL).<br />
					Jest on opcjonalnym mechanizmem który (na wspierających go systemach plików) pozwala na definiowanie uprawnień do pliku dla dodatkowych użytkowników i grup - plik ma nadal swojego właściciela, grupę i wszystkich pozostałych, ale przed prawami dla "others" wchodzą prawa użytkowników i grup definiowanych w ACL (w najpopularniejszej minimalnej wersji według schematu rwx). Wypadkowe prawa obliczane są jako suma wynikła z praw użytkownika i grup do których należy.<br />
					ACL pozwala ponadto definiować uprawnienia domyślne dla nowo powstałych plików w katalogu (są one opcją katalogu).
				</p>
				<p>Wszystkie poniższe komendy przyjmują opcję <code>-R</code> powodującą rekursywne wykonywanie zmian na drzewku katalogów/plików rozpoczynającym się w podanej ścieżce.</p>
				<dl class="cmdlist">
					<dt><dfn>chown</dfn> <var>[opcje]</var> <var>właściciel</var> <var>ścieżka</var></dt>
						<dd>zmiana właściciela pliku</dd>
					<dt><dfn>chgrp</dfn> <var>[opcje]</var> <var>grupa</var> <var>ścieżka</var></dt>
						<dd>zmiana grupy do której należy plik pliku</dd>
					<dt><dfn>chmod</dfn> <var>[opcje]</var> <var>uprawnienia</var> <var>ścieżka</var></dt>
						<dd>zmiana prawa dostępu do pliku(ów)</dd>
					
					<dt><dfn>getfacl</dfn> <var>[opcje]</var> <var>[ścieżka]</var></dt>
						<dd>dczyt uprawnień związanych z listami kontroli dostępu fACL</dd>
					<dt><dfn>setfacl</dfn> <var>[opcje]</var> <var>[ścieżka]</var></dt>
						<dd>ustawianie uprawnień związanych z listami kontroli dostępu fACL</dd>
						
					<dt><dfn>chattr</dfn></dt>
						<dd>zmienia atrybuty plików związanych z systemem plików (np. zabrania jakiejkolwiek modyfikacji pliku)</dd>
				</dl>
			</section>
			<section>
				<h5>Użytkownicy</h5>
				<dl class="cmdlist">
					<dt><dfn>id</dfn> <var>[użytkownik]</var></dt>
						<dd>informacja o użytkowniku (m.in. grupy do których należy)</dd>
					<dt><dfn>whoami</dfn></dt>
						<dd>informacja o aktualnym użytkowniku</dd>
					<dt><dfn>w</dfn> lub <var>who</var></dt>
						<dd>informacja o zalogowanych użytkownikach</dd>
					
					<dt><dfn>passwd</dfn> <var>[użytkownik]</var></dt>
						<dd>zmiana hasła</dd>
						
					<dt><dfn>su</dfn> <var>[użytkownik]</var></dt>
						<dd>przełącza użytkownika (aby przełączony użytkownik miał dostęp do "naszego" x serwera wcześniej wydajemy <code>xhost LOCAL:użytkownik</code>)</dd>
					<dt><dfn>sudo</dfn></dt>
						<dd>program pozwalający na wykonywanie uprzywilejowanych komend przez wyznaczonych użytkowników</dd>
				</dl>
			</section>
			<section>
				<h5>Procesy i zasoby</h5>
				<dl class="cmdlist">
					<dt><dfn>ps</dfn> <var>[opcje]</var></dt>
						<dd>wyświetla aktualnie działające procesy i informacje o nich<br />
							np. kombinacja opcji <code>-Alf</code> powoduje wyświetlenie wszystkich procesów, w długim, pełnym formacie wypisywania
						</dd>
					<dt><dfn>pgrep</dfn></dt>
						<dd>wyświetla filtrowaną listę aktualnie działających procesów</dd>
					<dt><dfn>pstree</dfn></dt>
						<dd> wyświetla drzewo aktualnie działających procesów</dd>
					<dt><dfn>pwdx</dfn></dt>
						<dd>podaje katalog roboczy podanego procesu</dd>
					
					<dt><dfn>top</dfn></dt>
						<dd>monitorowanie procesów obciążających CPU, pamięć, itd</dd>
					<dt><dfn>iotop</dfn> <var></var></dt>
						<dd>monitorowanie procesów obciążających I/O</dd>
					
					<dt><dfn>fuser</dfn> <var></var></dt>
						<dd>informacje o procesach korzystających z plików</dd>
					<dt><dfn>lsof</dfn> <var></var></dt>
						<dd>informacje o plikach otwartych przez program (można podglądać także w <code>/proc/PID/fd/</code>)</dd>
					<dt><dfn>socklist</dfn> <var></var></dt>
						<dd>wyświetla listę otwartych socketów</dd>
					<dt><dfn>vmstat</dfn> <var></var></dt>
						<dd>informacje o obciążeniu systemu</dd>
					<dt><dfn>ipcs</dfn> <var></var></dt>
						<dd>informacje o wykorzystaniu pamięci współdzielonej</dd>
					
					<dt><dfn>kill</dfn> <var>[opcje]</var> <var>pid</var></dt>
						<dd>przesyła sygnał do procesów o podanych PID</dd>
					<dt><dfn>killall</dfn> <var>[opcje]</var> <var>nazwa</var></dt>
						<dd>przesyła sygnał do procesów o pasującej nazwie</dd>
					
					<dt><dfn>time</dfn></dt>
						<dd>czas działania programu</dd>
					<dt><dfn>nice</dfn> / <dfn>renice</dfn> / <dfn>ionice</dfn> / <dfn>cpulimit</dfn></dt>
						<dd>zarządzanie priorytetami i limitami procesu</dd>
					<dt><dfn>taskset</dfn></dt>
						<dd>zarządzanie przypisaniem procesu do CPU / rdzenia</dd>
					<dt><dfn>free</dfn></dt>
						<dd>informacja o zajętości pamięci</dd>
				</dl>
			</section>
			<!-- END: Użytkownicy, uprawnienia i procesy -->
			<section>
				<h5>Diagnostyka sieci</h5>
				
				<h6>Adresy</h6>
				<dl class="cmdlist">
					<dt><dfn>ipcalc</dfn> oraz <dfn>sipcalc</dfn></dt>
						<dd>kalkulator IP (pozwalający na obliczanie adresów sieci rozgłoszeniowych, zmianę notacji itd)</dd>
					<dt><dfn>whois</dfn></dt>
						<dd>informacje z bazy whois (o domenie lub adresie IP)</dd>
				</dl>
				
				<h6>Dostępność i trasy do hostów</h6>
				<dl class="cmdlist">
					<dt><dfn>ping</dfn> <var>[opcje]</var> <var>host</var> lub <dfn>ping6</dfn> <var>[opcje]</var> <var>host</var></dt>
						<dd>sprawdzanie dostępności hosta z użyciem protokołu ICMP (ping - dla adresów IPv4, ping6 - dla adresów IPv6), ważniejsze opcje:<br />
							<code>-c <var>n</var></code> wykonaj <var>n</var> zapytań (domyślnie pyta do momentu przerwania (Ctrl-C, lub sygnał kill))<br />
							<code>-n</code> nie zamieniaj adresu IP hosta który odpowiedział na nazwę domenową
						</dd>
					<dt><dfn>tracepath</dfn> <var>[opcje]</var> <var>host</var> lub <dfn>tracepath6</dfn> <var>[opcje]</var> <var>host</var></dt>
						<dd>sprawdzanie ścieżki do hosta (tracepath - dla adresów IPv4, tracepath6 - dla adresów IP, ważniejsze opcje:<br />
							<code>-n</code> nie zamieniaj adresu IP hosta który odpowiedział na nazwę domenową
						</dd>
					<dt><dfn>traceroute</dfn> <var>[opcje]</var> <var>host</var> lub <dfn>traceroute6</dfn> <var>[opcje]</var> <var>host</var></dt>
						<dd>sprawdzanie ścieżki do hosta (traceroute - (domyślnie) dla adresów IPv4, traceroute6 - dla adresów IP<br />
							<code>-n</code> nie zamieniaj adresu IP hosta który odpowiedział na nazwę domenową
						</dd>
					<dt><dfn>tcptraceroute</dfn> lub <dfn>tcptraceroute6</dfn></dt>
						<dd>tak jak traceroute, tyle że z wykorzystaniem pakietów TCP a nie UDP</dd>
					<dt><dfn>mtr</dfn> <var>[opcje]</var> <var>host</var></dt>
						<dd>sprawdzanie ścieżki do hosta (wraz z stratami pakietów i opóźnieniami na poszczególnych odcinkach) w trybie ciągłym (z ciągłym odświeżaniem)<br />
							<code>-n</code> nie zamieniaj adresu IP hosta który odpowiedział na nazwę domenową
						</dd>
					
					<dt><dfn>nmap</dfn></dt>
						<dd>skaner sieciowy - sprawdzanie dostępnych hostów w sieci, otwartych portów, itd</dd>
					<dt><dfn>arping</dfn></dt>
						<dd>narzędzie do pingowania z wykorzystaniem zapytań ARP zamiast ICMP<br />
							istnieją dwie zasadnicze odmiany: z iputils oraz z synscan; ta druga zawarta w debianowym pakiecie "arping" umożliwia także pingowanie po adresie MAC (ale nie przez RARP, bo on nie do tego służy), aby to jednak działało host docelowy nie może ignorować pingów rozgłoszeniowych, metoda obejścia opisana jest w README arping'a
						</dd>
					<dt><dfn>arp-scan</dfn></dt>
						<dd>wyszukiwanie hostów w oparciu o zapytania ARP (można powiedzieć że jest to równoważne uruchamianiu komendy arping w pętli)</dd>
				</dl>
					
				<h6>DNS</h6>
				<dl class="cmdlist">
					<dt><dfn>dig</dfn> <var>[opcje]</var> <var>nazwa</var> <var>[typRekordu]</var></dt>
						<dd>narzędzia do uzyskania informacji z DNS,
							pozwala na określenie poprzez <code>@<var>adres</var></code> serwera który chcemy odpytać oraz na określenie (poprzez drugi argument) typu rekordu który chcemy uzyskać np.:<br />
								<code>A</code> - rekord typu A czyli mapowanie nazwy na adres IPv4<br />
								<code>AAAA</code> - rekord typu AAAA czyli mapowanie nazwy na adres IPv4<br />
								<code>MX</code> - rekord typu MX czyli informacja o serwerach obsługujących pocztę danej domeny<br />
								<code>NS</code> - rekord typu NS czyli informacja o serwerach obsługujących DNS danej domeny<br />
								<code>SRV</code> - rekord typu SRV czyli informacje o hoście świadczącym usługę (usługa określana jest w nazwie domeny o którą pytamy)<br />
								<code>TXT</code> - rekord typu TXT czyli informacje dodatkowe<br />
								<code>ANY</code> - powoduje odpytanie o wszystkie rekordy<br />
								<code>AXFR</code> - powoduje wysłanie prośby o transfer całej strefy (działa jezeli dany host ma prawo transferu całej strefy z danego serwera)
						</dd>
					<dt><dfn>host</dfn> <var>[opcje]</var> <var>nazwa|ip</var> <var>[server]</var></dt>
						<dd>narzędzia do zamiany adresów domenowych na IP i odwrotnie oraz wyciągania innych informacji z DNS (np. rekordy MX)</dd>
					<dt><dfn>nslookup</dfn> <var>[opcje]</var> <var>nazwa|ip</var> <var>[server]</var></dt>
						<dd>narzędzia do zamiany adresów domenowych na IP i odwrotnie oraz wyciągania innych informacji z DNS (np. rekordy MX)</dd>
					
					<dt><dfn>dnstracer</dfn></dt>
						<dd>śledzenie trasy zapytań DNS</dd>
					<dt><dfn>dnswalk</dfn></dt>
						<dd>debuger DNS</dd>
				</dl>
					
				<h6>IPv6</h6>
				<dl class="cmdlist">
					<dt><dfn>ndisc6</dfn></dt>
						<dd>testowanie ICMPv6 Neighbor Discovery</dd>
					<dt><dfn>rdisc6</dfn></dt>
						<dd>testowanie ICMPv6 Router Discovery</dd>
					<dt><dfn>rltraceroute6</dfn></dt>
						<dd>trasa pakietów do danego hosta IPv6 z użyciem UDP/ICMP</dd>
					<dt><dfn>tcpspray6</dfn></dt>
						<dd>pomiar prędkości łącza z użyciem TCP/IP Discard/Echo</dd>
					
					<dt><dfn>na6</dfn> / <dfn>ns6</dfn></dt>
						<dd>wysyłanie pakietów Neighbor Advertisement / Solicitation</dd>
					<dt><dfn>ra6</dfn> / <dfn>rs6</dfn></dt>
						<dd>wysyłanie pakietów Router Advertisement / Solicitation</dd>
					<dt><dfn>ni6</dfn> / <dfn>rd6</dfn></dt>
						<dd>wysyłanie pakietów ICMPv6 Node Information / Redirect</dd>
					<dt><dfn>scan6</dfn></dt>
						<dd>skanowanie sieci IPv6</dd>
				</dl>
				
				<h6>debugowanie łączności sieciowej</h6>
				<dl class="cmdlist">
					<dt><dfn>netcat</dfn> lub <dfn>nc</dfn> lub <dfn>netcat6</dfn></dt>
						<dd>program pozwalający na wysyłanie pakietów TCP i UDP z definiowaną przez nas zawartością, oraz odbiór pakietów TCP i UDP (słuchanie na wskazanym porcie), umożliwia m.in. testowanie usług sieciowych (takich jak smtp, www, jabber, ...); uwaga: występuje w kilku wersjach różniących się opcjami</dd>
					<dt><dfn>telnet</dfn></dt>
						<dd>program umożliwiający zdalny (nieszyfrowany, łącznie z hasłem!) dostęp do powłoki, a także (podobnie jak netcat) m.in. testowanie usług sieciowych</dd>
					
					<dt><dfn>swaks</dfn></dt>
						<dd>narzędzie do testowania SMTP</dd>
					
					<dt><dfn>tcpdump</dfn></dt>
						<dd>przechwytuje komunikację sieciową celem analizy nagłówków lub pełnej zawartości pakietów
							(wsparcie dla niektórych z protokołów warst wyższych wymaga doinstalowania - np. obsługę DHCP zapewnia dhcpdump)</dd>
					<dt><dfn>wireshark</dfn> lub <dfn>tshark</dfn></dt>
						<dd>przechwytuje komunikację sieciową celem analizy nagłówków lub pełnej zawartości pakietów, wspiera dekodowanie wielu protokołów warstwy aplikacyjnej, wireshark posiada graficzny interfejs użytkownika, tshark jest wersją konsolową</dd>
				</dl>
				
				<h6>informacje o wykorzystaniu i prędkości sieci</h6>
				<dl class="cmdlist">
					<dt><dfn>netstat</dfn> <var></var></dt>
						<dd> informacje o sieci</dd>
					<dt><dfn>iptraf</dfn> <var></var></dt>
						<dd>monitor IP LAN</dd>
					<dt><dfn>nload</dfn> <var></var></dt>
						<dd>graficzne (ncurses) pokazywanie wykorzystania (prędkości) interfejsów sieciowych</dd>
					
					<dt><dfn>ttcp</dfn> <var></var></dt>
						<dd>testuje prędkość połączenia sieciowego (strona domowa, najnowsza wersja oraz mutacja)</dd>
					<dt><dfn>iperf</dfn> <var></var></dt>
						<dd>pomiar prędkości połączenia sieciowego</dd>
				</dl>
			</section>
			<section>
				<h5>Konfiguracja sieci</h5>
				
				<h6>podstawowa konfiguracja interfejsów</h6>
				<dl class="cmdlist">
					<dt><dfn>ip</dfn></dt>
						<dd>informacje na temat interfejsów sieciowych (adresów IP, etc) i routingów oraz ich konfiguracja</dd>
					<dt><dfn>ifconfig</dfn></dt>
						<dd>informacje na temat interfejsów sieciowych (adresów IP, etc) oraz ich konfiguracja</dd>
					<dt><dfn>route</dfn></dt>
						<dd>konfiguracja routingu</dd>
					<dt><dfn>arp</dfn></dt>
						<dd>wyświetlanie i manipulowanie tablicą protokołu ARP</dd>
					<dt><dfn>dhclient</dfn></dt>
						<dd>konfiguracja automatyczna interfejsu w oparciu o DHCP</dd>
				</dl>
					
				<h6>konfiguracja mechanizmów jądrowych w Linuxie</h6>
				<dl class="cmdlist">
					<dt><dfn>vconfig</dfn></dt>
						<dd>konfiguracja (tagowanych) VLANów</dd>
					<dt><dfn>brctl</dfn></dt>
						<dd>konfiguracja bridge'ów (softwarowego switcha działającego w warstwie 2)</dd>
					<dt><dfn>ifenslave</dfn></dt>
						<dd>konfiguracja bondingu</dd>
					
					<dt><dfn>iptables</dfn></dt>
						<dd>jądrowe reguły filtrowania i routingu pakietów</dd>
					<dt><dfn>iptables</dfn></dt>
						<dd>jądrowe reguły filtrowania i routingu pakietów dla bridge'ów</dd>
					<dt><dfn>iptables</dfn></dt>
						<dd>jądrowe reguły filtrowania i routingu pakietów w warstwie drugiej OSI</dd>
				</dl>
					
				<h6>konfiguracja kart sieciowych (w tym WiFi)</h6>
				<dl class="cmdlist">
					<dt><dfn>ethtool</dfn></dt>
						<dd>konfiguracja kart ethernetowych pod względem takich parametrów jak prędkość transmisji, duplex, wake on lan, etc</dd>
					<dt><dfn>iwconfig</dfn></dt>
						<dd>konfiguracja (większości - do części trzeba użyć wlanctl-ng) bezprzewodowych interfejsów sieciowych</dd>
					<dt><dfn>wpa_supplicant</dfn></dt>
						<dd>konfiguracja większości bezprzewodowych interfejsów sieciowych z wsparciem dla WPA</dd>
					<dt><dfn>wpa_cli</dfn></dt>
						<dd>konfiguracja większości bezprzewodowych interfejsów sieciowych z wsparciem dla WPA</dd>
					<dt><dfn>iwlist</dfn></dt>
						<dd>dodatkowe informacje z bezprzewodowych interfejsów sieciowych (przydatna zwłaszcza opcja scan pokazująca dostępne sieci</dd>
				</dl>
			</section>
			<section>
				<h5>Narzędzia programistyczne</h5>
				<dl class="cmdlist">
					<dt><dfn>clang</dfn> lub <dfn>gcc</dfn></dt>
						<dd>kompilator C</dd>
					<dt><dfn>clang++</dfn> lub <dfn>g++</dfn></dt>
						<dd>kompilator C++</dd>
					<dt><dfn>ld</dfn></dt>
						<dd>linker</dd>
					<dt><dfn>python3</dfn> lub <dfn>python</dfn></dt>
						<dd>interpreter Pythona</dd>
					
					<dt><dfn>cmake</dfn></dt>
						<dd>system generacji plików Makefile</dd>
					<dt><dfn>make</dfn></dt>
						<dd>system budowania aplikacji w oparciu o pliki Makefile</dd>
					<dt><dfn>ldd</dfn></dt>
						<dd>wyświetlanie wykorzystywanych przez program bibliotek dynamicznych</dd>
					<dt><dfn>ldconfig</dfn></dt>
						<dd>konfiguracja bibliotek dynamicznych (m.in. określanie ścieżek w jakich są wyszukiwane), refresh bazy dostępnych bibliotek; patrz też /etc/ld.so.conf</dd>
						
					<dt><dfn>git</dfn>, <dfn>hg</dfn>, <dfn>svn</dfn></dt>
						<dd>systemy kontroli wersji</dd>
				</dl>
			</section>
			<section>
				<h5>Narzędzia administracyjne</h5>
				<dl class="cmdlist">
					<dt><dfn>shutdown</dfn></dt>
						<dd>wyłączanie i restartowanie systemu (komputera), podobnie do bezpośredniego operowania na poziomach init</dd>
					<dt><dfn>parted</dfn> lub <dfn>fdisk</dfn></dt>
						<dd>oglądanie i modyfikowanie podziału dysku na partycje</dd>
					<dt><dfn>mount</dfn> / <dfn>umount</dfn></dt>
						<dd>montowanie / odmontowywanie systemu plików<br />
							warto zwrócić uwagę na opcję montowania <code>-o bind</code> umożliwiającą montowanie katalogu w innym katalogu oraz na <code>-o remount</code> umożliwiającą zmianę parametrów podmontowanego systemu plików
						</dd>
					<dt><dfn>chroot</dfn> / <dfn>fakechroot</dfn> / <dfn>schroot</dfn></dt>
						<dd>narzędzia do uruchamiania programu / programów z podmienionym katalogiem głównym</dd>
					<dt><dfn>dd</dfn> / <dfn>ddrescue</dfn></dt>
						<dd>tworzenie kopi urządzenia / pliku obrazu (ddrescue z lepszą tolerancją błędów odczytu)</dd>
						
					<dt><dfn>apt</dfn> lub <dfn>aptitude</dfn></dt>
						<dd>menager pakietów systemach opartych o Debiana</dd>
					<dt><dfn>dpkg</dfn></dt>
						<dd>niskopoziomowe narzędzie do zarządzania pakietami deb</dd>
					<dt><dfn>adduser</dfn> / <dfn>deluser</dfn> oraz <dfn>addgroup</dfn> / <dfn>delgroup</dfn></dt>
						<dd>zarządzanie użytkownikami</dd>
					
					<dt><dfn>dmesg</dfn></dt>
						<dd>logi jądra</dd>
					<dt><dfn>lspci</dfn></dt>
						<dd>listowanie urządzeń podłączonych do magistrali PCI, PCI-express, ... (aktualizacjia bazy identyfikacyjnej <code>update-pciids</code>)</dd>
					<dt><dfn>lsusb</dfn></dt>
						<dd>listowanie urządzeń podłączonych do magistrali USB</dd>
					<dt><dfn>lsscsi</dfn></dt>
						<dd>listowanie urządzeń obsługiwanych przez podsystem SCSI (m.in. SATA, SCSI, FC)</dd>
					
					<dt><dfn>dmidecode</dfn></dt>
						<dd>odczyt informacji o sprzęcie</dd>
					<dt><dfn>ddcprobe</dfn></dt>
						<dd>odczyt informacji o monitorze</dd>
						
					<dt><dfn>smartctl</dfn></dt>
						<dd>odczyt informacji S.M.A.R.T. dotyczących dysku twardego</dd>
					<dt><dfn>hdparm</dfn> / <dfn>sdparm</dfn></dt>
						<dd>ustawienia parametrów dysków twardych (np. opcja -S ustawia czas po jakim usypiany jest dysk)</dd>
						
					<dt><dfn>hddtemp</dfn></dt>
						<dd>nardzędzie do kontroli temperatury dysku twardego</dd>
					<dt><dfn>mbmon</dfn> / <dfn>xmbmon</dfn></dt>
						<dd>monitorowanie parametrów pracy płyty głównej</dd>
					<dt><dfn>sensors</dfn> <var></var></dt>
						<dd>dane z czujników w komputerze (takie jak napięcia, temperatury, prędkości wentylatorów)</dd>
					<dt><dfn>acpi</dfn></dt>
						<dd>stan zasilania / baterii</dd>
				</dl>
			</section>
			<section>
				<h5>Inne narzędzia</h5>
				<dl class="cmdlist">
					<dt><dfn>echo</dfn> / <dfn>printf</dfn></dt>
						<dd>wypisuje argumenty na standardowe wyjście</dd>
					<dt><dfn>xargs</dfn></dt>
						<dd>pobierz argumenty z stdin</dd>
					<dt><dfn>mkfifo</dfn></dt>
						<dd>tworzy łącze nazwa (specjalny plik który może być wykorzystywany do komunikacji między procesami na zasadzie podobnej do |)</dd>
					<dt><dfn>seq</dfn></dt>
						<dd>wypisuje kolejne liczby (przydane np. w for)</dd>
					<dt><dfn>tee</dfn></dt>
						<dd>zapisuje stdin do podanego pliku, równocześnie wypisując go na stdout</dd>
					
					<dt><dfn>file</dfn></dt>
						<dd>rozpoznaje typ pliku</dd>
					<dt><dfn>konwert</dfn> lub <dfn>iconv</dfn></dt>
						<dd>konwersje kodowań plików tekstowych</dd>
					<dt><dfn>strings</dfn></dt>
						<dd>wypisuje sekwencje znaków drukowanych (określanie zawartości plików nietekstowych)</dd>
						
					<dt><dfn>which</dfn> <var>komenda</var></dt>
						<dd>zwraca wykonywaną ścieżkę / polecenie przy wykonywaniu <var>komenda</var></dd>
					
					<dt><dfn>date</dfn></dt>
						<dd>data i czas, program ten potrafi także przeliczać datę i czas - np. date -d @847103830 '+%Y-%m-%d %H:%M:%S', date -d '1996-11-04 11:37:10' '+%s', date -d '1996-11-04 11:37:10 +3week -2days'</dd>
					<dt><dfn>cal</dfn></dt>
						<dd>kalendarz</dd>
					
					<dt><dfn>calc</dfn> albo <dfn>apcalc</dfn></dt>
						<dd>zaawansowany kalkulator o składni podobnej do C umożliwiający wykonywanie mi.in. operacji logicznych (w tym binarnych)</dd>
					<dt><dfn>bc</dfn></dt>
						<dd>kalkulator (warto rozważyć utworzenie aliasu <code>alias 'bc'='bc &lt;(echo scale=3)'</code> (aby zaraz po starcie mieć 3 miejsca po przecinku) lub <code>alias 'bc'='bc -l'</code> (dla pełniejszej precyzji)</dd>
					<dt><dfn>numconv</dfn></dt>
						<dd>program do konwersji systemów liczbowych oprócz systemów pozycyjnych o różnych podstawach obsługuje także inne systemy liczbowe - np. rzymski</dd>
					<dt><dfn>gnuplot</dfn></dt>
						<dd>rysowanie wykresów</dd>
					
					<dt><dfn>clear</dfn></dt>
						<dd>czyści terminal</dd>
					<dt><dfn>reset</dfn></dt>
						<dd>przywraca ustawienia terminala (np. gdy po wyświetleniu pliku binarnego są dziwne krzaczki)</dd>
					<dt><dfn>stty</dfn></dt>
						<dd>konfiguruje terminal (np. port szeregowy /dev/tyyS* , później możemy korzystać z niego np. za pomocą cat, echo, ... i przekierowań potoków - np. <code>cat /dev/ttyS0 &gt; ~/serial.log</code> będzie logowało informacje z portu do wskazanego pliku)</dd>
					
					<dt><dfn>startx</dfn></dt>
						<dd>uruchamia środowisko graficzne</dd>
					<dt><dfn>xinit</dfn></dt>
						<dd>uruchamia program w środowisku graficznym (wraz z startem środowiska), np. xinit -e __WYBRANY_PROGRAM__ - - :1 uruchomi X'y na ekranie 1 (dawniej Alt+Ctrl+F8, obecnie na ogół na bieżącym terminalu) a w nich wskazany program</dd>
					<dt><dfn>xset</dfn></dt>
						<dd>konfigurowanie ekranu x-serwera, np. sleep 1; xset dpms force off spowoduje wyłączenie (uśpienie) monitora</dd>
				</dl>
			</section>
		</section>
		<section>
			<h4>Standardowe usługi</h4>
			<p>Systemy operacyjne zapewniają także szereg usług. Znaczna część z nich dostępna jest z poziomu biblioteki standardowej C (np. obsługa plików, komunikacji sieciowej, zamiany nazw domenowych oraz nazw usług na adresy numeryczne). Inne z nich realizowane są poprzez dedykowane procesy działające w tle (bez bezpośredniej interakcji z użytkownikiem), tzw. daemon-y. Poniżej omówione zostały niektóre z usług zapewnianych przez system operacyjny.</p>
			<section>
				<h5>Zamiana nazw na adresy numeryczne</h5>
				<p>Biblioteka standardowa zapewnia możliwość zamiany nazw hostów na ich numery IP, zamiany nazw usług na numery portów. Funkcjonalność ta korzysta z m.in. następujących plików konfiguracyjnych:<br />
					<code>/etc/services</code> - mapowanie nazwy usługi na numer portu<br />
					<code>/etc/hosts</code> - mapowanie nazw hostów na numery IP (lokalna baza)<br />
					<code>/etc/resolv.conf</code> - adresy serwerów DNS do których mogą być kierowane zapytania o adresy hostów
				</p>
			</section>
			<section>
				<h5>Poczta elektroniczna</h5>
				<p>Typowo system zapewnia obsługę (co najmniej lokalnego) dostarczania poczty elektronicznej. Do wysyłania listów można skorzystać z komend <code>mail</code> lub <code>sendmail</code>. Z kolei komenda <code>sendEmail</code> pozwala także na wysyłanie poczty przez wskazany serwer SMTP.</p>
			</section>
			<section>
				<!-- BEGIN: Planowanie zadań -->
				<h5>Planowanie zadań</h5>
				<p>Typowo system zapewnia usługę uruchamiania zadań o zadanym czasie. Z usługi tej można skorzystać przy pomocy poleceń:<br />
					<code>crontab</code> pozwala oglądać i edytować tablice zaplanowanych zadań cyklicznych (dla cron'a)<br />
					<code>at</code> pozwala jednorazowo zaplanować zadanie
				</p>
				<p>
					Pliki konfiguracyjne crona / obsługiwane crontab-em mają postać: <code>minuty godzina  dzienMiesiaca miesiac dzienTygodnia polecenie</code>.
					Wpis oznacza że polecenie ma zostać wykonane jeżeli wszystkie warunki będą spełnione, jeżeli jakiś warunek nie jest nam potrzebny można użyć gwiazdki <code>*</code>,
					z kolei <code>*/n</code> oznacza wykonywanie jeżeli dana wartość jest podzielna przez n. Np.:<br />
						<code>*/20 3  * * 1 ls</code> oznacza wykonanie komendy ls w każdy poniedziałek o godzinie 3:00 3:20 i 3:40
				</p>
				<p>
					Standardowe wyjście, wyjście błędu oraz powiadomienie o niezerowym kodzie powrotu domyślnie są wysyłane na lokalny adres mailowy użytkownika będącego właścicielem danego contaba.
					Niekiedy dostępny jest także <code>anacron</code> pozwalający na mniej precyzyjne planowanie zadań
				</p>
				<!-- END: Planowanie zadań -->
			</section>
			<section>
				<h5>Zdalny dostęp - SSH</h5>
				<p>Serwer SSH zapewnia zdalny, szyfrowany dostęp do komputera na którym jest uruchomiony z innych hostów. Usługa SSH pozwala na kopiowanie plików (sftp, scp, rsync over ssh), tunelowanie protokołu X'ów (serwera środowiska graficznego, dzięki czemu można używać zdalnych aplikacji z GUI) oraz tworzenie szyfrowanych tuneli (nasłuchujących na połączenia przychodzące tak po stronie klienta ssh, jak i serwera ssh).</p>
			</section>
		</section>
	</section>
</section>

<!-- TODO: zabezpieczenia, instalacje, itd
<section>
	<h2>Instalacje zasilania i sieci</h2>
	<section>
		<h3>Węzły</h3>
		<section>
			<h5>zasilania</h5>
			<p></p>
		</section>
		<section>
			<h5>sieci</h5>
			<p></p>
		</section>
		<section>
			<h5>automatyki, monitoringu</h5>
			<p></p>
		</section>
	</section>
	<section>
		<h3>Zabezpieczenia</h3>
		<section>
			<h5>zwarciowe</h5>
			<p></p>
		</section>
		<section>
			<h5>przeciązeniowe</h5>
			<p></p>
		</section>
		<section>
			<h5>przepięciowe</h5>
			<p></p>
		</section>
		<section>
			<h5>różnicoprądowe</h5>
			<p></p>
		</section>
		<section>
			<h5>zabezpieczenia wewnętrzne urządzeń</h5>
			<p>W urządzeniach elektonicznych stosuje się wewnętrzne zabezpieczenia zwarciowe i przeciążeniowe (głównie na wyjściach zasilaczy) oraz przepięciowe (głównie na wejściach zasilania i sygnałów).
				Jako zabezpieczenia przepięciowe stosowane są warystory (oporniki o silnie nieliniowej charakterystyce oporu, zależnej od przyłożonego napięcia) i transile (diody typu Zenera przeznaczone do układów przepięciowych).
				Jako zabezpieczenia przeciążeniowe i zwarciowe używa się bezpieczników topikowych, bezpieczników polimerowych (element o silnie nieliniowej charakterystyce oporu, zależnej od temperatury) lub ograniczników prądu opartych o tranzystor.</p>
		</section>
	</section>
	<section>
		<h3>Ethernet</h3>
		<p></p>
	</section>
</section>
-->

<section>
	<h2>Podsumowanie</h2>
	<p>
		W kontaktach z technologią, byciu dobrym "komputerowcem", elektronikiem, ... najważniejsze wydaje się być <strong>bawienie się technologią</strong>, eksperymentowanie, łączenie i integrowanie różnych systemów i technologii, poznawanie nowego, zagłębianie się w szczegóły aby nie tylko wiedzieć jak to obsłużyć, ale też wiedzieć jak działa, traktowanie problemów jako wyzwań, ... oraz czerpanie z tego radości. Do określenia kogoś o takiej postawie, takim podejściu do techniki, najlepszym terminem byłby <strong>haker</strong>, pomimo iż jest to termin różnie rozumiany, u wielu osób wywołujący negatywne skojarzenia, wydaje się on jednak najbliższy takiej postawie życiowej.
	</p><p>
		Zajmowanie się technologią (a szczególnie z takim nastawieniem) oznacza tak naprawdę ciągłe uczenie się - jeżeli się nie rozwijasz, jeżeli zostajesz w miejscu to tak naprawdę się cofasz. Zatem już od samego początku poznawania świata elektroniki, programowania, komputerów, sieci komputerowych, itp., przy nauce tych dziedzin bardzo istotne (jeżeli nie najistotniejsze) wydaje się bawienie się tym, otwarte podejście do stawianych problemów, <strong>eksperymentowanie</strong> i samodzielne szukanie rozwiązań.
	</p><p>
		Nie ma większego sensu uczenia się szczegółów, konkretnych implementacji, itp na zapas. Jeżeli możemy sobie tylko na to pozwolić warto uczyć się na "żywych" zastosowaniach (rozwiązując problemy, które gdzieś w jakiś sposób samoistnie się pojawiły), przy takiej nauce warto też pamiętać o ogromnych zasobach Internetu. Przy poznawaniu obsługi bądź konfiguracji jakiegoś nowego narzędzia równie istotne jak zapoznanie się z dokumentacją, podręcznikiem jest wypróbowanie różnorakich opcji, ich różnych kombinacji w praktyce, poszukanie takiego sposobu konfiguracji, użytkowania (takiego stylu) jaki jest najbardziej odpowiedni dla nas i dla rozwiązywanego problemu. W rozwiązywaniu konkretnych zagadnień najistotniejsze jest wiedzieć jak się do tego zabrać i umieć dać sobie radę.
	</p><p>
		Wydaje się że właśnie w tych dziedzinach często od wiedzy szczegółowej, ważniejsza jest szeroka wiedza ogólna (oraz oczywiście odpowiednie predyspozycje i chęci), wraz z umiejętnościami szukania informacji (i wiedzą gdzie należy jej szukać). Często nie ma nawet możliwości posiadania pełnej wiedzy na początku rozwiązywania jakiegoś problemu, istotniejsza jest ogólne zrozumienie "jak to działa", umiejętność korzystania z dokumentacji, wyszukiwania i sprawdzania szczegółów oraz umiejętność kombinowania / informatyczny spryt.
		Ważna jest także sporą doza praktyki (rzeczywistość tworzy sytuacje które nie śniłyby się teoretykowi ...) i tak zwane obycie z techniką / technologią. Gdy napotka się jakiś problem należy próbować go rozwiązać, eksperymentować, szukać porady (ale raczej na zasadzie "że chcemy dostać wędkę a nie rybę") i nie żałować na to czasu.
	</p>
	
	<section>
		<h3>Informacja cyfrowa</h3>
		<p>
			Podstawowym zadaniem chyba wszystkich systemów komputerowych i telekomunikacyjnych oraz ogromnej większości systemów elektronicznych jest przetwarzanie lub przekazywanie <strong>informacji</strong>. Obecnie jest to w znacznej większości informacja <strong>cyfrowa</strong> (w odróżnieniu od analogowej jest ona "skwantowana" - sygnał będący jej źródłem zmieniający się w sposób ciągły został poddany procesowi pomiaru i zamiany na liczbę o skończonej dokładności).
			Fakt dyskretyzacji zbioru wartości oraz (możliwe do wprowadzenia dzięki postaci liczbowej) sumy kontrolne umożliwiają wierne kopiowanie informacji. Dzięki wprowadzeniu tego dodatkowego matematycznego poziomu w zapisie informacji odrywamy się po części od ograniczeń naszej fizycznej rzeczywistości; "bity to nie atomy" i fizyka (w szczególności kwantowa) ich nie dotyczy.
		</p>
		<p>
			Podstawową jednostką informacji jest <strong>bit</strong>, mogący przyjmować dwa rozróżnialne stany nazywane zazwyczaj <strong>zero</strong> i <strong>jeden</strong>, będący odpowiedzią typu tak/nie. Przy pomocy mniejszej ilości stanów nie jest możliwe przekazanie informacji (pozornie mogłoby wydawać się że niekiedy wystarczy jeden stan - np. podnosimy n razy chorągiewkę i w ten sposób przekazujemy liczbę n, jednak tutaj też jest ukryty drugi stan - chorągiewka opuszczona). Z stanami tymi łatwo związać odpowiednie stany napięciowe na wejściach/wyjściach układów elektronicznych - np. napięcie powyżej X voltów ("jest napięcie") oznacza 1, napięcie poniżej Y voltów ("brak napięcia") oznacza 0.
			Wydaje się że właśnie z tych dwóch powodów <strong>system dwójkowy</strong> (mający tylko dwie cyfry - 0 i 1) wraz z <strong>logiką dwuwartościową</strong> zyskał tak duże zastosowanie w <strong>elektronice</strong> cyfrowej i komputerach.
		</p>
	</section>
	<section>
		<h3>Elektronika</h3>
		<p>
			Elektronika (zarówno analogowa jak i cyfrowa) zajmuje się zasadniczo przetwarzaniem informacji w postaci sygnałów elektrycznych. Podstawowymi pojęciami jest tutaj prąd (przepływ ładunku) oraz napięcie (<strong>różnica potencjałów</strong> czyli siła ten przepływ wymuszająca). Elementy elektroniczne podzielić możemy na elementy bierne (oporniki, kondensatory, cewki, diody) - wpływające na przepływ prądu w sposób nieregulowany oraz elementy aktywne (których działanie w odróżnieniu od biernych jest regulowane na drodze sygnałów elektrycznych). W elektronice (zwłaszcza cyfrowej) często dużo ważniejszym pojęciem niż prąd jest napięcie, a dokładniej nawet tylko potencjał w odniesieniu do umownego potencjału zerowego - masy (<strong>GND</strong>).
		</p><p>
			Dla przetwarzania danych przez współczesną elektronikę najważniejszym z podstawowych jej elementów wydaje się być <strong>tranzystor</strong> - jest to element o regulowanym poprzez przyłożenie odpowiedniego napięcia oporze elektrycznym (może być zatem wykorzystywany jako elektronicznie sterowany przełącznik). Obecnie większość tranzystorów wchodzących w skład urządzeń znajduje się we wnętrzach układów scalonych, liczących często tysiące czy nawet miliony tranzystorów.
		</p><p>
			Podstawowymi dla techniki cyfrowej układami scalonymi są <strong>bramki logiczne</strong> realizujące poszczególne funkcje logiczne na przetwarzanych sygnałach oraz <strong>rejestry</strong> pozwalające na zapamiętanie stanu (jakiejś informacji). Jednak także i bramki ustąpiły już miejsca <strong>układom programowalnym</strong> złożonym z tysięcy tranzystorów, bramek i tym podobnych elementów - np. programowalnym układom logicznym, procesorom czy też mikrokontrolerom (zawierającym także pamięć zmienną - dla danych programu oraz pamięć do przechowywania samego programu); sprowadzając w zasadzie elektronikę opartą na elementach dyskretnych do roli pomocniczej.
		</p><p>
			Właśnie niczym mniej ani więcej tylko takim programowalnym urządzeniem elektronicznym, o zdolności do przetwarzania znacznych ilości informacji (w postaci liczb) w krótkim czasie (znacznej mocy obliczeniowej), jest współczesny <strong>komputer</strong>. Złożony on jest zasadniczo z procesora, pamięci operacyjnej (wraz z układem odpowiedzialnym za umożliwienie dostępu do niej procesorowi - kontrolerem pamięci) i pamięci stałej (dysk twardy itp.) służącej do przechowywania programów i danych. Niezależnie od roli jaką pełni (maszyna do pisania czy grania, serwer WWW czy też serwer nadzorujący procesy w reaktorze jądrowym, ...) każdy komputer tylko i wyłącznie wykonuje jakiś <strong>program</strong>.
		</p><p>
			Poprzez powyższe twierdzenie, że komputer wykonuje tylko i wyłącznie program będący ciągiem instrukcji, nie twierdzę że nie może istnieć coś takiego jak <strong>sztuczna inteligencja</strong>, a nawet sztuczna świadomość. Obecnie istnieją systemy zdolne do samodzielnej nauki na podstawie historycznych doświadczeń, istnieją systemy decyzyjne oraz wiele innych rozwiązań które w jakimś stopniu można by uważać za inteligentne. Z problemem sztucznej inteligencji związana jest głównie nieprecyzyjność tego terminu (istnienie wielu sprzecznych definicji). Wydaje się, że nawet człowiek nie jest w stanie przekonać innej osoby o tym że jest istotą inteligentną a tym bardziej świadomą gdy tamta przyjmie inne założenie.
		</p>
		<img src="img/uklad_mieszany.svg" class="right_img" style="height:170px;" alt="mieszany układ cyfowo analogowy" />
		<p>
			W rozumieniu elektroniki ważna jest umiejętność przeanalizowania prostego układu, ustalenia / zrozumienia jak on działa.<br/>
			Dla przykładu: obok przedstawiony jest układ wykorzystujący zarówno elementy cyfrowe, jak i analogowe do uzyskania jakiegoś efektu. Jaki jest cel działania tego układu? Jak on działa w szczegółach?
			<ol>
				<li>U1 jest dwu wejściową bramką logiczną AND (na wyjściu zwraca stan logiczny 1 gdy na obu wejściach ma stan logiczny 1, któremu w tym wypadku odpowiada stan wysoki +5V), do jednego z wejść podłączony jest jakiś sygnał sterujący z zewnątrz (P1) do drugiego podłączony jest natomiast przełącznik S1 zwierający do masy.</li>
				<li>Rezystor R1 podłączony do +5V zapewnia iż gdy przełącznik nie jest zwarty to do wejścia bramki przyłożony jest stan wysoki (niektóre z układów scalonych mają takie rozwiązanie zaimplementowane wewnętrznie), a gdy zwieramy S1 to ogranicza płynący prąd - w ten sposób na wejście bramki może być podane logiczne 1 lub zero bez konieczności stosowania przełączania i bez obawy o zrobienie zwarcia.</li>
				<li>Wyjście bramki poprzez kolejny opornik (R2), który ogranicza prąd pobierany z wyjścia układu, steruje tranzystorem NPN T1 (przewodzi on gdy napięcie miedzy bramką (B) a emiterem (E) przekroczy określoną wartość).</li>
				<li>Wprowadzenie tranzystora w stan przewodzenia powoduje przepływ prądu przez LED D1 oraz rezystor R3, który ogranicza ten prąd do wartości odpowiedniej dla D1 (oczywiście także T1 musi być dostosowany do wartości tego prądu); warto tu także zwrócić uwagę na polaryzację D1 (LED jak każda dioda przewodzi tylko w jedną stronę).</li>
				<li>Kondensator C1 wraz z rezystorem R4 (a także R3) powoduje spowolnione wygaszanie D1 - kondensator rozładowuje się przez R4 gdy T1 przewodzi, natomiast po zaprzestaniu przewodzenia przez T1 kondensator ten ładuje się przez R3 i R4 podtrzymując przez pewien czas świecenie diody (dioda przygasa powoli, gdyż spada na niej napięcie w skutek procesu ładowania C1).</li>
			</ol>
		</p>
	</section>
	<section>
		<h3>Programowanie</h3>
		<p>
			Program jest to ciąg instrukcji (głównie operacji matematycznych i logicznych), zapisany w języku zrozumiałym dla danego procesora (kod maszynowy powstający w wyniku kompilacji kodu stworzonego w języku wyższego poziomu). Wśród tych instrukcji szczególne miejsce zajmują instrukcje skoków (warunkowych i bezwarunkowych), one właśnie umożliwiają warunkową realizację fragmentów programu oraz warunkowe powtarzanie (<strong>iterację</strong>) fragmentów programu. Za szczególny przypadek instrukcji skoku można uważać instrukcję wywołania procedury, powodującą przekazanie stosownych informacji i rozpoczęcie wykonywania podprogramu (poprzez warunkowe wywoływanie tej samej procedury z jej wnętrza możemy otrzymać "konkurencyjny" do iteracji sposób powtarzania fragmentu programu - <strong>rekurencję</strong>.
		</p><p>
			Podstawą działania każdego programu jest jakiś <strong>algorytm</strong>, jest to pojęcie trochę bardziej abstrakcyjne niż program (zwłaszcza rozumiany jako kod maszynowy) - ogólnie mówiąc jest to skończony ciąg czynności prowadzących do zrealizowania jakiegoś zadania. Jak już wspomniałem oprócz kodu maszynowego (złożonego z numerów rozkazów i ich parametrów) są również języki programowania. Najbardziej podstawowym jest <strong>asembler</strong>, który pozwala używać łatwiej zrozumiałych dla człowieka nazw zamiast numerów instrukcji, rejestrów (w których procesor przechowuje wartości którymi operuje), ... .
			Jednak jego instrukcje odpowiadają niemalże w 100% instrukcjom procesora (kodowi maszynowemu), dlatego też jest bardzo silnie zależny od danej architektury sprzętowej (modelu procesora), powoduje to problemy z przenoszeniem programów pisanych w asemblerze na inne architektury, to było jednym z powodów stworzenia <strong>języków wyższego poziomu</strong>. W językach takich treść algorytmu wyraża się przy pomocy poleceń danego języka będących bytami bardziej abstrakcyjnymi od instrukcji procesora (np. pojęcie zmiennej i operowanie na niej a nie na miejscach w pamięci i rejestrach). Obecnie asemblera używa się w zastosowaniach wymagających dużej wydajności (zarówno w oddzielnych aplikacjach jak i fragmentach większych programów) bądź dla urządzeń o niewielkich rozmiarach pamięci.
		</p>
	</section>
	<section>
		<h3>Telekomunikacja</h3>
		<p>
			Oprócz przetwarzania informacji liczne systemy zajmują się jej przekazywaniem. Aby mógł zajść proces komunikacji musi istnieć jakieś medium transmisyjne, które będzie odpowiedzialne za fizyczne przekazanie sygnału zawierającego informację. W <strong>telekomunikacji</strong> przekaz ten odbywa się zazwyczaj z wykorzystaniem zjawiska przepływu prądu przez przewodnik (tradycyjna łączność kablowa), bądź rozchodzenia się fali elektromagnetycznej (łączność radiowa, światłowody, ...).
			Bardzo istotne jest dopasowanie parametrów medium transmisyjnego, urządzeń nadawczych i odbiorczych do sygnału który zamierzamy transmitować, na przykład w przypadku kabli jest to częstotliwość którą są one w stanie przenosić bez zakłóceń (głównie ona odpowiada za szybkość transmisji i najczęściej jest rzędu kilkuset MHz) oraz impedancja (wyrażana w omach, sygnały które transmitujemy są sygnałami zmiennymi dlatego jest ona ważnym parametrem przewodu ...). Jednak pomimo to zawsze należy mieć świadomość, że to tylko kabel, który przewodzi elektrony i niezależnie od parametrów jakoś będzie to robił ... .
		</p><p>
			W tradycyjnych systemach telekomunikacyjnych sygnał był bezpośrednio informacją, a jego dotarcie do odbiornika oznaczało że informacja jest przeznaczona dla niego (telefonia) bądź dla każdego (radio, telewizja - systemy rozgłoszeniowe). Obecnie coraz większą rolę odgrywają komutowane <strong>sieci pakietowe</strong>, gdzie informacja nie jest tak ściśle związana z sygnałem.
			Dla przykładu w telefonii zrealizowanie każdego połączenia wymagało zestawienia go - odpowiedniego przełączenia styków w centralach (komutacji łączy); w Internecie informacja podążać może różnymi drogami (nie jest tworzona droga specjalnie dla danego połączenia) i na podstawie adresu odnaleźć host docelowy (jest to komutacja pakietów).
			W sieciach pakietowych właściwa informacja (jeżeli jest zbyt długa) dzielona jest na części, do każdej części dodawane są informacje kontrolne - nagłówek (zawierający m.in. adres odbiorcy). Tak utworzone pakiety podróżują niezależnie od siebie przez sieć do odbiorcy (bez zestawiania w tym celu specjalnego fizycznego połączenia).
		</p><p>
			Bardzo istotnym elementem jest adresacja (jest ona niezbędna aby informacja mogła być kierowana do konkretnego hosta - inaczej mamy sieć rozgłoszeniowa (np. telewizja)): każdy host w sieci musi posiadać unikalny (w ramach tej sieci) adres (chyba zawsze o ustalonej długości - nie jestem w stanie zagwarantować ze ktoś, gdzieś nie stworzył protokołu pakietowego z adresami zmiennej długości), często wydziela się również <strong>podsieci</strong>, posiadają one swój adres (na ogół jest to wspólna część adresu wszystkich hostów podsieci dopełniona zerami), adres określający ile adresów jest w podsieci () oraz adres na który reagować powinien każdy host w tej podsieci (adres rozgłoszeniowy).
			W przypadku chyba najpopularniejszych obecnie <strong>sieci IP</strong> wielość podsieci określana jest przez <strong>maskę podsieci</strong>, która po wykonaniu binarnego AND z dowolnym adresem hosta tej sieci da adres sieci. W związku z tym iż binarnie maska składa się z nieprzerwanego ciągu jedynek oraz nieprzerwanego ciągu zer, jest ona często zapisywana jest w postaci prefixowej, czyli liczby bitów mających wartość jeden.
			W sieciach IP (oprócz samego Internet Protocol - odpowiedzialnego za adresację itp) należy także wspomnieć o protokołach takich jak: ICMP - zapewniającym przesył komunikatów technicznych, oraz <strong>UDP</strong> czy TCP - umożliwiających przesył danych poprzez sieć IP (odpowiedzialne one są m.in. za adresację usług na danym hoście poprzez numery portów, <strong>TCP</strong> czuwa także nad poprawnością transferu - kontroluje czy dane dotarły i czy dotarły nieuszkodzone). Protokół IP oprócz najbardziej dla niego typowej transmisji jeden do jednego (unicast) umożliwia transmisję rozgłoszeniową (broadcast - jeden do wszystkich w sieci) i multicast (jeden do wielu).
		</p><p>
			Oczywiście sieci teleinformatyczne to nie tylko IP - należy koniecznie wspomnieć o protokołach warstw wyższych - takich jak HTTP (sieć Web), SMTP (e-mail), ... - zapewniających realizację typowych usług sieciowych oraz standardach związanych z konkretną realizacją sprzętową sieci - np. ethernet (będący najpopularniejszym standardem sieci lokalnych - LAN).
			Ze sprzętową realizacją sieci wiąże się m.in. pojęcie takie jak <strong>topologia sieci</strong> - czyli zasada łączenia hostów (<strong>gwiazda</strong> - wszystkie do jednego punktu, drzewo - wiele gwiazd łączonych w gwiazdy, <strong>magistrala</strong> - od jednej linii każdy host, ...). Najpopularniejszą obecnie topologią (przekładającą się także na inne instalacje - np. elektryczną, gdzie jednak dalej istotna jest magistrala) jest topologia gwiazdy, gdzie mamy doczynienia z punktami dystrybucyjnymi (w profesjonalnym podejściu realizowanymi w oparciu o szafy krosownicze i specjalnie przeznaczone do tego celu pomieszczenia) od których odchodzą trasy kablowe.
			Przy realizacji systemów telekomunikacyjnych (i innych teleinformatycznych oraz elektrycznych) warto pamiętać o stosownej dokumentacji tak przebiegu tras kablowych, jak i samej instalacji oraz punktów dystrybucyjnych a także przejrzystości i opisaniu samych instalacji.
			Warto tutaj także zwrócić uwagę na "nie informatyczne" bezpieczeństwo takich instalacji obejmujące takie zagadnienia jak zabezpieczenia przeciw pożarowe, przeciw przepięciowe oraz monitoring i kontrolę dostępu do pomieszczeń przeznaczonych na wspomniane instalacje.
		</p>
	</section>
	<section>
	<h3>Oprogramowanie</h3>
		<p>
			Oczywiście aby się zajmować, bawić komputerami, elektroniką, sieciami telekomunikacyjnymi konieczna jest wiedza na temat samej obsługi komputerów - zwłaszcza systemów unix'owatych. W tych systemach poszczególne osoby pracują na własnych kontach (identyfikowanych loginem i chronionych hasłem), szczególnym przypadkiem jest konto super użytkownika "<strong>root</strong>" - służy ono do czynności administracyjnych i umożliwia zrobienie z systemem (niemalże) wszystkiego. Standardowo stosowany jest też znany z adresów e-mail zapis z małpą - umożliwiający globalną identyfikację użytkownika - user@host.domena. Z użytkownikami związane są także uprawnienia - definiowane (w podstawowym wariancie) niezależnie dla właściciela, grupy i wszystkich innych w dziedzinach odczytu, zapisu i wykonania.
		</p><p>
			Powłoka tekstowa oparta jest na poleceniach (będących najczęściej osobnymi programami) do których przekazywane są opcje i argumenty (oddzielane są one - zarówno od siebie jak i od nazwy programu spacjami), opcje na ogół zaczynają się od myślnika (jednoliterowe) bądź dwóch myślników (wieloliterowe), ale są od tego wyjątki. Powłoka umożliwia także pracę w trybie wsadowym (nie interaktywnym) - jest to już język skryptowy sh/bash. Informacje o prawie każdym programie, większości plików konfiguracyjnych oraz funkcjach biblioteki standardowej C można znaleźć w podręczniku systemowym (polecenie <strong>man</strong>).
		</p>
	</section>
	<section>
		<h3>Epilog</h3>
		<p>
			Współczesna technika umożliwia korzystanie z komputera, a nawet tworzenie oprogramowania bez znajomości <strong>niskopoziomowych mechanizmów</strong> działania tych urządzeń. Wydaje się jednak, że aby zrozumieć współczesną technikę, być dobrym programistą, administratorem, ... poznanie tych mechanizmów wydaje się niezbędne (a na pewno jest bardzo pomocne) i jest też niewątpliwie bardzo przydatne gdy chcemy zrobić coś "bliżej sprzętu" ... .
		</p><p>
			Przy robieniu czegokolwiek warto pamiętać o standardach i normach technicznych, one naprawdę są (w zdecydowanej większości) tworzone po to aby ułatwić wszystkim życie (jakby wyglądał Internet gdyby każdy portal używał własnych standardów e-mail i www?). Należy też tak tworzyć, aby to co zrobiliśmy, napisaliśmy było przejrzyste i zrozumiałe dla innych oraz (za parę miesięcy czy lat) dla nas samych - aby kod był czytelny, dobrze skomentowany, a cały projekt posiadał dobrą i szczegółową <strong>dokumentację</strong> (wiem że często się nie chce, ale naprawdę warto ...). Należy się także wystrzegać rozwiązań przekombinowanych, stanowiących przerost formy nad treścią (trzymać się reguły <a href="http://pl.wikipedia.org/wiki/KISS_(reguła)">KISS</a>). Należy pamiętać, że zanim zaczniemy coś pisać warto poszukać czy nie ma czegoś o podobnej funkcji, bądź nie ma jakiś <strong>bibliotek</strong>, które zrobią za nas połowę pracy - nie zawsze warto odkrywać Amerykę na nowo ;-) .
		</p><p>
			Wszystkich czytelników zachęcam także do zapoznania się oprócz samego "vademecum" także z dolinkowanymi materiałami oraz przede wszystkim do dużej porcji obycia z technologią, samodzielnego zgłębiania wybranych zagadnień oraz dużej ilości <strong>praktyki</strong> - bo to właśnie ona w tym wszystkim jest najistotniejsza (a to niestety wymaga dużo czasu).
			Ważne jest aby robić to co się lubi - zawsze lepiej być dobrym sieciowcem z powołania niż kiepskim koderem (i na odwrót). Dokładny kierunek kształcenia nie jest bardzo istotny - lepiej żeby nie był zbyt odległy, ale i tak masy rzeczy trzeba się uczyć samemu. Warto mieć szersze spojrzenie na branże - to że specjalizujesz się np. w sieciach nie oznacza iż podstawy programowania (zarówno web-owego jak i systemowego) czy też elektroniki i innych pokrewnych zagadnień są zbędne - wręcz przeciwnie mogą być dodatkowym atutem (nie tylko w CV ale i w samej pracy). To czego się nauczysz jest Twoje, ale zdobytą wiedzę, doświadczenie warto notować (gdyż zdarza się ponownie odkrywać Amerykę i ze zdziwieniem stwierdzać "to ja się tym zajmowałem 10 lat temu???").
		</p>
	</section>
</section>

<section>
	<h2>Literatura</h2>
	<table class="links">
		<tr class="h2">
			<th style="width: 18%; max-width:120pt; min-width:100pt">
				zakres tematyczny
			</th>
			<th style="width: 25%; max-width:150pt; min-width:100pt">
				nazwa
			</th>
			<th style="width: 10%; max-width:100pt; min-width:50pt">
				autor
			</th>
			<th style="width: 7%; max-width:60pt; min-width:30pt">
				licencja
			</th>
			<th style="width: 26%; min-width:130pt">
				opis
			</th>
			<th style="width: 7%; max-width:60pt; min-width:30pt">
				link
			</th>
			<th style="width: 7%; max-width:60pt; min-width:30pt">
				kopia lokalna
			</th>
		</tr>
		
		<tr class="h3"><th colspan="7">Elektronika</th></tr>
		<tr>
			<td> Elektronika </td>
			<td> Lessons In Electric Circuits </td>
			<td> Tony R. Kuphaldt </td>
			<td> Design Science License </td>
			<td> Rozbudowany podręcznik do elektroniki od podstaw </td>
			<td> <a href="http://www.ibiblio.org/kuphaldt/electricCircuits/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Elektronika </td>
			<td> Electronics </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do elektroniki </td>
			<td> <a href="https://en.wikibooks.org/wiki/Electronics">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Podstawy elektroniki </td>
			<td> Electronics Fundamentals </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik podstaw elektroniki </td>
			<td> <a href="https://en.wikibooks.org/wiki/Electronics_Fundamentals">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> Podstawy elektroniki </td>
			<td> Practical Electronics </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Przewodnik rozumienia i tworzenia obwodów elektronicznych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Practical_Electronics">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> Podstawy elektroniki </td>
			<td> Circuit Idea </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Zbiór wyjaśnień zasad działania popularnych obwodów </td>
			<td> <a href="https://en.wikibooks.org/wiki/Circuit_Idea">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> Teoria obwodów </td>
			<td> Circuit Theory </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do teorii obwodów </td>
			<td> <a href="https://en.wikibooks.org/wiki/Circuit_Theory">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Teoria obwodów </td>
			<td> Metody analizy obwodów liniowych </td>
			<td> Wojciech Meller </td>
			<td> CC-NC-SA </td>
			<td> Podręcznik do teorii obwodów </td>
			<td> <a href="http://teoriaobwodow.edu.pl/pliki-do-pobrania/">PL</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Elektronika analogowa </td>
			<td> Analogue Electronics </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik elektroniki analogowej </td>
			<td> <a href="https://en.wikibooks.org/wiki/Analogue_Electronics">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> Elektronika cyfrowa </td>
			<td> Digital Circuits </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do elektroniki cyfrowej </td>
			<td> <a href="https://en.wikibooks.org/wiki/Digital_Circuits">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> Systemy mikroprocesorowe </td>
			<td> Microprocessor Design </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik projektowania systemów mikroprocesorowe </td>
			<td> <a href="https://en.wikibooks.org/wiki/Microprocessor_Design">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Systemy mikroprocesorowe </td>
			<td> Embedded Systems </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do systemów wbudowanych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Embedded_Systems">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Automatyka </td>
			<td> Control Systems </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do systemów kontroli i sterowania </td>
			<td> <a href="https://en.wikibooks.org/wiki/Control_Systems">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Telekomunikacja </td>
			<td> Communication Systems </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do systemów telekomunikacyjnych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Communication_Systems">EN</a> </td>
			<td> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Podstawy informatyki</th></tr>
		<tr>
			<td> Systemy operacyjne </td>
			<td> Pisanie OS </td>
			<td> Jarosław Pelczar i inni </td>
			<td> CC-SA, oryginał: PD </td>
			<td> Podręcznik przybliżający zagadnienia związane z działaniem i tworzeniem systemów operacyjnych </td>
			<td> <a href="https://pl.wikibooks.org/wiki/Pisanie_OS">PL</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Sterowniki urządzeń </td>
			<td> Linux Device Drivers, Third Edition </td>
			<td> Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman </td>
			<td> CC-NC-SA </td>
			<td> Podręcznik opisujący zagadnienia związane z tworzeniem sterowników urządzeń dla systemu Linux </td>
			<td> <a href="http://www.oreilly.com/openbook/linuxdrive3/book/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Algorytmy i struktury danych </td>
			<td> Algorithms </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Wprowadzenie do algorytmów </td>
			<td> <a href="https://en.wikibooks.org/wiki/Algorithms">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Algorytmy i struktury danych </td>
			<td> Data Structures </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Wprowadzenie do struktur danych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Data_Structures">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Algorytmy i struktury danych </td>
			<td> Algorithm Implementation </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Przykłady implementacji algorytmów </td>
			<td> <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Języki programowania</th></tr>
		<tr>
			<td> C </td>
			<td> C Programming </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania w C </td>
			<td> <a href="https://en.wikibooks.org/wiki/C_Programming">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> C </td>
			<td> A Little C Primer </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania w C </td>
			<td> <a href="https://en.wikibooks.org/wiki/A_Little_C_Primer">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> C++ </td>
			<td> C++ reference </td>
			<td>  </td>
			<td> CC-SA </td>
			<td> Podręcznik referencyjny dla C i C++ </td>
			<td> <a href="http://en.cppreference.com/w/">EN</a> </td>
			<td> </td>
		</tr>
		<!--<tr>
			<td> C++ </td>
			<td> Intro To C++ </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Wprowadzenie do C++ </td>
			<td> <a href="https://en.wikibooks.org/wiki/Intro_To_C%2B%2B">EN</a> </td>
			<td> none </td>
		</tr>-->
		<tr>
			<td> C++ </td>
			<td> C++ Programming </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania w C++ </td>
			<td> <a href="https://en.wikibooks.org/wiki/C++_Programming">EN</a> </td>
			<td> </td>
		</tr>
		<!--<tr>
			<td> C++ </td>
			<td> Modern C++: The Good Parts </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Wprowadzenie do współczesnego C++ </td>
			<td> <a href="https://en.wikibooks.org/wiki/Modern_C%2B%2B:_The_Good_Parts">EN</a> </td>
			<td> none </td>
		</tr>-->
		<tr>
			<td> C i C++ </td>
			<td> Programming Language Concepts Using C and C++ </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik wprowadzający do programowania </td>
			<td> <a href="https://en.wikibooks.org/wiki/Programming_Language_Concepts_Using_C_and_C%2B%2B">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Python </td>
			<td> Byte of Python / Ukąś Pythona</td>
			<td> Swaroop C H </td>
			<td> CC-SA, przykłady: BSD </td>
			<td> Podręcznik programowania w Pythonie </td>
			<td>
				<a href="https://python.swaroopch.com/">EN</a>
				<a href="http://python.edu.pl/byteofpython/index.html">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Python </td>
			<td> Dive into Python / Zanurkuj w Pythonie</td>
			<td> Mark Pilgrim </td>
			<td> GNU FDL </td>
			<td> Podręcznik programowania w Pythonie </td>
			<td>
				<a href="http://www.diveintopython.net/">EN</a>
				<a href="https://pl.wikibooks.org/wiki/Zanurkuj_w_Pythonie">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Python </td>
			<td> How to Think Like a Computer Scientist: Learning with Python </td>
			<td> Peter Wentworth, Jeffrey Elkner, Allen B. Downey, Chris Meyers </td>
			<td> GNU FDL </td>
			<td> Podręcznik programowania w Pythonie </td>
			<td> <a href="http://www.ict.ru.ac.za/Resources/cspw/thinkcspy3/">EN</a> <a href="http://www.openbookproject.net/thinkcs/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Python </td>
			<td> Non-Programmer's Tutorial for Python 3 </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Kurs programowania w Pythonie </td>
			<td> <a href="https://en.wikibooks.org/wiki/Non-Programmer's_Tutorial_for_Python_3">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> PHP </td>
			<td> PHP Programming </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania w PHP </td>
			<td> <a href="https://en.wikibooks.org/wiki/PHP_Programming">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Bash </td>
			<td> Advanced Bash-Scripting Guide </td>
			<td> Mendel Cooper </td>
			<td> PD </td>
			<td> Podręcznik tworzenia skryptów w bashu </td>
			<td> <a href="http://www.tldp.org/guides.html#abs">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> AWK </td>
			<td> GAWK: Effective AWK Programming </td>
			<td> Arnold D. Robbins </td>
			<td> GNU FDL </td>
			<td> Podręcznik dla języka AWK w odmianie GNU </td>
			<td> <a href="https://www.gnu.org/software/gawk/manual/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> AWK </td>
			<td> Opis języka AWK </td>
			<td> T. Przechlewski </td>
			<td> CC-BY-SA type </td>
			<td> Wprowadzenie do programowania w AWK </td>
			<td> <a href="https://archive.org/download/awkman-pl/awkman-pl.pdf">PL</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> AWK </td>
			<td> AWK Reference Card / Ściąga do AWK </td>
			<td> Arnold D. Robbins </td>
			<td> CC-BY-SA type </td>
			<td> Karta referencyjna dla języka AWK </td>
			<td>
				<a href="http://blyx.com/public/docs/reference_cards/awkcard-color.pdf">EN</a>
				<a href="https://archive.org/download/awkrefcard-pl/awkrefcard-pl.pdf">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> JavaScript </td>
			<td> Programming Ajax </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik technologii Ajax </td>
			<td> <a href="https://en.wikibooks.org/wiki/Programming_Ajax">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> języki opisu sprzętu </td>
			<td> Programmable Logic </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania układów logicznych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Programmable_Logic">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> języki opisu sprzętu </td>
			<td> VHDL for FPGA Design </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik programowania układów FPGA w VHDL </td>
			<td> <a href="https://en.wikibooks.org/wiki/VHDL_for_FPGA_Design">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> języki opisu sprzętu </td>
			<td> VHDL quick reference card </td>
			<td> Qualis Design Corporation </td>
			<td> CC-ND-SA type </td>
			<td> Karta referencyjna VHDL </td>
			<td> <a href="https://www.mimuw.edu.pl/~marpe/pul/card_vhdl.pdf">EN</a> </td>
			<td> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Sieci komputerowe</th></tr>
		<tr>
			<td> TCP/IP </td>
			<td> Linux Network Administrator's Guide, 2nd Edition </td>
			<td> Olaf Kirch, Terry Dawson </td>
			<td> GNU FDL </td>
			<td> Podręcznik opisujący zagadnienia związane z sieciami TCP/IP w systemie Linux </td>
			<td>
				<a href="http://www.oreilly.com/openbook/linag2/book/">EN</a>
				<a href="http://www.interklasa.pl/portal/index/subjectpages/informatyka?methid=134631581&amp;page=article&amp;article_id=327828">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> TCP/IP </td>
			<td> Linux Network Administrator's Guide, 3nd Edition </td>
			<td> Olaf Kirch, Terry Dawson </td>
			<td> CC-NC-SA </td>
			<td> Podręcznik opisujący zagadnienia związane z sieciami TCP/IP w systemie Linux </td>
			<td>
				<a href="https://the-eye.eu/public/Books/IT%20Various/linux_network_administrators_guide_3rd_edition.pdf">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> TCP/IP </td>
			<td> Computer network technologies and services </td>
			<td> Lorenzo David, Luca Ghio </td>
			<td> CC_SA </td>
			<td> Podręcznik opisujący zagadnienia związane z sieciami komputerowymi TCP/IP i usługami sieciowymi </td>
			<td>
				<a href="https://upload.wikimedia.org/wikipedia/commons/d/d3/Computer_network_technologies_and_services_lecture_notes.pdf">EN</a>
				<a href="https://en.wikibooks.org/wiki/Computer_network_technologies_and_services">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> TCP/IP </td>
			<td> Routing protocols and architectures </td>
			<td> Luca Ghio </td>
			<td> CC_SA </td>
			<td> Podręcznik opisujący zagadnienia związane z routingiem w sieciach komputerowych </td>
			<td>
				<a href="https://upload.wikimedia.org/wikipedia/commons/f/ff/Protocolli_e_architetture_di_routing_lecture_notes.pdf">EN</a>
				<a href="https://en.wikibooks.org/wiki/Routing_protocols_and_architectures">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Ethernet (LAN) </td>
			<td> Local Area Network design </td>
			<td> Luca Ghio </td>
			<td> CC_SA </td>
			<td> Podręcznik opisujący zagadnienia związane z lokalnymi sieciami komputerowymi </td>
			<td>
				<a href="https://upload.wikimedia.org/wikipedia/commons/f/fb/Progetto_di_reti_locali_lecture_notes.pdf">EN</a>
				<a href="https://en.wikibooks.org/wiki/Local_Area_Network_design">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Telekomunikacja </td>
			<td> Communication Networks </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik sieci komunikacyjnych (nie tylko komputerowych ale także radiowych, telewizyjnych, itp) </td>
			<td> <a href="https://en.wikibooks.org/wiki/Communication_Networks">EN</a> </td>
			<td> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Linux/BSD/Posix</th></tr>
		<tr>
			<td> Polecenia systemów typu Posix </td>
			<td> Unix Toolbox </td>
			<td> Colin Barschel </td>
			<td> CC-SA </td>
			<td> Zbiór użytecznych poleceń systemów Unix/Linux/BSD </td>
			<td> <a href="http://cb.vu/unixtoolbox.xhtml">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Vim </td>
			<td> Ściąga do vi </td>
			<td> T. Przechlewski </td>
			<td> CC-SA type </td>
			<td> Karta referencyjna dla edytora vim </td>
			<td> <a href="https://archive.org/download/virefcard-pl/virefcard-pl.pdf">PL</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Vim </td>
			<td> Ściąga do vi </td>
			<td> Laurent Grégoire </td>
			<td> GNU GPL </td>
			<td> Karta referencyjna dla edytora vim </td>
			<td> <a href="https://tnerual.eriogerg.free.fr/vimqrc.pdf">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Debian </td>
			<td> Debian Reference </td>
			<td> Osamu Aoki </td>
			<td> GNU GPL </td>
			<td> Podręcznik Debiana </td>
			<td> <a href="https://www.debian.org/doc/manuals/debian-reference/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> Debian </td>
			<td> The Debian Administrator's Handbook </td>
			<td> Raphaël Hertzog, Roland Mas </td>
			<td> CC-SA / GNU GPL </td>
			<td> Podręcznik administratora Debiana </td>
			<td>
				<a href="https://debian-handbook.info/get/now/">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Debian </td>
			<td> Debian GNU/Linux Reference Card </td>
			<td> W. Martin Borgert, Holger Wansing </td>
			<td> GNU GPL </td>
			<td> Karta referencyjna dla Debian GNU/Linux </td>
			<td>
				<a href="https://www.debian.org/doc/manuals/refcard/refcard.en.pdf">EN</a>
				<a href="https://www.debian.org/doc/manuals/refcard/refcard.pl.pdf">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> FreeBSD </td>
			<td> FreeBSD Handbook </td>
			<td>  </td>
			<td> BSD-type </td>
			<td> Podręcznik dla systemu FreeBSD </td>
			<td>
				<a href="ftp://ftp.freebsd.org/pub/FreeBSD/doc/handbook/book.pdf">EN</a>
				<a href="ftp://ftp.freebsd.org/pub/FreeBSD/doc/pl/books/handbook/book.pdf">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Arch </td>
			<td> Arch Linux Wiki </td>
			<td>  </td>
			<td> GNU FDL </td>
			<td> Dokumentacja dla Arch Linux </td>
			<td>
				<a href="https://wiki.archlinux.org/">EN</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> PLD Linux </td>
			<td> Podręcznik użytkownika, administratora i twórcy </td>
			<td>  </td>
			<td> GNU FDL </td>
			<td> Podręcznik dla PLD Linux Distribution </td>
			<td>
				<a href="http://pl.docs.pld-linux.org/pld_dok.html">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> Linux </td>
			<td> Linux Networking </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik sieci w środowisku Linux </td>
			<td> <a href="https://en.wikibooks.org/wiki/Linux_Networking">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Języki zapytań i oznaczeń</th></tr>
		<tr>
			<td> SQL </td>
			<td> Structured Query Language </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik do języka zapytań baz danych SQL </td>
			<td> <a href="https://en.wikibooks.org/wiki/Structured_Query_Language">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td> wyrażenia regularne </td>
			<td> Regular Expressions </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik wyrażeń regularnych </td>
			<td> <a href="https://en.wikibooks.org/wiki/Regular_Expressions">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> XML </td>
			<td> XML Schema </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik Schcemy XML </td>
			<td> <a href="https://en.wikibooks.org/wiki/XML_Schema">EN</a> </td>
			<td> <!-- only in 2015 --> </td>
		</tr>
		<tr>
			<td> LaTeX </td>
			<td> The Not So Short Introduction to LaTeX / Nie za krótkie wprowadzenie do systemu LaTeX </td>
			<td> Tobias Oetiker, Hubert Partl, Irene Hyna, Elisabeth Schlegl </td>
			<td> GNU GPL </td>
			<td> Podręcznik wprowadzający do systemu składu tekstu LaTeX </td>
			<td>
				<a href="https://www.ctan.org/tex-archive/info/lshort/english/">EN</a>
				<a href="https://www.ctan.org/tex-archive/info/lshort/polish">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td> LaTeX </td>
			<td> LaTeX </td>
			<td> wikibooks.org </td>
			<td> CC-SA </td>
			<td> Podręcznik wprowadzający do systemu składu tekstu LaTeX </td>
			<td> <a href="https://en.wikibooks.org/wiki/LaTeX">EN</a> </td>
			<td> </td>
		</tr>
		
		<tr class="h3"><th colspan="7">Inne, ogólne, wielotematyczne</th></tr>
		<tr>
			<td> aparatura przemysłowa </td>
			<td> Lessons In Industrial Instrumentation </td>
			<td> Tony R. Kuphaldt </td>
			<td> Design Science License </td>
			<td> Rozbudowany podręcznik do aparatury przemysłowej od podstaw </td>
			<td> <a href="http://www.ibiblio.org/kuphaldt/socratic/sinst/">EN</a> </td>
			<td> </td>
		</tr>
		<tr>
			<td>  </td>
			<td> Wikipedia </td>
			<td>  </td>
			<td> CC-SA </td>
			<td> Otwarta, wolna, wielojęzyczna encyklopedia </td>
			<td>
				<a href="https://en.wikipedia.org/wiki/">EN</a>
				<a href="https://pl.wikipedia.org/wiki/">PL</a>
			</td>
			<td> </td>
		</tr>
		<tr>
			<td></td>
			<td> opcode.eu.org </td>
			<td> Robert Paciorek </td>
			<td> BSD/MIT-type </td>
			<td> Serwis internetowy poświęcony różnym zagadnieniom z elektroniki, programowania, sieci i instalacji budynkowych </td>
			<td> <a href="http://opcode.eu.org/">PL</a> </td>
			<td> </td>
		</tr>
<!--
		<tr>
			<td>  </td>
			<td>  </td>
			<td>  </td>
			<td>  </td>
			<td>  </td>
			<td> <a href="">PL</a> </td>
			<td> </td>
		</tr>
-->
	</table>
<!--
	https://en.wikibooks.org/wiki/Semiconductors - mocno niekompletny
-->
</section>

<section id="licencja">
	<h2>Licencja</h2>
<pre>
<b>Copyright (c) 2003-2019, Robert Ryszard Paciorek &lt;rrp@opcode.eu.org&gt;</b>

To jest wolny i otwarty dokument/oprogramowanie. Redystrybucja, użytkowanie
i/lub modyfikacja SĄ DOZWOLONE na warunkach licencji MIT.

This is free and open document/software. Redistribution, use and/or modify
ARE PERMITTED under the terms of the MIT license.


<b>The MIT License:</b>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</pre>
</section>

</body>
</html>
